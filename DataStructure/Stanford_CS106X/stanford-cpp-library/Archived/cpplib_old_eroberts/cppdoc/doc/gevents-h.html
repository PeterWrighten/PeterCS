<html>
<head>
<title>include/gevents.h</title>
<link rel="stylesheet" type="text/css" href="cppdoc.css" />
</head>
<body>
<pre class=code>
<scan class=comment>/*
 * File: gevents.h
 * ---------------
 * This interface defines the event types used in the StanfordCPPLib
 * graphics libraries.  The structure of this package is adapted from the
 * Java event model.
 */
</scan>
#ifndef _gevents_h
#define _gevents_h

#include "gwindow.h"

<a name="Type:EventClassType"><scan class=comment>/*
 * Type: EventClassType
 * --------------------
 * This enumeration type defines the event classes.
 */
</scan>
enum EventClassType {
   NULL_EVENT,         <scan class=comment>/* Indicates an uninitialized event              */</scan>
   WINDOW_EVENT,       <scan class=comment>/* Indicates a window-system event               */</scan>
   ACTION_EVENT,       <scan class=comment>/* Indicates an event with an associated action  */</scan>
   TIMER_EVENT,        <scan class=comment>/* Indicates an interval timer event             */</scan>
   MOUSE_EVENT,        <scan class=comment>/* Indicates a mouse event                       */</scan>
   KEY_EVENT           <scan class=comment>/* Indicates an event generated by the keyboard  */</scan>
};

<a name="Type:WindowEventType"><scan class=comment>/*
 * Type: WindowEventType
 * ---------------------
 * This enumeration type defines the event types for window events.
 */
</scan>
enum WindowEventType {
   WINDOW_ACTIVATED,   <scan class=comment>/* Generated when the window gains focus         */</scan>
   WINDOW_CLOSED,      <scan class=comment>/* Generated when the window is finally closed   */</scan>
   WINDOW_CLOSING,     <scan class=comment>/* Generated when the user clicks the close box  */</scan>
   WINDOW_DEACTIVATED, <scan class=comment>/* Generated when the window loses focus         */</scan>
   WINDOW_DEICONIFIED, <scan class=comment>/* Generated when the window is expanded         */</scan>
   WINDOW_ICONIFIED,   <scan class=comment>/* Generated when the window is minimized        */</scan>
   WINDOW_OPENED       <scan class=comment>/* Generated when the window is opened           */</scan>
};

<a name="Type:ActionEventType"><scan class=comment>/*
 * Type: ActionEventType
 * ---------------------
 * This enumeration type defines the event types for action events.
 */
</scan>
enum ActionEventType {
   ACTION_PERFORMED    <scan class=comment>/* Generated when a user action is performed     */</scan>
};

<a name="Type:TimerEventType"><scan class=comment>/*
 * Type: TimerEventType
 * --------------------
 * This enumeration type defines the event types for timer events.
 */
</scan>
enum TimerEventType {
   TIMER_TICKED        <scan class=comment>/* Generated when the interval timer ticks       */</scan>
};

<a name="Type:MouseEventType"><scan class=comment>/*
 * Type: MouseEventType
 * --------------------
 * This enumeration type defines the event types for mouse events.
 */
</scan>
enum MouseEventType {
   MOUSE_PRESSED,      <scan class=comment>/* Generated when the mouse button is pressed     */</scan>
   MOUSE_RELEASED,     <scan class=comment>/* Generated when the mouse button is released    */</scan>
   MOUSE_CLICKED,      <scan class=comment>/* Generated on clicks after PRESSED and RELEASED */</scan>
   MOUSE_MOVED,        <scan class=comment>/* Generated when the mouse is moved              */</scan>
   MOUSE_DRAGGED       <scan class=comment>/* Generated on mouse motion with the button down */</scan>
};

<a name="Type:KeyEventType"><scan class=comment>/*
 * Type: KeyEventType
 * ------------------
 * This enumeration type defines the event types for keyboard events.
 */
</scan>
enum KeyEventType {
   KEY_PRESSED,        <scan class=comment>/* Generated when a key is pressed                */</scan>
   KEY_RELEASED,       <scan class=comment>/* Generated when a key is released               */</scan>
   KEY_TYPED           <scan class=comment>/* Generated after PRESSED and RELEASED on a key  */</scan>
};

<a name="Type:ModifierCodes"><scan class=comment>/*
 * Type: ModifierCodes
 * -------------------
 * This enumeration type defines a set of constants used to check whether
 * modifiers are in effect.
 */
</scan>
enum ModifierCodes {
   SHIFT_DOWN     = 1 &lt;&lt; 0,
   CTRL_DOWN      = 1 &lt;&lt; 1,
   META_DOWN      = 1 &lt;&lt; 2,
   ALT_DOWN       = 1 &lt;&lt; 3,
   ALT_GRAPH_DOWN = 1 &lt;&lt; 4,
   BUTTON1_DOWN   = 1 &lt;&lt; 5,
   BUTTON2_DOWN   = 1 &lt;&lt; 6,
   BUTTON3_DOWN   = 1 &lt;&lt; 7
};

<a name="Type:KeyCodes"><scan class=comment>/*
 * Type: KeyCodes
 * --------------
 * This enumeration type defines the constants for the special keys on the
 * keyboard.  These values begin after the char range.
 */
</scan>
enum KeyCodes {
   ESCAPE_KEY = 256,
   DELETE_KEY,
   TAB_KEY,
   RETURN_KEY,
   CLEAR_KEY,
   ENTER_KEY,
   UP_ARROW_KEY,
   DOWN_ARROW_KEY,
   LEFT_ARROW_KEY,
   RIGHT_ARROW_KEY,
   HELP_KEY,
   HOME_KEY,
   PAGE_UP_KEY,
   PAGE_DOWN_KEY,
   FORWARD_DEL_KEY,
   END_KEY,
   F1_KEY,
   F2_KEY,
   F3_KEY,
   F4_KEY,
   F5_KEY,
   F6_KEY,
   F7_KEY,
   F8_KEY,
   F9_KEY,
   F10_KEY,
   F11_KEY,
   F12_KEY,
   F13_KEY,
   F14_KEY,
   F15_KEY,
};

<scan class=comment>/* Forward definitions */</scan>

class GWindowEvent;
class GActionEvent;
class GTimerEvent;
class GMouseEvent;
class GKeyEvent;

<a name="Class:GEvent"><scan class=comment>/*
 * Class: GEvent
 * -------------
 * This class is the root of the hierarchy for all events.  The primary
 * purpose of this general class is as the parameter to the waitForEvent
 * and getNextEvent functions.  Code that uses these functions to wait for
 * events of more than one class must typically cast the event to the
 * appropriate subclass, as illustrated in the sample code that accompanies
 * the prototypes for those functions.
 */
</scan>
class GEvent {

public:

<a name="Constructor:GEvent"><scan class=comment>/*
 * Constructor: GEvent
 * Usage: GEvent event;
 * --------------------
 * Ensures that an event is properly initialized to a NULL event.
 */
</scan>
   GEvent();

<a name="Method:getEventClass"><scan class=comment>/*
 * Method: getEventClass
 * Usage: EventClassType eventClass = e.getEventClass();
 * -----------------------------------------------------
 * Returns the enumerated type constant indicating the class of the event.
 */
</scan>
   EventClassType getEventClass();

<a name="Method:getEventTime"><scan class=comment>/*
 * Method: getEventTime
 * Usage: double time = e.getEventTime();
 * --------------------------------------
 * Returns the system time in milliseconds at which the event occurred.  To
 * ensure portability among systems that represent time in different ways,
 * the StanfordCPPLib packages use type double to represent time, which is
 * always encoded as the number of milliseconds that have elapsed since
 * 00:00:00 UTC on January 1, 1970, which is the conventional zero point
 * for computer-based time systems.
 */
</scan>
   double getEventTime();

<a name="Method:getModifiers"><scan class=comment>/*
 * Method: getModifiers
 * Usage: int modifiers = e.getModifiers();
 * ----------------------------------------
 * Returns an integer whose bits indicate what modifiers are in effect.  To
 * check whether the shift key is down, for example, one could use the
 * following code:
 *
 *    if (e.getModifiers() &amp; SHIFT_DOWN) . . .
 */
</scan>
   int getModifiers();

<a name="Method:toString"><scan class=comment>/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */
</scan>
   virtual string toString();

<a name="Operator:bool"><scan class=comment>/*
 * Operator: bool
 * Usage: if (e) . . .
 * -------------------
 * Converts the event to a Boolean value which is true if the event is
 * valid.
 */
</scan>
   operator bool();

#include "private/geventpriv.h"

};

<a name="Function:startIntervalTimer"><scan class=comment>/*
 * Function: startIntervalTimer
 * Usage: startIntervalTimer(delay);
 *        startIntervalTimer(delay, count);
 * ----------------------------------------
 * Starts an interval timer that fires a timer event repeatedly every delay
 * milliseconds.  The count parameter, if specified, indicates the maximum
 * number of events to fire; if this parameter is missing, the timer
 * continues to fire until it is stopped.
 */
</scan>
void startIntervalTimer(double delay);
void startIntervalTimer(double delay, int count);

<a name="Function:stopIntervalTimer"><scan class=comment>/*
 * Function: stopIntervalTimer
 * Usage: stopIntervalTimer();
 * ---------------------------
 * Stops the interval timer.
 */
</scan>
void stopIntervalTimer();

<a name="Function:postEvent"><scan class=comment>/*
 * Function: postEvent
 * Usage: postEvent(e);
 * --------------------
 * Adds the event to the end of the event queue.
 */
</scan>
void postEvent(GEvent e);

<a name="Function:waitForEvent"><scan class=comment>/*
 * Function: waitForEvent
 * Usage: waitForEvent(e);
 * -----------------------
 * Dismisses the process until an event occurs.  When it does, the
 * waitForEvent function returns with the details of the event.  The
 * parameter e can be either a general GEvent variable or one of the
 * specific subclasses.  In the former case, the function returns when any
 * event occurs.  Clients should use this approach if they need to respond
 * to more than one class of event.  As an example, the following code is
 * the canonical event loop for an animated application that needs to
 * respond to mouse, key, and timer events:
 *
 *    startIntervalTimer(ANIMATION_DELAY_IN_MILLISECONDS);
 *    while (true) {
 *       GEvent e;
 *       waitForEvent(e);
 *       switch (e.getEventClass()) {
 *        case TIMER_EVENT:
 *          takeAnimationStep();
 *          break;
 *        case MOUSE_EVENT:
 *          handleMouseEvent(GMouseEvent(e));
 *          break;
 *        case KEY_EVENT:
 *          handleKeyEvent(GKeyEvent(e));
 *          break;
 *       }
 *    }
 *
 * For applications that are interested only in mouse events, for example,
 * this code can be simplified as follows:
 *
 *    while (true) {
 *       GMouseEvent e;
 *       waitForEvent(e);
 *       handleMouseEvent(e);
 *    }
 */
</scan>
void waitForEvent(GEvent &amp; e);
void waitForEvent(GWindowEvent &amp; e);
void waitForEvent(GActionEvent &amp; e);
void waitForEvent(GTimerEvent &amp; e);
void waitForEvent(GMouseEvent &amp; e);
void waitForEvent(GKeyEvent &amp; e);

<a name="Function:waitForClick"><scan class=comment>/*
 * Function: waitForClick
 * Usage: waitForClick();
 *        waitForClick(mouseEvent);
 * --------------------------------
 * Waits for a mouse click to occur anywhere in the window, discarding any
 * other events.  If the client passes a GMouseEvent as a reference
 * parameter, the function will fill in the details of the click event.
 */
</scan>
void waitForClick();
void waitForClick(GMouseEvent &amp; mouseEvent);

<a name="Function:getNextEvent"><scan class=comment>/*
 * Function: getNextEvent
 * Usage: if (getNextEvent(e)) . . .
 * ---------------------------------
 * Checks to see if there are any events waiting on the event queue.  If
 * so, getNextEvent fills in the structure of the event with the first
 * event in the queue and returns true.  If there are no events,
 * getNextEvent returns false.  As with waitForEvent, the parameter e can
 * be either a GEvent variable or one of the specific subclasses.  Clients
 * should use this form of the call if they need to support animation in
 * the main thread, as in the following code example:
 *
 *    while (true) {
 *       GEvent e;
 *       if (getNextEvent(e)) {
 *          switch (e.getEventClass()) {
 *           case MOUSE_EVENT:
 *             handleMouseEvent(GMouseEvent(e));
 *             break;
 *           case KEY_EVENT:
 *             handleKeyEvent(GKeyEvent(e));
 *             break;
 *          }
 *       } else {
 *          takeAnimationStep();
 *       }
 *    }
 */
</scan>
bool getNextEvent(GEvent &amp; e);
bool getNextEvent(GWindowEvent &amp; e);
bool getNextEvent(GActionEvent &amp; e);
bool getNextEvent(GTimerEvent &amp; e);
bool getNextEvent(GMouseEvent &amp; e);
bool getNextEvent(GKeyEvent &amp; e);

<a name="Class:GWindowEvent"><scan class=comment>/*
 * Class: GWindowEvent
 * -------------------
 * This event subclass represents a window event.
 */
</scan>
class GWindowEvent : public GEvent {

public:

<a name="Constructor:GWindowEvent"><scan class=comment>/*
 * Constructor: GWindowEvent
 * Usage: GWindowEvent windowEvent;
 *        GWindowEvent windowEvent(e);
 *        GWindowEvent windowEvent(type, gw);
 * ------------------------------------------
 * Creates a GWindowEvent using the specified parameters or those taken
 * from the more general event e.
 */
</scan>
   GWindowEvent();
   GWindowEvent(GEvent e);
   GWindowEvent(WindowEventType type, GWindow gw);

<a name="Method:getEventType"><scan class=comment>/*
 * Method: getEventType
 * Usage: WindowEventType type = e.getEventType();
 * -----------------------------------------------
 * Returns the enumerated type constant corresponding to the specific type
 * of window event.
 */
</scan>
   WindowEventType getEventType();

<a name="Method:getWindow"><scan class=comment>/*
 * Method: getWindow
 * Usage: GWindow gw = e.getWindow();
 * ----------------------------------
 * Returns the graphics window in which this event occurred.
 */
</scan>
   GWindow getWindow();

<a name="Method:toString"><scan class=comment>/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */
</scan>
   string toString();

};

<a name="Class:GActionEvent"><scan class=comment>/*
 * Class: GActionEvent
 * -------------------
 * This event subclass represents an action event.
 */
</scan>
class GActionEvent : public GEvent {

public:

<a name="Constructor:GActionEvent"><scan class=comment>/*
 * Constructor: GActionEvent
 * Usage: GActionEvent actionEvent;
 *        GActionEvent actionEvent(e);
 *        GActionEvent actionEvent(type, actionCommand);
 * -----------------------------------------------------
 * Creates a GActionEvent using the specified parameters or those taken
 * from the more general event e.
 */
</scan>
   GActionEvent();
   GActionEvent(GEvent e);
   GActionEvent(ActionEventType type, string actionCommand);

<a name="Method:getEventType"><scan class=comment>/*
 * Method: getEventType
 * Usage: ActionEventType type = e.getEventType();
 * -----------------------------------------------
 * Returns the enumerated type constant corresponding to the specific type
 * of action event.
 */
</scan>
   ActionEventType getEventType();

<a name="Method:getActionCommand"><scan class=comment>/*
 * Method: getActionCommand
 * Usage: string cmd = e.getActionCommand();
 * -----------------------------------------
 * Returns the action command associated with this event.
 */
</scan>
   string getActionCommand();

<a name="Method:toString"><scan class=comment>/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */
</scan>
   string toString();

};

<a name="Class:GTimerEvent"><scan class=comment>/*
 * Class: GTimerEvent
 * ------------------
 * This event subclass represents a timer event.
 */
</scan>
class GTimerEvent : public GEvent {

public:

<a name="Constructor:GTimerEvent"><scan class=comment>/*
 * Constructor: GTimerEvent
 * Usage: GTimerEvent timerEvent;
 *        GTimerEvent timerEvent(e);
 *        GTimerEvent timerEvent(type);
 * ------------------------------------
 * Creates a GTimerEvent.
 */
</scan>
   GTimerEvent();
   GTimerEvent(GEvent e);
   GTimerEvent(TimerEventType type);

<a name="Method:getEventType"><scan class=comment>/*
 * Method: getEventType
 * Usage: TimerEventType type = e.getEventType();
 * ----------------------------------------------
 * Returns the enumerated type constant corresponding to the specific type
 * of timer event.
 */
</scan>
   TimerEventType getEventType();

<a name="Method:toString"><scan class=comment>/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */
</scan>
   string toString();

};

<a name="Class:GMouseEvent"><scan class=comment>/*
 * Class: GMouseEvent
 * ------------------
 * This event subclass represents a mouse event.
 */
</scan>
class GMouseEvent : public GEvent {

public:

<a name="Constructor:GMouseEvent"><scan class=comment>/*
 * Constructor: GMouseEvent
 * Usage: GMouseEvent mouseEvent;
 *        GMouseEvent mouseEvent(e);
 *        GMouseEvent mouseEvent(type, x, y);
 * ------------------------------------------
 * Creates a GMouseEvent using the specified parameters or those taken from
 * the more general event e.
 */
</scan>
   GMouseEvent();
   GMouseEvent(GEvent e);
   GMouseEvent(MouseEventType type, double x, double y);

<a name="Method:getEventType"><scan class=comment>/*
 * Method: getEventType
 * Usage: MouseEventType type = e.getEventType();
 * ----------------------------------------------
 * Returns the enumerated type constant corresponding to the specific type
 * of mouse event.
 */
</scan>
   MouseEventType getEventType();

<a name="Method:getX"><scan class=comment>/*
 * Method: getX
 * Usage: double x = getX();
 * -------------------------
 * Returns the x coordinate at which the event occurred relative to the
 * window origin at the upper left corner of the window.
 */
</scan>
   double getX();

<a name="Method:getY"><scan class=comment>/*
 * Method: getY
 * Usage: double y = getY();
 * -------------------------
 * Returns the y coordinate at which the event occurred relative to the
 * window origin at the upper left corner of the window.
 */
</scan>
   double getY();

<a name="Method:toString"><scan class=comment>/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */
</scan>
   string toString();

};

<a name="Class:GKeyEvent"><scan class=comment>/*
 * Class: GKeyEvent
 * ----------------
 * This event subclass represents a key event.
 */
</scan>
class GKeyEvent : public GEvent {

public:

<a name="Constructor:GKeyEvent"><scan class=comment>/*
 * Constructor: GKeyEvent
 * Usage: GKeyEvent keyEvent;
 *        GKeyEvent keyEvent(e);
 *        GKeyEvent keyEvent(type, key);
 * -------------------------------------
 * Creates a GKeyEvent using the specified parameters or those taken from
 * the more general event e.
 */
</scan>
   GKeyEvent();
   GKeyEvent(GEvent e);
   GKeyEvent(KeyEventType type, int key);

<a name="Method:getEventType"><scan class=comment>/*
 * Method: getEventType
 * Usage: KeyEventType type = e.getEventType();
 * --------------------------------------------
 * Returns the enumerated type constant corresponding to the specific type
 * of key event.
 */
</scan>
   KeyEventType getEventType();

<a name="Method:getKey"><scan class=comment>/*
 * Method: getKey
 * Usage: int key = getKey();
 * --------------------------
 * Returns the integer code associated with the key in the event.
 */
</scan>
   int getKey();

<a name="Method:getChar"><scan class=comment>/*
 * Method: getChar
 * Usage: char ch = e.getChar();
 * -----------------------------
 * Returns the character code for the key value after applying modifier
 * keys.  For example, if the user types the 'a' key with the shift key
 * down, getChar will return 'A'.  If the key code in the event does not
 * correspond to a character, getChar returns the null character ('\0').
 */
</scan>
   char getChar();

<a name="Method:toString"><scan class=comment>/*
 * Method: toString
 * Usage: string str = e.toString();
 * ---------------------------------
 * Converts the event to a human-readable representation of the event.
 */
</scan>
   string toString();

};

#endif
</pre>
</body>
</html>
