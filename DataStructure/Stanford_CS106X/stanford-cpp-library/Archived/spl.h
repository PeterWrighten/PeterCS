// Stanford C++ library (extracted)
// @author Marty Stepp
// @version Sat Oct 12 18:21:52 PDT 2019
//
// This library has been merged into a single .h and .cpp file by an automatic script
// to make it easier to include and use with the CodeStepByStep tool.
// DO NOT EDIT THIS FILE DIRECTLY!
// If you want to make changes or additions to the Stanford C++ library,
// make them to the library's original source as separate .cpp / .h files,
// then re-run the script to extract the library into these single large merged files.

#define STANFORD_CPP_LIB_PRESENT true

using namespace std;

/////////////////////// BEGIN code extracted from StanfordCPPLib/private/init.h ///////////////////////
/*
 * File: init.h
 * ------------
 * This file contains code to check whether the Stanford C++ library has been
 * initialized, and if not, to initialize it.
 * This file must be included by every student-facing header in the Stanford
 * C++ library to make sure that the library is initialized before it is used.
 *
 * There used to be a group of files such as private/main.h, main.cpp, and
 * startup.cpp that contained various initialization code.  These were removed
 * and replaced with this style of initialization for the following reasons:
 *
 * - simplicity/consolidation
 * - allow student to NOT include console.h and use plain text console
 *
 * @version 2018/08/28
 * - refactor to use stanfordcpplib namespace and init.cpp
 * @version 2018/07/03
 * - add code to handle Qt GUI library initialization
 * @version 2017/04/25
 * - wrap library initializer in an #ifndef to avoid multiple declaration
 *
 * TODO: figure out how to support both 0-arg and 2-arg main()
 */

#ifndef _init_h
#define _init_h

#include <cstdlib>
#include <functional>
#include <stdio.h>

namespace stanfordcpplib {

/**
 * Returns true if the std::exit function is enabled.
 * This will be true unless disabled by, say, an autograder.
 */
bool exitEnabled();

/**
 * Initializes the Stanford C++ library.
 * A call to this function is inserted before the student's main() runs.
 * This should be run from the Qt GUI (main) thread.
 */
void initializeLibrary(int argc, char** argv);

/**
 * This is for any initialization that needs to be done in the student's thread
 * rather than on the Qt GUI main thread.
 * Currently this is used primarily to set up exception handlers for the
 * student's thread so we can print usable stack traces.
 */
void initializeLibraryStudentThread();

/**
 * Runs the student's main function in its own thread, creating that thread
 * as an object of type GThread.
 */
void runMainInThread(int (* mainFunc)(void));

/**
 * Runs the student's main function in its own thread, creating that thread
 * as an object of type GThread.
 */
void runMainInThread(std::function<int()> mainFunc);

/**
 * Runs the student's main function in its own thread, creating that thread
 * as an object of type GThread.
 */
void runMainInThreadVoid(void (* mainFuncVoid)(void));

/**
 * Runs the student's main function in its own thread, creating that thread
 * as an object of type GThread.
 */
void runMainInThreadVoid(std::function<void()> mainFuncVoid);

/**
 * Sets whether the std::exit function will be enabled or not.
 * If disabled, an error() will be thrown if student tries to exit().
 */
void setExitEnabled(bool enabled);

/**
 * Shuts down the Stanford C++ library.
 * A call to this function is inserted after the student's main().
 */
void shutdownLibrary();

/**
 * Performs any initialization needed by the library during static-init phase,
 * which occurs before main() is launched.
 * The StanfordCppLibraryInitializer class below helps us do this properly.
 */
void staticInitializeLibrary();

#ifndef StanfordCppLibraryInitializer_created
#define StanfordCppLibraryInitializer_created
class StanfordCppLibraryInitializer {
public:
    /*
     * Code to initialize the library.
     * Implemented as a class constructor so that it will run before the
     * student's main function.
     * Here we put anything that we need to initialize during the static
     * phase before main() runs.
     * Presently there is nothing that requires such initialization,
     * so this is blank.
     */
    StanfordCppLibraryInitializer() {
        staticInitializeLibrary();
    }
};
static StanfordCppLibraryInitializer __stanfordcpplib_init;
#endif // __StanfordCppLibraryInitializer_created

} // namespace stanfordcpplib

// bypass std::exit function
namespace std {
void __stanfordcpplib__exitLibrary(int status);
} // namespace std

#define STD_EXIT __std_exit_function_
#define exit __stanfordcpplib__exitLibrary

#ifdef SPL_HEADLESS_MODE

#endif // SPL_HEADLESS_MODE

#ifdef SPL_OVERLOAD_PROBLEMATIC_POINTER_ARITHMETIC

#endif // SPL_OVERLOAD_PROBLEMATIC_POINTER_ARITHMETIC

#endif // _init_h

/////////////////////// END code extracted from StanfordCPPLib/private/init.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/private/static.h ///////////////////////
/*
 * File: static.h
 * --------------
 * This file provides several macros for declaring static variables and functions
 * in ways that are safe for usage during the C++ static initiialization phase.
 * These macros should be used to declare all not-inside-function static data
 * used by the library, since a lot of library code runs during the
 * static initialization phase.
 *
 * @version 2017/10/05
 * - added STATIC_VARIABLE_NAMESPACE
 */

#ifndef _static_h
#define _static_h

// macros for concatenating two macros
#ifndef CONCAT_IMPL
#define MACRO_CONCAT(a, ...) PRIMITIVE_CONCAT(a, __VA_ARGS__)
#define PRIMITIVE_CONCAT(a, ...) a ## __VA_ARGS__
#define MACRO_IDENT(x) x
#endif // CONCAT_IMPL

// declare static var/func and assign it the given value
#define STATIC_VARIABLE_DECLARE(type, name, value) \
    static type & s_##name() { \
        static type __##name = (value); \
        return __##name; \
    }

// declare but don't assign a value (use type's default value)
#define STATIC_VARIABLE_DECLARE_BLANK(type, name) \
    static type & s_##name() { \
        static type __##name; \
        return __##name; \
    }

// declare static const var/func and assign it the given value
#define STATIC_CONST_VARIABLE_DECLARE(type, name, value) \
    static const type & s_##name() { \
        static const type __##name = (value); \
        return __##name; \
    }

// declare static var/func collection and assign it the given elements
// (these seem to not work for multi-template collections like Map<K, V>  :-/
//  but they work for single-template collections like Vector<E>)
#define STATIC_VARIABLE_DECLARE_COLLECTION(type, name, ...) \
    static type & s_##name() { \
        static type __##name = { __VA_ARGS__ }; \
        return __##name; \
    }

// declare static var/func collection and leave it empty
#define STATIC_VARIABLE_DECLARE_COLLECTION_EMPTY(type, name) \
    static type & s_##name() { \
        static type __##name; \
        return __##name; \
    }

#define STATIC_VARIABLE_DECLARE_MAP_EMPTY(maptype, keytype, valuetype, name) \
    static maptype < keytype , valuetype > & s_##name() { \
        static maptype < keytype , valuetype > __##name; \
        return __##name; \
    }

// declare static const var/func collection and assign it the given elements
#define STATIC_CONST_VARIABLE_DECLARE_COLLECTION(type, name, ...) \
    static const type & s_##name() { \
        static const type __##name { __VA_ARGS__ }; \
        return __##name; \
    }

// look up the value of the given static variable (by calling its static s_ function)
#define STATIC_VARIABLE(name) \
    (s_##name())

// look up the value of the given static variable in another namespace
#define STATIC_VARIABLE_NAMESPACE(namespacename, name) \
    (namespacename::s_##name())

#endif // _static_h

/////////////////////// END code extracted from StanfordCPPLib/private/static.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/system/error.h ///////////////////////
/*
 * File: error.h
 * -------------
 * This file defines the <code>ErrorException</code> class and the
 * <code>error</code> function.
 *
 * @version 2018/10/18
 * - added getKind for ErrorExceptions that wrap other types of errors
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/11/29
 * - fix for undefined SIGUSR1 on Windows systems
 * @version 2016/11/29
 * - changed error() to accept const string& instead of string
 * @version 2016/11/23
 * - added operator << to print ErrorExceptions
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _error_h
#define _error_h

#include <csignal>
#include <exception>
#include <iostream>
#include <string>

// bug fix for missing SIGUSR1 on some Windows systems
#ifndef SIGUSR1
#define SIGUSR1 10
#endif // SIGUSR2

/**
 * This exception is thrown by calls to the <code>error</code>
 * function.  Typical code for catching errors looks like this:
 *
 *<pre>
 *    try {
 *       ... code in which an error might occur ...
 *    } catch (ErrorException& ex) {
 *       ... code to handle the error condition ...
 *    }
 *</pre>
 *
 * If an <code>ErrorException</code> is thrown at any point in the
 * range of the <code>try</code> (including in functions called from
 * that code), control will jump immediately to the error handler.
 */
class ErrorException : public std::exception {
public:
    /**
     * Creates a new ErrorException with the given error message.
     */
    ErrorException(std::string msg);

    /**
     * Frees any memory allocated by the exception.
     */
    virtual ~ErrorException() noexcept = default;

    /**
     * Prints the exception to the standard error stream (cerr),
     * including its message and stack trace if any.
     */
    virtual void dump() const;

    /**
     * Prints the exception to the given output stream,
     * including its message and stack trace if any.
     */
    virtual void dump(std::ostream& out) const;

    /**
     * Returns what kind of exception this is.
     * In general this returns "error", but in some cases we catch other kinds
     * of exceptions (like thrown ints or strings) and wrap them up as
     * ErrorExceptions. In such cases, the kind will be "int" or "string" etc.
     */
    virtual std::string getKind() const;

    /**
     * Returns the exception's error message as passed to its constructor.
     */
    virtual std::string getMessage() const;

    /**
     * Returns a stack trace for this exception as a multi-line string.
     * See exceptions.h/cpp for descriptions of the format.
     * Not every exception has a proper stack trace, based on when/why it was
     * thrown, platform incompatibilities, and other issues; use hasStackTrace to
     * check if a given exception's stack trace is populated.
     */
    virtual std::string getStackTrace() const;

    /**
     * Returns whether this exception has a non-empty stack trace.
     * Not every exception has a proper stack trace, based on when/why it was
     * thrown, platform incompatibilities, and other issues; use hasStackTrace to
     * check if a given exception's stack trace is populated.
     */
    virtual bool hasStackTrace() const;

    /**
     * Sets what kind of exception this is.
     * Default is "error".
     */
    void setKind(const std::string& kind);

    /**
     * Returns the exception's error message as a C string.
     */
    virtual const char* what() const noexcept;

protected:
    /**
     * Sets this exception's stack trace to the given multi-line string.
     */
    void setStackTrace(const std::string& stackTrace);

private:
    std::string _kind;
    std::string _msg;
    std::string _stackTrace;

    /**
     * Prepends "*** " to each line of the given string.
     * Used to format stack traces that print to the console.
     */
    static std::string insertStarsBeforeEachLine(const std::string& s);
};

/**
 * Prints the error exception to the given output stream.
 */
std::ostream& operator <<(std::ostream& out, const ErrorException& ex);

/**
 * Signals an error condition in a program by throwing an
 * <code>ErrorException</code> with the specified message.
 */
[[noreturn]] void error(const std::string& msg);

#endif // _error_h

/////////////////////// END code extracted from StanfordCPPLib/system/error.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/require.h ///////////////////////
/*
 * File: require.h
 * ---------------
 *
 * This file contains assertion functions for argument checking within the
 * code of the Stanford C++ library itself.
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _require_h
#define _require_h

#include <string>

/**
 * @private
 */
namespace require {

void inRange(double value, double min, double max, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void inRange(int value, int min, int max, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void inRange2D(double x, double y, double maxX, double maxY, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void inRange2D(double x, double y, double minX, double minY, double maxX, double maxY, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void inRange2D(int x, int y, int maxX, int maxY, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void inRange2D(int x, int y, int minX, int minY, int maxX, int maxY, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void nonEmpty(const std::string& str, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void nonNegative(double value, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void nonNegative(int value, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void nonNegative(long value, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void nonNegative2D(double x, double y, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void nonNegative2D(int x, int y, const std::string& caller = "", const std::string& xValueName = "", const std::string& yValueName = "", const std::string& details = "");
void nonNull(const void* ptr, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void positive(double value, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void positive(int value, const std::string& caller = "", const std::string& valueName = "", const std::string& details = "");
void require(bool test, const std::string& caller = "", const std::string& details = "");

} // namespace require

#endif // _require_h

/////////////////////// END code extracted from StanfordCPPLib/util/require.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/private/headless.h ///////////////////////
/*
 * File: headless.h
 * ----------------
 * This file contains some code for running in "headless" mode with no GUI.
 *
 * @version 2018/11/22
 * - initial version
 */



#ifndef _headless_h
#define _headless_h

#ifdef SPL_HEADLESS_MODE

// make up a Qt version
#define QT_VERSION 5110

// make Qt version macro produce a version less than this
#define QT_VERSION_CHECK(a, b, c) 5090

#endif // SPL_HEADLESS_MODE

#endif // _headless_h

/////////////////////// END code extracted from StanfordCPPLib/private/headless.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/io/base64.h ///////////////////////
/*
 * File: base64.h
 * --------------
 * This file declares a set of functions for encoding and decoding binary data
 * in the base64 format.  See:
 * http://en.wikipedia.org/wiki/Base64
 *
 * @author Marty Stepp, based upon open-source Apache Base64 en/decoder
 * @version 2014/08/03
 * @since 2014/08/03
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _base64_h
#define _base64_h

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

int Base64encode_len(int len);
int Base64encode(char* coded_dst, const char* plain_src, int len_plain_src);

int Base64decode_len(const char* coded_src);
int Base64decode(char* plain_dst, const char* coded_src);

#ifdef __cplusplus
}

#include <string>

namespace Base64 {
/**
 * Returns a Base64-encoded equivalent of the given string.
 */
std::string encode(const std::string& s);

/**
 * Decodes the given Base64-encoded string and returns the decoded
 * original contents.
 */
std::string decode(const std::string& s);
}
#endif // __cplusplus

#endif // _base64_h

/////////////////////// END code extracted from StanfordCPPLib/io/base64.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/direction.h ///////////////////////
/*
 * File: direction.h
 * -----------------
 * This file exports an enumerated type called <code>Direction</code>
 * whose elements are the four compass points: <code>NORTH</code>,
 * <code>EAST</code>, <code>SOUTH</code>, and <code>WEST</code>.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _direction_h
#define _direction_h

#include <iostream>
#include <string>

/**
 * This enumerated type is used to represent the four compass directions.
 */
enum Direction { NORTH, EAST, SOUTH, WEST };

/**
 * Returns the direction that is to the left of the argument.
 */
Direction leftFrom(Direction dir);

/**
 * Returns the direction that is to the right of the argument.
 */
Direction rightFrom(Direction dir);

/**
 * Returns the direction that is opposite to the argument.
 */
Direction opposite(Direction dir);

/**
 * Returns the name of the direction as a string.
 */
std::string directionToString(Direction dir);

/**
 * Overloads the <code>&lt;&lt;</code> operator so that it is able
 * to display <code>Direction</code> values.
 */
std::ostream& operator <<(std::ostream& os, const Direction& dir);

/**
 * Overloads the <code>&gt;&gt;</code> operator so that it is able
 * to read <code>Direction</code> values.
 */
std::istream& operator >>(std::istream& os, Direction& dir);

/**
 * Overloads the suffix version of the <code>++</code> operator to
 * work with <code>Direction</code> values.  The sole purpose of this
 * definition is to support the idiom
 *
 *<pre>
 *    for (Direction dir = NORTH; dir &lt;= WEST; dir++) ...
 *</pre>
 */
Direction operator ++(Direction& dir, int);

#endif // _direction_h

/////////////////////// END code extracted from StanfordCPPLib/util/direction.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/hashcode.h ///////////////////////
/*
 * File: hashcode.h
 * ----------------
 * This file declares global hashing functions for various common data types.
 * These functions are used by the HashMap and HashSet collections, as well as
 * by other collections that wish to be used as elements within HashMaps/Sets.
 *
 * @version 2017/10/21
 * - added hash codes for short, unsigned integers
 * @version 2017/09/29
 * - added composite hashCode functions (hashCode2, 3, 4, ...)
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 *   (hashSeed(), hashMultiplier(), and hashMask())
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _hashcode_h
#define _hashcode_h

#include <string>
#include <utility>

/*
 * Function: hashCode
 * Usage: int hash = hashCode(key);
 * --------------------------------
 * Returns a hash code for the specified key, which is always a
 * nonnegative integer.  This function is overloaded to support
 * all of the primitive types and the C++ <code>string</code> type.
 */
int hashCode(bool key);
int hashCode(char key);
int hashCode(double key);
int hashCode(float key);
int hashCode(long double key);
int hashCode(int key);
int hashCode(unsigned int key);
int hashCode(long key);
int hashCode(unsigned long key);
int hashCode(short key);
int hashCode(unsigned short key);
int hashCode(const char* str);
int hashCode(const std::string& str);
int hashCode(void* key);

/*
 * Constants that are used to help implement these functions
 * (see hashcode.h for example usage)
 */
int hashSeed();         // Starting point for first cycle
int hashMultiplier();   // Multiplier for each cycle
int hashMask();         // All 1 bits except the sign

/*
 * Computes a composite hash code from a list of multiple values.
 * The components are scaled up so as to spread out the range of values
 * and reduce collisions.
 * The type of each value passed must have a suitable hashCode() function.
 */
template <typename T1, typename T2, typename... Others>
int hashCode(T1&& first, T2&& second, Others&&... remaining) {
    int result = hashSeed();

    /* Compute the hash code for the last n - 1 arguments. */
    result += hashCode(std::forward<T2>(second), std::forward<Others>(remaining)...);

    /* Update the hash to factor in the hash of the first element. */
    result *= hashMultiplier();
    result += hashCode(std::forward<T1>(first));

    /* Hash the resulting integer to mask off any unneeded bits. */
    return hashCode(result);
}

#endif // _hashcode_h

/////////////////////// END code extracted from StanfordCPPLib/collections/hashcode.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/random.h ///////////////////////
/*
 * File: random.h
 * --------------
 * This file exports functions for generating pseudorandom numbers.
 * 
 * @version 2019/05/16
 * - added randomColor that takes min/max RGB
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/10/05
 * - added randomFeedClear
 * @version 2017/09/28
 * - moved random 'feed' functions into autograder namespace
 * @version 2016/08/02
 * - added randomColor, randomColorString
 * @version 2014/10/19
 * - alphabetized functions
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _random_h
#define _random_h

#include <string>

/**
 * Returns <code>true</code> with 50% probability.
 */
bool randomBool();

/**
 * Returns <code>true</code> with the probability indicated by <code>p</code>.
 * The argument <code>p</code> must be a floating-point number between
 * 0 (never) and 1 (always).  For example, calling
 * <code>randomChance(.30)</code> returns <code>true</code> 30 percent
 * of the time.
 */
bool randomChance(double p);

/**
 * Returns a random RGB color as an integer.
 * See also: gwindow.h convertRGBToColor()
 */
int randomColor();

/**
 * Returns a random RGB color as an integer, with the value of the RGB components
 * bounded between the given minimum and maximum.
 * @throw ErrorException if min or max is not in [0..255] or min > max
 * See also: gwindow.h convertRGBToColor()
 */
int randomColor(int minRGB, int maxRGB);

/**
 * Returns a random RGB color as a hex string like "#ff00ff" for magenta.
 * See also: gwindow.h convertColorToRGB()
 */
std::string randomColorString();

/**
 * Returns a random RGB color as a hex string like "#ff00ff" for magenta,
 * with the value of the RGB components bounded between the given minimum and maximum.
 * @throw ErrorException if min or max is not in [0..255] or min > max
 * See also: gwindow.h convertColorToRGB()
 */
std::string randomColorString(int minRGB, int maxRGB);

/**
 * Returns a random integer in the range <code>low</code> to
 * <code>high</code>, inclusive.
 */
int randomInteger(int low, int high);

/**
 * Returns a random real number in the half-open interval
 * [<code>low</code>&nbsp;..&nbsp;<code>high</code>).  A half-open
 * interval includes the first endpoint but not the second, which
 * means that the result is always greater than or equal to
 * <code>low</code> but strictly less than <code>high</code>.
 */
double randomReal(double low, double high);

/**
 * Sets the internal random number seed to the specified value.  You
 * can use this function to set a specific starting point for the
 * pseudorandom sequence or to ensure that program behavior is
 * repeatable during the debugging phase.
 */
void setRandomSeed(int seed);

/**
 * Extra functions to facilitate creation of autograder programs.
 * @private
 */
namespace autograder {
/**
 * Inserts the given boolean value to be returned by the random number
 * generator, rather than truly random choices.
 */
void randomFeedBool(bool value);

/**
 * Removes any previously 'fed' random integers so that future calls
 * to random functions will return truly random values.
 */
void randomFeedClear();

/**
 * Inserts the given integer to be returned by the random number generator,
 * rather than truly random numbers.
 */
void randomFeedInteger(int value);

/**
 * Inserts the given real number to be returned by the random number generator,
 * rather than truly random numbers.
 */
void randomFeedReal(double value);
}

#endif // _random_h

/////////////////////// END code extracted from StanfordCPPLib/util/random.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/point.h ///////////////////////
/*
 * File: point.h
 * -------------
 * This file exports a class representing an integer-valued <i>x</i>-<i>y</i>
 * pair.
 *
 * @version 2018/11/22
 * - added headless mode support
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _point_h
#define _point_h

#include <string>

#ifndef SPL_HEADLESS_MODE
class GPoint;   // forward declaration
#endif // SPL_HEADLESS_MODE

/**
 * This class represents an <i>x</i>-<i>y</i> coordinate point on a
 * two-dimensional integer grid.  If you need to work with real-valued points,
 * you should use the <a href="gtypes.html"><code>gtypes.h</code></a>
 * interface instead.
 */
class Point {
public:
    /**
     * Creates a <code>Point</code> object at (0, 0).
     */
    Point();

    /**
     * Creates a <code>Point</code> object with the specified x and y coordinates.
     */
    Point(int x, int y);

#ifndef SPL_HEADLESS_MODE
    /**
     * Creates a <code>Point</code> object with the same x and y coordinates
     * as the given other point.
     */
    Point(const GPoint& point);
#endif // SPL_HEADLESS_MODE

    /**
     * Returns the <i>x</i>-coordinate of the point.
     */
    int getX() const;

    /**
     * Returns the <i>y</i>-coordinate of the point.
     */
    int getY() const;

    /**
     * Returns a string representation of the <code>Point</code> in the form
     * <code>"(x, y)"</code>.
     */
    std::string toString() const;

    /**
     * Returns <code>true</code> if <code>p1</code> and <code>p2</code>
     * are the same point.
     */
    bool operator ==(const Point& p2) const;

    /**
     * Returns <code>true</code> if <code>p1</code> and <code>p2</code>
     * are different.
     */
    bool operator !=(const Point& p2) const;

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    // instance variables
    int x;                         // the x-coordinate of the point
    int y;                         // the y-coordinate of the point
};

/**
 * Overloads the <code>&lt;&lt;</code> operator so that it is able
 * to display <code>Point</code> values.
 */
std::ostream& operator <<(std::ostream& os, const Point& pt);

/**
 * Hash code function for Point objects.
 */
int hashCode(const Point& pt);

#endif // _point_h

/////////////////////// END code extracted from StanfordCPPLib/util/point.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/io/simpio.h ///////////////////////
/*
 * File: simpio.h
 * --------------
 * This file exports a set of functions that simplify input/output
 * operations in C++ and provide some error-checking on console input.
 * 
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2016/09/29
 * - added getDouble method
 * @version 2015/07/05
 * - increased visibility of appendSpace function used by various IO
 *   prompting functions (no longer static)
 * @version 2014/10/19
 * - alphabetized functions
 * - converted many funcs to take const string& rather than string for efficiency
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _simpio_h
#define _simpio_h

#include <iostream>
#include <string>

/**
 * Adds a space at the end of the given string by reference if none is present.
 * @private
 */
void appendSpace(std::string& prompt);

/**
 * Reads a complete line from <code>cin</code>, expecting the user to type a
 * single character. If this is the case, that character value is returned.
 * If the user types anything other than a one-character line of input,
 * the user is given a chance to reenter the value.
 *
 * If supplied, the optional <code>prompt</code> string is printed before
 * reading the value.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "You must type a single character. Try again.".
 */
char getChar(const std::string& prompt = "",
             const std::string& reprompt = "");

/**
 * Reads a complete line from <code>cin</code> and scans it as a
 * floating-point number. If the scan succeeds, the floating-point
 * value is returned.  If the input is not a legal number or if
 * extraneous characters (other than whitespace) appear in the string,
 * the user is given a chance to reenter the value.
 *
 * If supplied, the optional <code>prompt</code> string is printed before
 * reading the value.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Illegal numeric format. Try again.".
 *
 * Equivalent to getReal.
 */
double getDouble(const std::string& prompt = "",
                 const std::string& reprompt = "");

/**
 * Reads a complete line from <code>cin</code> and scans it as a
 * floating-point number. If the scan succeeds, the floating-point
 * value is returned.  If the input is not a legal number or if
 * it is not between min and max, or if extraneous characters
 * (other than whitespace) appear in the string,
 * the user is given a chance to reenter the value.
 *
 * The required <code>prompt</code> string is printed before reading the value.
 *
 * Equivalent to getRealBetween.
 */
double getDoubleBetween(const std::string& prompt, double min, double max);


/**
 * Reads a complete line from <code>cin</code> and scans it as an
 * integer. If the scan succeeds, the integer value is returned. If
 * the argument is not a legal integer or if extraneous characters
 * (other than whitespace) appear in the string, the user is given
 * a chance to reenter the value.
 *
 * If supplied, the optional <code>prompt</code> string is printed before
 * reading the value.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Illegal integer format. Try again.".
 */
int getInteger(const std::string& prompt = "",
               const std::string& reprompt = "");

/**
 * Reads a complete line from <code>cin</code> and scans it as an
 * integer. If the scan succeeds, the integer value is returned. If
 * the argument is not a legal integer, if it is not between min and max,
 * or if extraneous characters (other than whitespace) appear in the string,
 * the user is given a chance to reenter the value.
 *
 * The required <code>prompt</code> string is printed before reading the value.
 */
int getIntegerBetween(const std::string& prompt, int min, int max);

/**
 * Reads a line of text from <code>cin</code> and returns that line
 * as a string.  The newline character that terminates the input is
 * not stored as part of the return value.  If supplied, the optional
 * <code>prompt</code> string is printed before reading the value.
 */
std::string getLine(const std::string& prompt = "");

/**
 * Alternate version of getLine that accepts a prompt and fills a given output
 * variable with its result.
 */
void getLine(const std::string& prompt,
             std::string& out);

/**
 * Alternate version of getLine that accepts an input stream to read from.
 * Meant as a drop-in replacement for the standard C++ getline (lowercase L)
 * function.
 */
void getLine(std::istream& input,
             std::string& out);

/**
 * Reads a complete line from <code>cin</code> and scans it as a
 * floating-point number. If the scan succeeds, the floating-point
 * value is returned.  If the input is not a legal number or if
 * extraneous characters (other than whitespace) appear in the string,
 * the user is given a chance to reenter the value.
 *
 * If supplied, the optional <code>prompt</code> string is printed before
 * reading the value.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Illegal numeric format. Try again.".
 *
 * Equivalent to getDouble.
 */
double getReal(const std::string& prompt = "",
               const std::string& reprompt = "");

/**
 * Reads a complete line from <code>cin</code> and scans it as a
 * floating-point number. If the scan succeeds, the floating-point
 * value is returned.  If the input is not a legal number or if
 * it is not between min and max, or if extraneous characters
 * (other than whitespace) appear in the string,
 * the user is given a chance to reenter the value.
 *
 * The required <code>prompt</code> string is printed before reading the value.
 *
 * Equivalent to getDoubleBetween.
 */
double getRealBetween(const std::string& prompt, double min, double max);

/**
 * Reads a complete line from <code>cin</code> and treats it as a
 * yes-or-no answer to a question.  Returns <code>true</code> if the line
 * typed begins with a 'y' or 'Y', and returns <code>false</code> if it begins
 * with a 'n' or 'N'.  Otherwise the user is given a chance to reenter the
 * value.
 *
 * If supplied, the optional <code>prompt</code> string is printed before
 * reading the value.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to,
 * "Please type a word that starts with 'Y' or 'N'.".
 * 
 * The also also optional <code>defaultValue</code> argument indicates what
 * should happen if the user just presses Enter rather than typing Y or N.
 * By default, the user is re-prompted, but if a defaultValue is passed here,
 * pressing Enter will be equivalent to having typed that value.
 * This is useful where the default Y/N answer is Yes or No and you want to
 * let the user avoid typing.
 */
bool getYesOrNo(const std::string& prompt = "",
                const std::string& reprompt = "",
                const std::string& defaultValue = "");

#endif // _simpio_h

/////////////////////// END code extracted from StanfordCPPLib/io/simpio.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/functional.h ///////////////////////
/*
 * File: functional.h
 * ------------------
 * Contains a few functions for functional programming.
 *
 * The map, filter, and reduce operations are quite common in functional
 * programming systems.  They allow for elegant functional solutions to many
 * common programming tasks involving collections of data.
 *
 * There are similar functions in the C++ STL algorithm package.
 * But those functions often operate on STL iterators.
 * By contrast, these functions accept collections as parameters instead.
 * This is preferable for introductory students who are just learning.
 *
 * Implementation detail: Each function has several overloads.
 * Some of these are to allow for functions and predicates that accept their
 * arguments either by value or by const reference.
 * Other overloads allow either returning the result collection or passing it in
 * by reference as an output parameter to be filled in.
 *
 * We do not support "in-place" versions of these functions, partly because
 * there is not a perfect standard "remove" member across all collections that
 * accepts a value to remove as its parameter, and partly because the more common
 * functional style is to expect a new collection result to be returned.
 *
 * @author Marty Stepp
 * @version 2018/03/10
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _functional_h
#define _functional_h

#include <functional> // The standard header one. :-)

namespace functional {

/*
 * Performs a filter operation on the given collection,
 * returning a new collection that retains only the elements
 * for which the given predicate function returns true.
 */
template <typename CollectionType, typename ElementType>
CollectionType filter(CollectionType collection,
                      bool (*predicate)(ElementType)) {
    CollectionType result;
    for (const ElementType& element : collection) {
        if (predicate(element)) {
            result.add(element);
        }
    }
    return result;
}

/*
 * Performs a filter operation on the given collection,
 * returning a new collection that retains only the elements
 * for which the given predicate function returns true.
 */
template <typename CollectionType, typename ElementType>
CollectionType filter(CollectionType collection,
                      bool (*predicate)(const ElementType&)) {
    CollectionType result;
    for (const ElementType& element : collection) {
        if (predicate(element)) {
            result.add(element);
        }
    }
    return result;
}

/*
 * Performs a filter operation on the given collection,
 * building a new collection that retains only the elements
 * for which the given predicate function returns true.
 * The new collection is stored in the given 'result' variable.
 * A reference to that same result is returned for convenience.
 */
template <typename CollectionType, typename ElementType>
CollectionType& filter(CollectionType collection,
                       bool (*predicate)(ElementType),
                       CollectionType& result) {
    for (const ElementType& element : collection) {
        if (predicate(element)) {
            result.add(element);
        }
    }
    return result;
}

/*
 * Performs a filter operation on the given collection,
 * building a new collection that retains only the elements
 * for which the given predicate function returns true.
 * The new collection is stored in the given 'result' variable.
 * A reference to that same result is returned for convenience.
 */
template <typename CollectionType, typename ElementType>
CollectionType& filter(CollectionType collection,
                       bool (*predicate)(const ElementType&),
                       CollectionType& result) {
    for (const ElementType& element : collection) {
        if (predicate(element)) {
            result.add(element);
        }
    }
    return result;
}

/**
 * Performs a filter operation on the given collection,
 * returning a new collection that retains only the elements
 * for which the given predicate function returns true.
 */
template <typename CollectionType, typename ElementType>
CollectionType filter(CollectionType collection,
                      std::function<bool (const ElementType &)> predicate) {
    CollectionType result;
    for (const ElementType& element : collection) {
        if (predicate(element)) {
            result.add(element);
        }
    }
    return result;
}

/**
 * Performs a filter operation on the given collection,
 * building a new collection that retains only the elements
 * for which the given predicate function returns true.
 * The new collection is stored in the given 'result' variable.
 * A reference to that same result is returned for convenience.
 */
template <typename CollectionType, typename ElementType>
CollectionType& filter(CollectionType collection,
                       std::function<bool (const ElementType &)> predicate,
                       CollectionType& result) {
    for (const ElementType& element : collection) {
        if (predicate(element)) {
            result.add(element);
        }
    }
    return result;
}

/*
 * Applies the given function to each element of the given collection,
 * producing and returning a new collection containing the results.
 */
template <typename CollectionType, typename ElementType>
CollectionType map(CollectionType collection,
                   ElementType (*fn)(ElementType)) {
    CollectionType result;
    for (const ElementType& element : collection) {
        result.add(fn(element));
    }
    return result;
}

/*
 * Applies the given function to each element of the given collection,
 * producing and returning a new collection containing the results.
 */
template <typename CollectionType, typename ElementType>
CollectionType map(CollectionType collection,
                   ElementType (*fn)(const ElementType&)) {
    CollectionType result;
    for (const ElementType& element : collection) {
        result.add(fn(element));
    }
    return result;
}

/*
 * Applies the given function to each element of the given collection,
 * producing a new collection containing the results.
 * The new collection is stored in the 'result' variable.
 * A reference to that same result is returned for convenience.
 */
template <typename CollectionType, typename ElementType,
          typename CollectionType2, typename ElementType2>
CollectionType2& map(CollectionType collection,
                     ElementType2 (*fn)(ElementType),
                     CollectionType2& result) {
    for (const ElementType& element : collection) {
        result.add(fn(element));
    }
    return result;
}

/*
 * Applies the given function to each element of the given collection,
 * producing a new collection containing the results.
 * The new collection is stored in the 'result' variable.
 * A reference to that same result is returned for convenience.
 */
template <typename CollectionType, typename ElementType,
          typename CollectionType2, typename ElementType2>
CollectionType2& map(CollectionType collection,
                     ElementType2 (*fn)(const ElementType&),
                     CollectionType2& result) {
    for (const ElementType& element : collection) {
        result.add(fn(element));
    }
    return result;
}

/**
 * Applies the given function to each element of the given collection,
 * producing and returning a new collection containing the results.
 */
template <typename CollectionType, typename ElementType>
CollectionType map(CollectionType collection,
                   std::function<ElementType (const ElementType &)> fn) {
    CollectionType result;
    for (const ElementType& element : collection) {
        result.add(fn(element));
    }
    return result;
}

/**
 * Applies the given function to each element of the given collection,
 * producing a new collection containing the results.
 * The new collection is stored in the 'result' variable.
 * A reference to that same result is returned for convenience.
 */
template <typename CollectionType, typename ElementType,
          typename CollectionType2, typename ElementType2>
CollectionType2& map(CollectionType collection,
                     std::function<ElementType (const ElementType &)> fn,
                     CollectionType2& result) {
    for (const ElementType& element : collection) {
        result.add(fn(element));
    }
    return result;
}

/*
 * Performs a reduction operation, applying a function to each neighboring pair
 * of elements of the collection until they are all combined (reduced) into a
 * single value, which is then returned.
 */
template <typename CollectionType, typename ElementType>
ElementType reduce(CollectionType collection,
                   ElementType (*fn)(ElementType e1, ElementType e2),
                   ElementType startValue) {
    ElementType prev = startValue;
    for (const ElementType& element : collection) {
        prev = fn(prev, element);
    }
    return prev;
}

/*
 * Performs a reduction operation, applying a function to each neighboring pair
 * of elements of the collection until they are all combined (reduced) into a
 * single value, which is then returned.
 */
template <typename CollectionType, typename ElementType>
ElementType reduce(CollectionType collection,
                   ElementType (*fn)(ElementType e1, ElementType e2)) {
    bool first = true;
    ElementType prev;
    for (const ElementType& element : collection) {
        if (first) {
            prev = element;
            first = false;
        } else {
            prev = fn(prev, element);
        }
    }
    return prev;
}

/*
 * Performs a reduction operation, applying a function to each neighboring pair
 * of elements of the collection until they are all combined (reduced) into a
 * single value, which is then returned.
 * Begins the reduction with the given starting value, which is then merged
 * with each value from the collection one at a time.
 */
template <typename CollectionType, typename ElementType>
ElementType reduce(CollectionType collection,
                   ElementType (*fn)(const ElementType& e1, const ElementType& e2),
                   ElementType startValue) {
    ElementType prev = startValue;
    for (const ElementType& element : collection) {
        prev = fn(prev, element);
    }
    return prev;
}

/*
 * Performs a reduction operation, applying a function to each neighboring pair
 * of elements of the collection until they are all combined (reduced) into a
 * single value, which is then returned.
 * Begins the reduction with the given starting value, which is then merged
 * with each value from the collection one at a time.
 */
template <typename CollectionType, typename ElementType>
ElementType reduce(CollectionType collection,
                   ElementType (*fn)(const ElementType& e1, const ElementType& e2)) {
    bool first = true;
    ElementType prev;
    for (const ElementType& element : collection) {
        if (first) {
            prev = element;
            first = false;
        } else {
            prev = fn(prev, element);
        }
    }
    return prev;
}

/**
 * Performs a reduction operation, applying a function to each neighboring pair
 * of elements of the collection until they are all combined (reduced) into a
 * single value, which is then returned.
 * Begins with a "default" value of the starting type.
 */
template <typename CollectionType, typename ElementType>
ElementType reduce(CollectionType collection,
                   std::function<ElementType (const ElementType&, const ElementType &)> fn) {
    ElementType prev;
    for (const ElementType& element : collection) {
        prev = fn(prev, element);
    }
    return prev;
}

/**
 * Performs a reduction operation, applying a function to each neighboring pair
 * of elements of the collection until they are all combined (reduced) into a
 * single value, which is then returned.
 * Begins the reduction with the given starting value, which is then merged
 * with each value from the collection one at a time.
 */
template <typename CollectionType, typename ElementType>
ElementType reduce(CollectionType collection,
                   std::function<ElementType (const ElementType&, const ElementType &)> fn,
                   ElementType startValue) {
    ElementType prev = startValue;
    for (const ElementType& element : collection) {
        prev = fn(prev, element);
    }
    return prev;
}

} // namespace functional

#endif // _functional_h

/////////////////////// END code extracted from StanfordCPPLib/collections/functional.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/gmath.h ///////////////////////
/*
 * File: gmath.h
 * -------------
 * This file exports several functions for working with graphical
 * geometry along with the mathematical constants <code>PI</code>
 * and <code>E</code>.
 *
 * @version 2018/11/22
 * - added headless mode support
 * - alphabetized methods
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/12/12
 * - added floatingPointEqual(a, b, tolerance)
 * @version 2016/10/14
 * - added floatingPointEqual method for comparing floats and doubles
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _gmath_h
#define _gmath_h

#include <cmath>
#include <limits>

#ifndef SPL_HEADLESS_MODE
#define INTERNAL_INCLUDE 1

#endif // SPL_HEADLESS_MODE

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * The mathematical constant pi, which is the ratio of the circumference
 * of a circle to its diameter.
 */
extern const double PI;

/**
 * Constant: E
 * -----------
 * The mathematical constant e, which is the base of natural logarithms.
 */
extern const double E;

/**
 * Returns the trigonometric cosine of <code>angle</code>, which is
 * expressed in degrees.
 */
double cosDegrees(double angle);


/**
 * Returns the number of digits in the given integer in the given base.
 * Defaults to base-10, decimal.
 * @example countDigits(3456) returns 4.
 * @example countDigits(0)    returns 1.
 * @example countDigits(-778) returns 3.
 * @throw ErrorException if base is 0 or negative.
 */
int countDigits(int n, int base = 10);

/**
 * Returns true if the two given floating-point numbers are "equal" to each other,
 * within a given tolerance.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(T f1, T f2, T tolerance) {
    return (std::fabs(f1 - f2) <= tolerance);
}

/**
 * Returns true if the two given floating-point numbers are "equal" to each other.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(T f1, T f2) {
    return floatingPointEqual(f1, f2, /* tolerance */ (T) std::numeric_limits<T>::epsilon() * std::fmax(fabs(f1), fabs(f2)));
}

/**
 * Returns true if the given floating-point number is "equal" to the given integer.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(T f1, int f2) {
    return floatingPointEqual(f1, (T) f2);
}

/**
 * Returns true if the given floating-point number is "equal" to the given integer.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(int f1, T f2) {
    return floatingPointEqual((T) f1, f2);
}

/**
 * Returns true if the given floating-point number is "equal" to the given integer.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(T f1, long int f2) {
    return floatingPointEqual(f1, (T) f2);
}

/**
 * Returns true if the given floating-point number is "equal" to the given integer.
 * Floating-point equality is tricky because of round-off errors, which can cause
 * the numbers to be nearly the same but not identical.
 *
 * See also:
 * http://stackoverflow.com/questions/4548004/how-to-correctly-and-standardly-compare-floats
 */
template<typename T>
bool floatingPointEqual(long int f1, T f2) {
    return floatingPointEqual((T) f1, f2);
}

/**
 * Returns the trigonometric sine of <code>angle</code>, which is
 * expressed in degrees.
 */
double sinDegrees(double angle);

/**
 * Returns the trigonometric tangent of <code>angle</code>, which is
 * expressed in degrees.
 */
double tanDegrees(double angle);

/**
 * Converts an angle from radians to degrees.
 */
double toDegrees(double radians);

/**
 * Converts an angle from degrees to radians.
 */
double toRadians(double degrees);

/**
 * Returns the angle in degrees from the origin to the specified point.
 * This function takes account of the fact that the graphics coordinate
 * system is flipped in the <i>y</i> direction from the traditional
 * Cartesian plane.
 */
double vectorAngle(double x, double y);

/**
 * Returns the angle in degrees from the origin to the specified point.
 * This function takes account of the fact that the graphics coordinate
 * system is flipped in the <i>y</i> direction from the traditional
 * Cartesian plane.
 */
#ifndef SPL_HEADLESS_MODE
double vectorAngle(const GPoint& pt);
#endif // SPL_HEADLESS_MODE
double vectorAngle(const Point& pt);

/**
 * Computes the distance between the origin and the specified point.
 */
double vectorDistance(double x, double y);

/**
 * Computes the distance between the origin and the specified point.
 */
#ifndef SPL_HEADLESS_MODE
double vectorDistance(const GPoint& pt);
#endif // SPL_HEADLESS_MODE
double vectorDistance(const Point& pt);

#endif // _gmath_h

/////////////////////// END code extracted from StanfordCPPLib/util/gmath.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/shuffle.h ///////////////////////
/*
 * File: shuffle.h
 * ---------------
 * This file contains implementation of a shuffling function that operates on
 * a 1-D and 2-D array, Vector, or Grid of any type.
 *
 * @author Marty Stepp
 * @since 2014/02/01
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _shuffle_h
#define _shuffle_h

#include <string>
#include <algorithm>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Randomly rearranges the elements of the given array up to the given length.
 * Precondition: The array pointer points to a valid non-null array in memory,
 * and that array contains at least 'length' elements.
 */
template <typename T>
void shuffle(T* array, int length) {
    for (int i = 0; i < length; i++) {
        int j = randomInteger(i, length - 1);
        if (i != j) std::swap(array[i], array[j]);
    }
}

/*
 * Randomly rearranges the elements of the given 2-D array up to the given
 * number of rows and columns.
 * Precondition: The array pointer points to a valid non-null 2-D array in
 * memory, and that array contains at least the given number of rows/columns.
 */
template <typename T>
void shuffle(T** array2d, int rows, int cols) {
    int length = rows * cols;
    for (int i = 0; i < length; i++) {
        int j = randomInteger(i, length - 1);
        if (i != j) {
            int r1 = i / cols;
            int c1 = i % cols;
            int r2 = j / cols;
            int c2 = j % cols;

            std::swap(array2d[r1][c1], array2d[r2][c2]);
        }
    }
}

/*
 * Randomly rearranges the characters of the given string and returns the
 * rearranged version.
 */
std::string shuffle(std::string s);

#endif // _shuffle_h

/////////////////////// END code extracted from StanfordCPPLib/collections/shuffle.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/collections.h ///////////////////////
/*
 * File: collections.h
 * -------------------
 * Contains general-purpose functions for use with many collections.
 *
 * For example, we have functions for comparing any collections that have
 * a visible iterator (begin(), end()).
 * Used to implement comparison operators like < and >= on collections.
 *
 * @author Marty Stepp
 * @version 2019/10/12
 * - added ARRAY_LENGTH macro
 * @version 2019/04/12
 * - added GenericSet unionWith, intersect, difference methods
 * - added functions to read/write quoted char values
 * - changed comment formatting
 * @version 2017/12/12
 * - added equalsDouble for collections of double values (can't compare with ==)
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2017/09/29
 * - added compareTo1-5
 * @version 2016/12/09
 * - added checkVersion for iterators
 * @version 2016/09/24
 * - renamed compare.h to collections.h
 * - added printing functions
 * @version 2014/10/10
 * - initial version as compare.h
 * @since 2014/10/10
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _collections_h
#define _collections_h

#include <iostream>
#include <sstream>
#include <type_traits>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

// macro to get the length of a stack-allocated array
#define ARRAY_LENGTH(a) (sizeof(a) / sizeof((a)[0]))

// begin global namespace string read/writing functions from strlib.h

/**
 * Reads the next char from infile into the reference parameter ch.
 * If the first character (other than whitespace) is either a single
 * or a double quote, this function reads characters up to the
 * matching quote, processing standard escape sequences as it goes.
 * If not, readQuotedChar reads characters up to any of the characters
 * in the string STRING_DELIMITERS in the implementation file.
 *
 * @private
 */
bool readQuotedChar(std::istream& is, char& ch, bool throwOnError = true);

/**
 * Reads the next string from infile into the reference parameter str.
 * If the first character (other than whitespace) is either a single
 * or a double quote, this function reads characters up to the
 * matching quote, processing standard escape sequences as it goes.
 * If not, readQuoted String reads characters up to any of the characters
 * in the string STRING_DELIMITERS in the implementation file.
 *
 * @private
 */
bool readQuotedString(std::istream& is, std::string& str, bool throwOnError = true);

/**
 * Writes the char ch to outfile surrounded by single quotes, converting
 * special characters to escape sequences, as necessary.  If the optional
 * parameter forceQuotes is explicitly set to false, quotes are included
 * in the output only if necessary.
 *
 * @private
 */
std::ostream& writeQuotedChar(std::ostream& os, char ch, bool forceQuotes = true);

/**
 * Writes the string str to outfile surrounded by double quotes, converting
 * special characters to escape sequences, as necessary.  If the optional
 * parameter forceQuotes is explicitly set to false, quotes are included
 * in the output only if necessary.
 *
 * @private
 */
std::ostream& writeQuotedString(std::ostream& os, const std::string& str,
                                bool forceQuotes = true);

/**
 * Checks whether the string needs quoting in order to be read correctly.
 * @private
 */
bool stringNeedsQuoting(const std::string& str);

/**
 * Writes a generic value to the output stream.  If that value is a string,
 * this function uses writeQuotedString to write the value.
 * @private
 */
template <typename ValueType>
std::ostream& writeGenericValue(std::ostream& os, const ValueType& value, bool) {
    return os << std::boolalpha << value;
}

inline std::ostream& writeGenericValue(std::ostream& os, char value,
                                       bool forceQuotes) {
    return writeQuotedChar(os, value, forceQuotes);
}

inline std::ostream& writeGenericValue(std::ostream& os, const std::string& value,
                                       bool forceQuotes) {
    return writeQuotedString(os, value, forceQuotes);
}

template <typename ValueType>
inline std::string genericValueToString(const ValueType& value,
                                        bool forceQuotes = false) {
    std::ostringstream os;
    writeGenericValue(os, value, forceQuotes);
    return os.str();
}

inline std::string genericValueToString(const std::string& value,
                                        bool forceQuotes) {
    std::ostringstream os;
    writeQuotedString(os, value, forceQuotes);
    return os.str();
}

/**
 * Reads a generic value from the input stream.  If that value is a string,
 * this function uses readQuotedString to read the value.
 * @private
 */
template <typename ValueType>
bool readGenericValue(std::istream& is, ValueType& value) {
    return (bool) (is >> value);
}

inline bool readGenericValue(std::istream& is, char& value) {
    return readQuotedChar(is, value, /* throwOnError */ false);
}

inline bool readGenericValue(std::istream& is, std::string& value) {
    return readQuotedString(is, value, /* throwOnError */ false);
}

// end of global namespace string read/writing functions from strlib.h
namespace stanfordcpplib {
namespace collections {

#ifdef SPL_THROW_ON_INVALID_ITERATOR
template <typename CollectionType, typename IteratorType>
void checkVersion(const CollectionType& coll, const IteratorType& itr,
                  const std::string& memberName = "") {
    unsigned int collVersion = coll.version();
    unsigned int itrVersion = itr.version();
    if (itrVersion != collVersion) {
        std::string msg = memberName;
        if (!msg.empty()) {
            msg += ": ";
        }
        msg += "Collection modified during iteration. Iterator is now invalid.\n";
        msg += "Do not modify a collection during a for-each loop or iterator traversal.";
        error(msg);
    }
}
#else // SPL_THROW_ON_INVALID_ITERATOR
template <typename CollectionType, typename IteratorType>
void checkVersion(const CollectionType&, const IteratorType&,
                  const std::string& = "") {
    // empty
}
#endif

/*
 * Performs a comparison for ordering between the given two collections
 * by comparing their elements pairwise to each other.
 * Returns -1 if collection 1 is "less than" collection 2;
 * Returns  1 if collection 1 is "greater than" collection 2;
 * Returns  0 if collection 1 is "equal to" collection 2.
 * The element type must have an operator <.
 */
template <typename CollectionType>
int compare(const CollectionType& coll1, const CollectionType& coll2) {
    // optimization: if they are the same object, then they are equal
    if (&coll1 == &coll2) {
        return 0;
    }
    
    auto itr1 = coll1.begin(),
         itr2 = coll2.begin(),
         end1 = coll1.end(),
         end2 = coll2.end();
    for (;
         itr1 != end1 && itr2 != end2;
         ++itr1, ++itr2) {
        // compare each pair of elements from iterators
        
        // TO STUDENT:
        // If the line below is failing to compile in your program, it probably
        // means that you are trying to make a nested collection
        // (e.g. Set<Vector<T>>) for some element type T that does not have a
        // less-than < operator.  That operator is *required* in order to make
        // a Set or Map of Vectors, so that the set/map knows how to sort the
        // elements into their ascending order.
        // You should either add a < operator to your class, or consider a
        // different nested collection solution.  Good luck!
        if (*itr1 < *itr2) {
            return -1;
        } else if (*itr2 < *itr1) {
            return 1;
        }
    }
    
    // if we get here, everything from v1 matched v2, so they are either equal,
    // or one is shorter than the other (fewer elements) and is therefore less
    if (itr1 == end1 && itr2 == end2) {
        return 0;
    } else if (itr1 == end1) {
        return -1;
    } else {
        return 1;
    }
}

/*
 * Performs a comparison for ordering between the given two maps
 * by comparing their key/value pairs pairwise to each other.
 * Returns -1 if collection 1 is "less than" collection 2;
 * Returns  1 if collection 1 is "greater than" collection 2;
 * Returns  0 if collection 1 is "equal to" collection 2.
 * Note that the order of keys and values in the maps matter here;
 * the same map with keys in different orders would produce a different result.
 * The key and value types must both have an operator <.
 */
template <typename MapType>
int compareMaps(const MapType& map1, const MapType& map2) {
    // optimization: if they are the same object, then they are equal
    if (&map1 == &map2) {
        return 0;
    }
    
    auto itr1 = map1.begin(),
         itr2 = map2.begin(),
         end1 = map1.end(),
         end2 = map2.end();
    for (;
         itr1 != end1 && itr2 != end2;
         ++itr1, ++itr2) {
        // compare each pair of elements from iterators
        
        // TO STUDENT:
        // If the line below is failing to compile in your program, it probably
        // means that you are trying to make a nested collection
        // (e.g. Set<Map<K, V>>) for some element type K or V that does not have a
        // less-than < operator.  That operator is *required* in order to make
        // a Set or Map of Maps, so that the set/map knows how to sort the
        // keys and values into their ascending order.
        // You should either add a < operator to your key/value types, or consider a
        // different nested collection solution.  Good luck!
        if (*itr1 < *itr2) {
            return -1;
        } else if (*itr2 < *itr1) {
            return 1;
        }
        
        // key1 == key2, so compare values
        auto value1 = map1[*itr1];
        auto value2 = map2[*itr2];
        if (value1 < value2) {
            return -1;
        } else if (value2 < value1) {
            return 1;
        }
    }
    
    // if we get here, everything from v1 matched v2, so they are either equal,
    // or one is shorter than the other (fewer elements) and is therefore less
    if (itr1 == end1 && itr2 == end2) {
        return 0;
    } else if (itr1 == end1) {
        return -1;
    } else {
        return 1;
    }
}

/*
 * Template functions to compare two interleaved sequences of values, returning
 * -1 if the first value is less than the second,
 *  0 if the values are equal,
 *  1 if the first value is greater than the second.
 * The type passed must support a < less-than operator.
 */
inline int compareTo() {
    return 0;
}
template <typename T, typename... Rest>
int compareTo(const T& first, const T& second, const Rest&... rest) {
    if (first < second) return -1;
    if (second < first) return +1;
    return compareTo(rest...);
}

/*
 * Returns true if the two collections contain the same elements in the same order.
 * The element type must have an operator ==.
 */
template <typename CollectionType>
bool equals(const CollectionType& coll1, const CollectionType& coll2) {
    // optimization: if literally same collection, stop
    if (&coll1 == &coll2) {
        return true;
    }
    // optimization: if not same size, don't bother comparing pairwise
    if (coll1.size() != coll2.size()) {
        return false;
    }

    // check each pair of elements for equality
    auto itr1 = coll1.begin();
    auto end1 = coll1.end();
    auto itr2 = coll2.begin();
    auto end2 = coll2.end();
    while (itr1 != end1 && itr2 != end2) {
        if (!(*itr1 == *itr2)) {
            return false;
        }
        ++itr1;
        ++itr2;
    }
    return true;
}

/*
 * Returns true if the two collections contain the same elements in the same order.
 * The element type must be double, float, or any floating-point type.
 */
template <typename CollectionType>
bool equalsDouble(const CollectionType& coll1, const CollectionType& coll2) {
    // optimization: if literally same collection, stop
    if (&coll1 == &coll2) {
        return true;
    }
    // optimization: if not same size, don't bother comparing pairwise
    if (coll1.size() != coll2.size()) {
        return false;
    }

    // check each pair of elements for equality
    auto itr1 = coll1.begin();
    auto end1 = coll1.end();
    auto itr2 = coll2.begin();
    auto end2 = coll2.end();
    while (itr1 != end1 && itr2 != end2) {
        if (!floatingPointEqual(*itr1, *itr2)) {
            return false;
        }
        ++itr1;
        ++itr2;
    }
    return true;
}

/*
 * Returns true if the given two maps contain the same set of keys and each
 * key maps to the same value in both maps.
 * The order of the keys is not considered.
 * The key and value types must both have an operator ==.
 */
template <typename MapType>
bool equalsMap(const MapType& map1, const MapType& map2) {
    // optimization: if literally same map, stop
    if (&map1 == &map2) {
        return true;
    }
    // optimization: if not same size, don't bother comparing pairwise
    if (map1.size() != map2.size()) {
        return false;
    }

    // check whether each element in the first map is also in the second.
    // since the sizes are the same, if this is true, the maps are equal.
    for (auto itr1 = map1.begin(), end1 = map1.end(); itr1 != end1; ++itr1) {
        if (!map2.containsKey(*itr1) || !(map1.get(*itr1) == map2.get(*itr1))) {
            return false;
        }
    }
    return true;
}

/*
 * Computes a hashCode for any iterable type.
 * Pass true for 'orderMatters' for collections that maintain some kind of element
 * ordering that is of importance.  This would be true for almost all collections
 * except hash-based ones where the ordering is semi-random and unimportant.
 */
template <typename IteratorType>
int hashCodeIterable(IteratorType begin, IteratorType end, bool orderMatters = true) {
    int code = hashSeed();
    while (begin != end) {
        if (orderMatters) {
            code *= hashMultiplier();
        }
        code += hashCode(*begin);
        ++begin;
    }
    return int(code & hashMask());
}

/*
 * Computes a hashCode for any type of collection.
 * The collection must have begin() and end()
 */
template <typename CollectionType>
int hashCodeCollection(const CollectionType& collection, bool orderMatters = true) {
    return hashCodeIterable(collection.begin(), collection.end(), orderMatters);
}

/*
 * Template hash function for hash maps.
 * Requires the key and value types in the HashMap to have a hashCode function.
 */
template <typename MapType>
int hashCodeMap(const MapType& map, bool orderMatters = true) {
    int code = hashSeed();
    auto begin = map.begin();
    auto end = map.end();
    while (begin != end) {
        if (orderMatters) {
            code *= hashMultiplier();
        }
        code += hashCode(*begin);

        if (orderMatters) {
            code *= hashMultiplier();
        }
        code += hashCode(map[*begin]);
        ++begin;
    }
    return int(code & hashMask());
}

/*
 * Returns a randomly chosen element of the given collection.
 * Throws an error if the set is empty.
 */
template <typename Collection>
auto randomElement(const Collection& collection) -> const decltype(*collection.begin())& {
    if (collection.isEmpty()) {
        error("randomElement: empty collection was passed");
    }
    return *std::next(collection.begin(), randomInteger(0, collection.size() - 1));
}

/*
 * Returns a randomly chosen element of the given collection.
 * The collection must have an index [] operator.
 * Throws an error if the set is empty.
 */
template <template <typename> class CollectionType, class ElementType>
const ElementType& randomElementIndexed(const CollectionType<ElementType>& collection) {
    if (collection.isEmpty()) {
        error("randomElement: empty collection was passed");
    }
    int index = randomInteger(0, collection.size() - 1);
    return collection[index];
}

/*
 * Reads in any collection from the given input stream.
 * The collection must have an add() method that takes a single value,
 * and a clear() method that removes all elements from the collection.
 */
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
template <typename CollectionType, typename ElementType>
std::istream& readCollection(std::istream& input, CollectionType& collection, ElementType& element, std::string descriptor = "readIterable") {
#else
template <typename CollectionType, typename ElementType>
std::istream& readCollection(std::istream& input, CollectionType& collection, ElementType& element, std::string /* descriptor */) {
#endif
    char ch = '\0';
    input >> ch;
    if (ch != '{') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error(descriptor + ": Missing {");
#endif
        input.setstate(std::ios_base::failbit);
        return input;
    }
    collection.clear();
    input >> ch;
    if (ch != '}') {
        input.unget();
        while (true) {
            if (!readGenericValue(input, element)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(descriptor + ": parse error");
#endif
                return input;
            }
            collection.add(element);
            input >> ch;
            if (ch == '}') {
                break;
            }
            if (ch != ',') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(std::string(descriptor + ": Unexpected character ") + ch);
#endif
                input.setstate(std::ios_base::failbit);
                return input;
            }
        }
    }
    return input;
}

/*
 * Reads in any Map collection from the given input stream.
 * The collection must have an add() method that takes a single value,
 * and a clear() method that removes all elements from the collection.
 */
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
template <typename MapType, typename KeyType, typename ValueType>
std::istream& readMap(std::istream& input, MapType& map, KeyType& key, ValueType& value, std::string descriptor = "readIterable") {
#else
template <typename MapType, typename KeyType, typename ValueType>
std::istream& readMap(std::istream& input, MapType& map, KeyType& key, ValueType& value, std::string /* descriptor */) {
#endif
    char ch = '\0';
    input >> ch;
    if (ch != '{') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error(descriptor + ": Missing {");
#endif
        input.setstate(std::ios_base::failbit);
        return input;
    }
    map.clear();
    input >> ch;
    if (ch != '}') {
        input.unget();
        while (true) {
            if (!readGenericValue(input, key)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(descriptor + ": parse key error");
#endif
                return input;
            }
            input >> ch;
            if (ch != ':') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(descriptor + ": Missing colon after key");
#endif
                input.setstate(std::ios_base::failbit);
                return input;
            }
            if (!readGenericValue(input, value)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(descriptor + ": parse value error");
#endif
                return input;
            }
            map.put(key, value);
            input >> ch;
            if (ch == '}') {
                break;
            }
            if (ch != ',') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(std::string(descriptor + ": Unexpected character ") + ch);
#endif
                input.setstate(std::ios_base::failbit);
                return input;
            }
        }
    }
    return input;
}

/*
 * Writes out any collection to the given output stream using its two iterators,
 * begin and end.
 */
template <typename IteratorType>
std::ostream& writeIterable(std::ostream& out, IteratorType begin, IteratorType end) {
    out << "{";
    bool first = true;
    while (begin != end) {
        if (!first) {
            out << ", ";
        }
        first = false;
        writeGenericValue(out, *begin, /* forceQuotes */ true);
        ++begin;
    }
    out << "}";
    return out;
}

/*
 * Writes out any collection to the given output stream using its two iterators,
 * begin and end.
 */
template <typename CollectionType>
std::ostream& writeCollection(std::ostream& out, CollectionType collection) {
    return writeIterable(out, collection.begin(), collection.end());
}

/*
 * Writes out any collection to the given output stream using its two iterators,
 * begin and end.
 */
template <typename IteratorType>
std::ostream& writeIterableOfPointers(std::ostream& out, IteratorType begin, IteratorType end) {
    out << "{";
    bool first = true;
    while (begin != end) {
        if (!first) {
            out << ", ";
        }
        first = false;
        writeGenericValue(out, **begin, /* forceQuotes */ true);
        ++begin;
    }
    out << "}";
    return out;
}

/*
 * Writes out any collection to the given output stream using its two iterators,
 * begin and end.
 */
template <typename CollectionType>
std::ostream& writeCollectionOfPointers(std::ostream& out, CollectionType collection) {
    return writeIterableOfPointers(out, collection.begin(), collection.end());
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename MapType>
std::ostream& writeMap(std::ostream& out, const MapType& map) {
    out << "{";
    auto begin = map.begin();
    auto end = map.end();
    bool first = true;
    while (begin != end) {
        if (!first) {
            out << ", ";
        }
        first = false;
        writeGenericValue(out, *begin, /* forceQuotes */ true);
        out << ":";
        writeGenericValue(out, map[*begin], /* forceQuotes */ true);
        ++begin;
    }
    out << "}";
    return out;
}

/*
 * Type responsible for tracking the version of some object. This is factored out into
 * its own object with unusual copy functions so that any time the underlying object
 * is moved or assigned the underlying version number is updated.
 */
class VersionTracker {
public:
    /* Assigning a VersionTracker increments the underlying version number. */
    VersionTracker& operator= (VersionTracker) {
        ++mVersion;
        return *this;
    }

    /* Move-constructing a VersionTracker implements the version number of the
     * object being moved.
     */
    VersionTracker(VersionTracker&& rhs) {
        rhs.mVersion++;
    }

    /* Use default constructor and default copy constructor. */
    VersionTracker() = default;
    VersionTracker(const VersionTracker &) = default;

    /* Marks that the version must be updated. */
    void update() {
        ++mVersion;
    }

    /* Returns the version number. */
    unsigned int version() const {
        return mVersion;
    }

private:
    unsigned int mVersion = 0;
};

/*
 * Checked iterator type that wraps an underlying iterator type, adding in bounds-checking
 * and version-checking.
 */
template <typename Iterator> class CheckedIterator {
public:
    /* We're whatever sort of iterator we're wrapping. */
    using difference_type   = typename std::iterator_traits<Iterator>::difference_type;
    using iterator_category = typename std::iterator_traits<Iterator>::iterator_category;
    using pointer           = typename std::iterator_traits<Iterator>::pointer;
    using reference         = typename std::iterator_traits<Iterator>::reference;
    using value_type        = typename std::iterator_traits<Iterator>::value_type;

    /*
     * Default constructor must be explicitly declared so that the private constructor
     * doesn't shadow us.
     */
    CheckedIterator() = default;

    /* Constructs an iterator given information about the underlying container. */
    template <typename Container>
    CheckedIterator(const VersionTracker* owner, Iterator iter, Container& c)
        : mVersion(owner->version()), mOwner(owner), mIter(iter), mBegin(c.begin()), mEnd(c.end()) {

    }

    /*
     * We're friends with all other CheckedIterator types, allowing for cross-construction
     * and the like.
     */
    template <typename OtherItr> friend class CheckedIterator;

    /* Conversion constructor, when permitted. */
    template <typename OtherItr> CheckedIterator(const CheckedIterator<OtherItr>& rhs)
        : mVersion(rhs.mVersion),
          mOwner(rhs.mOwner),
          mIter(rhs.mIter),
          mBegin(rhs.mBegin),
          mEnd(rhs.mEnd) {

    }

    template <typename OtherItr> operator CheckedIterator<OtherItr>() const {
        return CheckedIterator<OtherItr>{mVersion, mOwner, mIter, mBegin, mEnd};
    }

    /* All possible iterator functions. */

    /* Comparison operators. */
    template <typename OtherItr> bool operator ==(const CheckedIterator<OtherItr>& rhs) const {
        if (!mOwner || !rhs.mOwner) {
            error("Cannot compare an uninitialized iterator.");
        }
        if ( mOwner !=  rhs.mOwner) {
            error("Cannot compare iterators from two different containers.");
        }
        return mIter == rhs.mIter;
    }
    template <typename OtherItr> bool operator !=(const CheckedIterator<OtherItr>& rhs) const {
        return !(*this == rhs);
    }

    /*
     * We report errors if the underlying owners are different, since otherwise
     * the behavior is undefined.
     */
    template <typename OtherItr> bool operator <(const CheckedIterator<OtherItr>& rhs) const {
        if (!mOwner || !rhs.mOwner) {
            error("Cannot compare an uninitialized iterator.");
        }
        if (mOwner != rhs.mOwner) {
            error("Cannot compare iterators from different containers.");
        }
        return mIter < rhs.mIter;
    }
    template <typename OtherItr> bool operator >(const CheckedIterator<OtherItr>& rhs) const {
        return rhs < *this;
    }
    template <typename OtherItr> bool operator <=(const CheckedIterator<OtherItr>& rhs) const {
        return !(*this > rhs);
    }
    template <typename OtherItr> bool operator >=(const CheckedIterator<OtherItr>& rhs) const {
        return !(*this < rhs);
    }

    /* Random access. */
    reference operator [](difference_type index) const {
        if (!mOwner) {
            error("Cannot access elements through an uninitialized iterator.");
        }
        ::stanfordcpplib::collections::checkVersion(*mOwner, *this);
        if (index >= 0 &&  index >= mEnd - mIter) {
            error("Out of bounds.");
        }
        if (index <  0 && -index >  mIter - mBegin) {
            error("Out of bounds.");
        }

        return mIter[index];
    }

    CheckedIterator& operator +=(difference_type index) {
        if (!mOwner) error("Cannot advance uninitialized iterators.");
        ::stanfordcpplib::collections::checkVersion(*mOwner, *this);
        mIter += index;
        return *this;
    }
    CheckedIterator& operator -=(difference_type index) {
        return *this += (-index);
    }

    CheckedIterator operator +(difference_type index) const {
        auto result = *this;
        return result += index;
    }
    CheckedIterator operator -(difference_type index) const {
        return *this + (-index);
    }

    template <typename OtherItr>
    difference_type operator -(const CheckedIterator<OtherItr>& rhs) const {
        if (!mOwner || !rhs.mOwner) {
            error("Cannot subtract uninitialized iterators.");
        }

        ::stanfordcpplib::collections::checkVersion(*mOwner, *this);
        if (mOwner != rhs.mOwner) {
            error("Cannot subtract iterators from two different containers.");
        }

        return mIter - rhs.mIter;
    }

    /* Forwards and backwards. */
    CheckedIterator& operator ++() {
        if (!mOwner) {
            error("Cannot advance an uninitialized iterator.");
        }

        ::stanfordcpplib::collections::checkVersion(*mOwner, *this);
        if (mIter == mEnd) {
            error("Cannot advance an iterator past end of range.");
        }
        ++mIter;
        return *this;
    }
    CheckedIterator operator ++(int) {
        auto result = *this;
        ++*this;
        return result;
    }

    CheckedIterator& operator --() {
        if (!mOwner) {
            error("Cannot back up an uninitialized iterator.");
        }

        ::stanfordcpplib::collections::checkVersion(*mOwner, *this);
        if (mIter == mBegin) {
            error("Cannot back up an iteartor before start of range.");
        }

        --mIter;
        return *this;
    }
    CheckedIterator operator --(int) {
        auto result = *this;
        --*this;
        return result;
    }

    /* Dereferencing. */
    reference operator *() const {
        if (!mOwner) {
            error("Cannot dereference an uninitialized iterator.");
        }
        ::stanfordcpplib::collections::checkVersion(*mOwner, *this);

        if (mIter == mEnd) {
            error("Iterator out of range.");
        }
        return *mIter;
    }
    pointer operator ->() const {
        return &**this;
    }

    /* Direct version access. */
    unsigned int version() const {
        if (!mOwner) {
            error("Cannot get version from an uninitialized iterator.");
        }
        return mVersion;
    }

private:
    unsigned int mVersion = 0;
    const VersionTracker* mOwner = nullptr;
    Iterator mIter;
    Iterator mBegin, mEnd;
};

/*
 * Iterator over a pairs that projects out the first component. Essentially, this turns an
 * iterator over pair<const Key, Value> into an iterator over const Key.
 *
 * All bounds-checking, error-handling, etc. are presumed to come from the underlying
 * iterator type.
 */
template <typename Iterator> class ProjectingIterator {
public:
    /* The sort of thing that we're wrapping. */
    using value_type       = typename std::remove_reference<decltype(std::declval<Iterator>()->first)>::type;

    /* We're whatever sort of iterator we're wrapping. */
    using difference_type   = typename std::iterator_traits<Iterator>::difference_type;
    using iterator_category = typename std::iterator_traits<Iterator>::iterator_category;
    using pointer           = const value_type *;
    using reference         = const value_type &;

    /*
     * Default constructor must be explicitly declared so that the private constructor
     * doesn't shadow us.
     */
    ProjectingIterator() = default;

    /* Wraps an existing iterator. */
    explicit ProjectingIterator(Iterator iter) : mIter(iter) {
        // Empty
    }

    /*
     * We're friends with all other related types, allowing for cross-construction
     * and the like.
     */
    template <typename OtherItr> friend class ProjectingIterator;

    /* Conversion constructor, when permitted. */
    template <typename OtherItr> ProjectingIterator(const ProjectingIterator<OtherItr>& rhs)
        : mIter(rhs.mIter) {
        // Empty
    }

    template <typename OtherItr> operator ProjectingIterator<OtherItr>() const {
        return ProjectingIterator<OtherItr>(mIter);
    }

    /* All possible iterator functions. */

    /* Comparison operators. */
    template <typename OtherItr> bool operator ==(const ProjectingIterator<OtherItr>& rhs) {
        return mIter == rhs.mIter;
    }
    template <typename OtherItr> bool operator !=(const ProjectingIterator<OtherItr>& rhs) {
        return !(*this == rhs);
    }

    template <typename OtherItr> bool operator <(const ProjectingIterator<OtherItr>& rhs) {
        return mIter < rhs.mIter;
    }
    template <typename OtherItr> bool operator >(const ProjectingIterator<OtherItr>& rhs) {
        return rhs < *this;
    }
    template <typename OtherItr> bool operator <=(const ProjectingIterator<OtherItr>& rhs) {
        return !(*this > rhs);
    }
    template <typename OtherItr> bool operator >=(const ProjectingIterator<OtherItr>& rhs) {
        return !(*this < rhs);
    }

    /* Random access. */
    reference operator [](difference_type index) const {
        return mIter[index];
    }
    ProjectingIterator& operator +=(difference_type index) {
        mIter += index;
        return *this;
    }
    ProjectingIterator& operator -=(difference_type index) {
        return *this += (-index);
    }
    ProjectingIterator operator +(difference_type index) const {
        auto result = *this;
        return result += index;
    }
    ProjectingIterator operator -(difference_type index) const {
        return *this + (-index);
    }
    template <typename OtherItr>
    difference_type operator -(const ProjectingIterator<OtherItr>& rhs) const {
        return mIter - rhs.mIter;
    }

    /* Forwards and backwards. */
    ProjectingIterator& operator ++() {
        ++mIter;
        return *this;
    }
    ProjectingIterator operator ++(int) {
        auto result = *this;
        ++*this;
        return result;
    }

    ProjectingIterator& operator --() {
        --mIter;
        return *this;
    }
    ProjectingIterator operator --(int) {
        auto result = *this;
        --*this;
        return result;
    }

    /* Dereferencing. */
    reference operator *() const {
        return mIter->first;
    }
    pointer operator ->() const {
        return &**this;
    }

private:
    Iterator mIter;
};

/**
 * Class: GenericSet<SetTraits>
 * ----------------------------
 * This class stores a collection of distinct elements. SetTraits should be
 * a type containing the following:
 *
 *     typename ValueType:          whatever is stored in the map
 *     typename MapType:            should be a Map<ValueType, bool>
 *     static std::string name():   should return the name of the type.
 *
 * There's one more requirement: you need to define a function
 *
 *     template <typename... Args>
 *        static MapType construct(Args&&... args)
 *
 * that constructs an internal MapType object with the specified arguments.
 * This function should do something creative or clever to ensure that there
 * is a nice compiler error generated in the event that the arguments are
 * invalid, since otherwise the error is going to be deeply nested inside the
 * GenericSet template.
 *
 * This is not meant to be used directly by students.
 */
template <typename SetTraits>
class GenericSet {
public:
    /**
     * Utility alias to make things easier to work with.
     */
    using value_type = typename SetTraits::ValueType;

    /**
     * Constructor: GenericSet
     * Usage: GenericSet<ValueType, SetTraits> set;
     * --------------------------------------------
     * Initializes an empty set of the specified element type.
     */
    GenericSet() = default;

    /**
     * Constructor: GenericSet
     * Usage: GenericSet<ValueType, SetTraits> set {1, 2, 3};
     * ------------------------------------------------------
     * Initializes a new set that stores the given elements.
     */
    GenericSet(std::initializer_list<value_type> list);

    /**
     * Constructor: GenericSet
     * Usage: GenericSet<ValueType, SetTraits> set(... things for the map ...);
     * ------------------------------------------------------------------------
     * Forwards the specified arguments down to the underlying Map type.
     */
    template <typename... Args>
    explicit GenericSet(Args... args);

    /**
     * Constructor: GenericSet
     * Usage: GenericSet<ValueType, SetTraits> set({1, 2, 3}, ... things for the map ...);
     * -----------------------------------------------------------------------------------
     * Constructs a set using the specified elements, forwarding the arguments to the
     * underlying map.
     */
    template <typename... Args>
    GenericSet(std::initializer_list<value_type> list,
               Args... args);

    /**
     * Destructor: ~Set
     * ----------------
     * Frees any heap storage associated with this set.
     */
    virtual ~GenericSet() = default;

    /**
     * Method: add
     * Usage: set.add(value);
     * ----------------------
     * Adds an element to this set, if it was not already there.  For
     * compatibility with the STL <code>set</code> class, this method
     * is also exported as <code>insert</code>.
     */
    void add(const value_type& value);

    /**
     * Method: addAll
     * Usage: set.addAll(set2);
     * ------------------------
     * Adds all elements of the given other set to this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     *
     * Note that this function modifies the current set in place rather than
     * returning a new set. If you want a new set, consider using the + operator
     * instead (not +=), which returns a newly created copy set.
     *
     * Identical in behavior to the += operator.
     */
    GenericSet& addAll(const GenericSet& set);

    /**
     * Method: back
     * Usage: ValueType value = set.back();
     * ------------------------------------
     * Returns the last value in the set in the order established by the
     * <code>foreach</code> macro.  If the set is empty, generates an error.
     */
    value_type back() const;

    /**
     * Method: clear
     * Usage: set.clear();
     * -------------------
     * Removes all elements from this set.
     */
    void clear();

    /**
     * Method: contains
     * Usage: if (set.contains(value)) ...
     * -----------------------------------
     * Returns <code>true</code> if the specified value is in this set.
     */
    bool contains(const value_type& value) const;

    /**
     * Method: containsAll
     * Usage: if (set.containsAll(set2)) ...
     * -------------------------------------
     * Returns <code>true</code> if every value from the given other set
     * is also found in this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(const GenericSet& set2) const;

    /**
     * Method: difference
     * Usage: set.difference(set2);
     * ----------------------------
     * Removes all elements of the given other set from this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     *
     * Note that this function modifies the current set in place rather than
     * returning a new set. If you want a new set, consider using the - operator
     * instead (not -=), which returns a newly created copy set.
     *
     * Identical in behavior to the -= operator and the removeAll function.
     */
    GenericSet& difference(const GenericSet& set);

    /**
     * Method: equals
     * Usage: if (set.equals(set2)) ...
     * --------------------------------
     * Returns <code>true</code> if this set contains exactly the same values
     * as the given other set.
     * Identical in behavior to the == operator.
     */
    bool equals(const GenericSet& set2) const;

    /**
     * Method: first
     * Usage: ValueType value = set.first();
     * -------------------------------------
     * Returns the first value in the set in the order established by the
     * <code>foreach</code> macro.  If the set is empty, <code>first</code>
     * generates an error.
     * Equivalent to front.
     */
    value_type first() const;

    /**
     * Method: front
     * Usage: ValueType value = set.front();
     * -------------------------------------
     * Returns the first value in the set in the order established by the
     * <code>foreach</code> macro.  If the set is empty, generates an error.
     * Equivalent to first.
     */
    value_type front() const;

    /**
     * Method: insert
     * Usage: set.insert(value);
     * -------------------------
     * Adds an element to this set, if it was not already there.  This
     * method is exported for compatibility with the STL <code>set</code> class.
     */
    void insert(const value_type& value);

    /**
     * Method: intersect
     * Usage: set.intersect(set2);
     * ---------------------------
     * Removes all elements from this set that are not contained in the given
     * other set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     *
     * Note that this function modifies the current set in place rather than
     * returning a new set. If you want a new set, consider using the * operator
     * instead (not *=), which returns a newly created copy set.
     *
     * Identical in behavior to the *= operator and the retainAll function.
     */
    GenericSet& intersect(const GenericSet& set);

    /**
     * Method: isEmpty
     * Usage: if (set.isEmpty()) ...
     * -----------------------------
     * Returns <code>true</code> if this set contains no elements.
     */
    bool isEmpty() const;

    /**
     * Method: isSubsetOf
     * Usage: if (set.isSubsetOf(set2)) ...
     * ------------------------------------
     * Implements the subset relation on sets.  It returns
     * <code>true</code> if every element of this set is
     * contained in <code>set2</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    bool isSubsetOf(const GenericSet& set2) const;

    /**
     * Method: isSupersetOf
     * Usage: if (set.isSupersetOf(set2)) ...
     * --------------------------------------
     * Implements the superset relation on sets.  It returns
     * <code>true</code> if every element of this set is
     * contained in <code>set2</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(const GenericSet& set2) const;

    /**
     * Method: mapAll
     * Usage: set.mapAll(fn);
     * ----------------------
     * Iterates through the elements of the set and calls <code>fn(value)</code>
     * for each one.  The iteration order matches the underlying order in which
     * the elements are stored.  For Set, this is sorted order according to the
     * comparison function; for LinkedHashSet, this is the insertion order; and
     * for HashSet, this is whatever order the elements happen to be in.
     */
    void mapAll(std::function<void (const value_type&)> fn) const;

    /**
     * Method: remove
     * Usage: set.remove(value);
     * -------------------------
     * Removes an element from this set.  If the value was not
     * contained in the set, no error is generated and the set
     * remains unchanged.
     */
    void remove(const value_type& value);

    /**
     * Method: removeAll
     * Usage: set.removeAll(set2);
     * ---------------------------
     * Removes all elements of the given other set from this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     *
     * Note that this function modifies the current set in place rather than
     * returning a new set. If you want a new set, consider using the - operator
     * instead (not -=), which returns a newly created copy set.
     *
     * Identical in behavior to the -= operator and the difference function.
     */
    GenericSet& removeAll(const GenericSet& set);

    /**
     * Method: retainAll
     * Usage: set.retainAll(set2);
     * ---------------------------
     * Removes all elements from this set that are not contained in the given
     * other set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     *
     * Note that this function modifies the current set in place rather than
     * returning a new set. If you want a new set, consider using the * operator
     * instead (not *=), which returns a newly created copy set.
     *
     * Identical in behavior to the *= operator and the intersect function.
     */
    GenericSet& retainAll(const GenericSet& set);

    /**
     * Method: size
     * Usage: count = set.size();
     * --------------------------
     * Returns the number of elements in this set.
     */
    int size() const;

    /**
     * Method: toString
     * Usage: string str = set.toString();
     * -----------------------------------
     * Converts the set to a printable string representation.
     */
    std::string toString() const;

    /**
     * Method: unionWith
     * Usage: set.unionWith(set2);
     * ---------------------------
     * Adds all elements of the given other set to this set.
     * You can also pass an initializer list such as {1, 2, 3}.
     * Returns a reference to this set.
     * Identical in behavior to the += operator and the addAll function.
     *
     * Note that this function modifies the current set in place rather than
     * returning a new set. If you want a new set, consider using the + operator
     * instead (not +=), which returns a newly created copy set.
     *
     * (Implementation note: This function cannot be named 'union' because
     * that is a C/C++ keyword.)
     */
    GenericSet& unionWith(const GenericSet& set);

    /**
     * Operator: ==
     * Usage: set1 == set2
     * -------------------
     * Returns <code>true</code> if <code>set1</code> and <code>set2</code>
     * contain the same elements.
     */
    bool operator ==(const GenericSet& set2) const;

    /**
     * Operator: !=
     * Usage: set1 != set2
     * -------------------
     * Returns <code>true</code> if <code>set1</code> and <code>set2</code>
     * are different.
     */
    bool operator !=(const GenericSet& set2) const;

    /**
     * Operators: <, >, <=, >=
     * Usage: if (set1 <= set2) ...
     * ...
     * ----------------------------
     * Relational operators to compare two sets.
     * The <, >, <=, >= operators require that the value type has a < operator
     * so that the elements can be compared pairwise.
     *
     * These are implemented as friend functions so that if we fully instantiate
     * this type, we don't get errors when using relational operators.
     */
    template <typename Traits>
    friend bool operator <(const GenericSet<Traits>& set1, const GenericSet<Traits>& set2);
    template <typename Traits>
    friend bool operator <=(const GenericSet<Traits>& set1, const GenericSet<Traits>& set2);
    template <typename Traits>
    friend bool operator >(const GenericSet<Traits>& set1, const GenericSet<Traits>& set2);
    template <typename Traits>
    friend bool operator >=(const GenericSet<Traits>& set1, const GenericSet<Traits>& set2);

    /**
     * Operator: +
     * Usage: set1 + set2
     *        set1 + element
     * ---------------------
     * Returns the union of sets <code>set1</code> and <code>set2</code>, which
     * is the set of elements that appear in at least one of the two sets.
     * You can also pass an initializer list such as {1, 2, 3}.
     * The right hand set can be replaced by an element of the value type, in
     * which case the operator returns a new set formed by adding that element.
     */
    GenericSet operator +(const GenericSet& set2) const;
    GenericSet operator +(const value_type& element) const;

    /**
     * Operator: *
     * Usage: set1 * set2
     * ------------------
     * Returns the intersection of sets <code>set1</code> and <code>set2</code>,
     * which is the set of all elements that appear in both.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    GenericSet operator *(const GenericSet& set2) const;

    /**
     * Operator: -
     * Usage: set1 - set2
     *        set1 - element
     * ---------------------
     * Returns the difference of sets <code>set1</code> and <code>set2</code>,
     * which is all of the elements that appear in <code>set1</code> but
     * not <code>set2</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     * The right hand set can be replaced by an element of the value type, in
     * which case the operator returns a new set formed by removing that element.
     */
    GenericSet operator -(const GenericSet& set2) const;
    GenericSet operator -(const value_type& element) const;

    /**
     * Operator: +=
     * Usage: set1 += set2;
     *        set1 += value;
     * ---------------------
     * Adds all of the elements from <code>set2</code> (or the single
     * specified value) to <code>set1</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     * As a convenience, the <code>Set</code> package also overloads the comma
     * operator so that it is possible to initialize a set like this:
     *
     *<pre>
     *    Set&lt;int&gt; digits;
     *    digits += 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
     *</pre>
     */
    GenericSet& operator +=(const GenericSet& set2);
    GenericSet& operator +=(const value_type& value);

    /**
     * Operator: *=
     * Usage: set1 *= set2;
     * --------------------
     * Removes any elements from <code>set1</code> that are not present in
     * <code>set2</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    GenericSet& operator *=(const GenericSet& set2);

    /**
     * Operator: -=
     * Usage: set1 -= set2;
     *        set1 -= value;
     * ---------------------
     * Removes the elements from <code>set2</code> (or the single
     * specified value) from <code>set1</code>.
     * You can also pass an initializer list such as {1, 2, 3}.
     * As a convenience, the <code>Set</code> package also overloads the comma
     * operator so that it is possible to remove multiple elements from a set
     * like this:
     *
     *<pre>
     *    digits -= 0, 2, 4, 6, 8;
     *</pre>
     *
     * which removes the values 0, 2, 4, 6, and 8 from the set
     * <code>digits</code>.
     */
    GenericSet& operator -=(const GenericSet& set2);
    GenericSet& operator -=(const value_type& value);

    /*
     * Additional Set operations
     * -------------------------
     * In addition to the methods listed in this interface, the Set
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * The iteration forms process the Set in ascending order.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    typename SetTraits::MapType map = SetTraits::construct();  /* Map used to store the elements    */
    bool removeFlag = false;                                   /* Flag to differentiate += and -=   */

public:
    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support the comma operator, copying, and iteration.
     *
     * Including these methods in the public interface would make
     * that interface more difficult to understand for the average client.
     */
    GenericSet& operator ,(const value_type& value) {
        if (this->removeFlag) {
            this->remove(value);
        } else {
            this->add(value);
        }
        return *this;
    }

    using const_iterator = typename SetTraits::MapType::const_iterator;
    using iterator = const_iterator;

    iterator begin() const {
        return map.begin();
    }

    iterator end() const {
        return map.end();
    }

    friend int hashCode(const GenericSet& set) {
        return hashCode(set.map);
    }
};

template <typename SetTraits>
GenericSet<SetTraits>::GenericSet(std::initializer_list<value_type> list)
    : map(SetTraits::construct()) {
    /* Can't do addAll because that would recursively try constructing a GenericSet.
     * Instead, directly add everything here. This becomes the focal point for
     * all initializer_list conversions.
     */
    for (const auto& elem: list) {
        add(elem);
    }
}

template <typename SetTraits>
template <typename... Args>
GenericSet<SetTraits>::GenericSet(Args... args) : GenericSet({}, std::move(args)...) {
    // Handled by other constructor
}

template <typename SetTraits>
template <typename... Args>
GenericSet<SetTraits>::GenericSet(std::initializer_list<value_type> list, Args... args)
    : map(SetTraits::construct(std::move(args)...)) {

    /* Can't do addAll because that would recursively try constructing a GenericSet.
     * Instead, directly add everything here. This becomes the focal point for
     * all initializer_list conversions.
     */
    for (const auto& elem: list) {
        add(elem);
    }
}

template <typename SetTraits>
void GenericSet<SetTraits>::add(const value_type& value) {
    map.put(value, true);
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::addAll(const GenericSet& set2) {
    for (const auto& value : set2) {
        add(value);
    }
    return *this;
}

template <typename SetTraits>
typename GenericSet<SetTraits>::value_type
GenericSet<SetTraits>::back() const {
    if (isEmpty()) {
        error(SetTraits::name() + "::back: set is empty");
    }
    return map.back();
}

template <typename SetTraits>
void GenericSet<SetTraits>::clear() {
    map.clear();
}

template <typename SetTraits>
bool GenericSet<SetTraits>::contains(const value_type& value) const {
    return map.containsKey(value);
}

template <typename SetTraits>
bool GenericSet<SetTraits>::containsAll(const GenericSet& set2) const {
    for (const auto& value: set2) {
        if (!contains(value)) {
            return false;
        }
    }
    return true;
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::difference(const GenericSet<SetTraits>& set) {
    return removeAll(set);
}

template <typename SetTraits>
bool GenericSet<SetTraits>::equals(const GenericSet& set2) const {
    // optimization: if literally same set, stop
    if (this == &set2) {
        return true;
    }

    /* We are equal if we have the same size and we're a subset of the other
     * set.
     */
    if (size() != set2.size()) {
        return false;
    }
    return isSubsetOf(set2);
}

template <typename SetTraits>
typename GenericSet<SetTraits>::value_type
GenericSet<SetTraits>::first() const {
    if (isEmpty()) {
        error(SetTraits::name() + "::first: set is empty");
    }
    return *begin();
}

template <typename SetTraits>
typename GenericSet<SetTraits>::value_type
GenericSet<SetTraits>::front() const {
    if (isEmpty()) {
        error(SetTraits::name() + "::front: set is empty");
    }
    return map.front();
}

template <typename SetTraits>
void GenericSet<SetTraits>::insert(const value_type& value) {
    map.put(value, true);
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::intersect(const GenericSet<SetTraits>& set) {
    return retainAll(set);
}

template <typename SetTraits>
bool GenericSet<SetTraits>::isEmpty() const {
    return map.isEmpty();
}

template <typename SetTraits>
bool GenericSet<SetTraits>::isSubsetOf(const GenericSet& set2) const {
    for (const auto& elem: *this) {
        if (!set2.contains(elem)) {
            return false;
        }
    }
    return true;
}

template <typename SetTraits>
bool GenericSet<SetTraits>::isSupersetOf(const GenericSet& set2) const {
    return containsAll(set2);
}

template <typename SetTraits>
void GenericSet<SetTraits>::mapAll(std::function<void (const value_type &)> fn) const {
    map.mapAll([&](const value_type& elem, bool) {
        fn(elem);
    });
}

template <typename SetTraits>
void GenericSet<SetTraits>::remove(const value_type& value) {
    map.remove(value);
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::removeAll(const GenericSet& set2) {
    map.removeAll(set2.map);
    return *this;
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::retainAll(const GenericSet& set2) {
    map.retainAll(set2.map);
    return *this;
}

template <typename SetTraits>
int GenericSet<SetTraits>::size() const {
    return map.size();
}

template <typename SetTraits>
std::string GenericSet<SetTraits>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::unionWith(const GenericSet<SetTraits>& set) {
    return addAll(set);
}


/*
 * Implementation notes: set operators
 * -----------------------------------
 * The implementations for the set operators use iteration to walk
 * over the elements in one or both sets.
 */
template <typename SetTraits>
bool GenericSet<SetTraits>::operator ==(const GenericSet& set2) const {
    return equals(set2);
}

template <typename SetTraits>
bool GenericSet<SetTraits>::operator !=(const GenericSet& set2) const {
    return !equals(set2);
}

template <typename SetTraits>
bool operator <(const GenericSet<SetTraits>& set1, const GenericSet<SetTraits>& set2) {
    return set1.map < set2.map;
}

template <typename SetTraits>
bool operator <=(const GenericSet<SetTraits>& set1, const GenericSet<SetTraits>& set2) {
    return set1.map <= set2.map;
}

template <typename SetTraits>
bool operator >(const GenericSet<SetTraits>& set1, const GenericSet<SetTraits>& set2) {
    return set1.map > set2.map;
}

template <typename SetTraits>
bool operator >=(const GenericSet<SetTraits>& set1, const GenericSet<SetTraits>& set2) {
    return set1.map >= set2.map;
}

template <typename SetTraits>
GenericSet<SetTraits> GenericSet<SetTraits>::operator +(const GenericSet& set2) const {
    return GenericSet(*this).addAll(set2);
}

template <typename SetTraits>
GenericSet<SetTraits> GenericSet<SetTraits>::operator +(const value_type& element) const {
    GenericSet result = *this;
    result.add(element);
    return result;
}

template <typename SetTraits>
GenericSet<SetTraits> GenericSet<SetTraits>::operator *(const GenericSet& set2) const {
    return GenericSet(*this).retainAll(set2);
}

template <typename SetTraits>
GenericSet<SetTraits> GenericSet<SetTraits>::operator -(const GenericSet& set2) const {
    return GenericSet(*this).removeAll(set2);
}

template <typename SetTraits>
GenericSet<SetTraits> GenericSet<SetTraits>::operator -(const value_type& element) const {
    GenericSet result = *this;
    result.remove(element);
    return result;
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::operator +=(const GenericSet& set2) {
    removeFlag = false;
    return addAll(set2);
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::operator +=(const value_type& value) {
    add(value);
    removeFlag = false;
    return *this;
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::operator *=(const GenericSet& set2) {
    return retainAll(set2);
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::operator -=(const GenericSet& set2) {
    removeFlag = true;
    return removeAll(set2);
}

template <typename SetTraits>
GenericSet<SetTraits>& GenericSet<SetTraits>::operator -=(const value_type& value) {
    remove(value);
    removeFlag = true;
    return *this;
}

template <typename SetTraits>
std::ostream& operator <<(std::ostream& os, const GenericSet<SetTraits>& set) {
    return stanfordcpplib::collections::writeCollection(os, set);
}

template <typename SetTraits>
std::istream& operator >>(std::istream& is, GenericSet<SetTraits>& set) {
    typename SetTraits::ValueType element;
    return stanfordcpplib::collections::readCollection(is, set, element, /* descriptor */ SetTraits::name() + "::operator >>");
}


/*
 * Types used to automatically check whether a type is comparable using
 * the < operator and whether a type supports operator== and hashCode.
 *
 * This is used to provide better compiler diagnostics to students when
 * they try to instantiate our times incorrectly.
 *
 * Later on, when C++20 concepts are rolled out, we should consider
 * replacing this code with concepts.
 */
template <typename T>
struct IsLessThanComparable {
private:
    /* Use SFNIAE overloading to detect which of these two options to pick. */
    struct Yes{};
    struct No {};

    template <typename U>
    static Yes check(int,
                     decltype(std::declval<U>() < std::declval<U>()) = 0);
    template <typename U> static No  check(...);

public:
    static constexpr bool value =
            std::conditional<std::is_same<decltype(check<T>(0)), Yes>::value,
                             std::true_type,
                             std::false_type>::type::value;
};

template <typename T>
struct IsHashable {
private:
    /* Use SFNIAE overloading to detect which of these two options to pick. */
    struct Yes{};
    struct No {};

    template <typename U>
    static Yes check(int,
                     decltype(hashCode(std::declval<U>())) = 0,
                     decltype(std::declval<U>() == std::declval<U>()) = 0);
    template <typename U> static No  check(...);

public:
    static constexpr bool value =
            std::conditional<std::is_same<decltype(check<T>(0)), Yes>::value,
                             std::true_type,
                             std::false_type>::type::value;
};

/*
 * Returns std::less<T>, except with a nice static assertion wrapped around it to
 * make sure that in the event that T isn't comparable via <, the error message is
 * more readable.
 */
template <typename T>
std::function<bool (const T&, const T&)> checkedLess() {
    static_assert(IsLessThanComparable<T>::value,
                  "Oops! You tried using a type as a key in our Map without making it comparable. Click this error for more details.");
    /*
     * Hello CS106 students! If you got directed to this line of code in a compiler error,
     * it probably means that you tried making a Map with a custom struct or class type
     * as the key type or a Set with a custom struct as a value type.
     *
     * In order to have a type be a key type in a Map - or to have a type be a value type
     * in a Set - it needs to have be comparable using the < operator. By default, types in C++
     * can't be compared using the < operator, hence the error.
     *
     * There are two ways to fix this. The first option would simply be to not use your custom
     * type as a key in the Map or value in a Set. This is probably the easiest option.
     *
     * The second way to fix this is to explicitly define an operator< function for your custom
     * type. Here's the syntax for doing that:
     *
     *     bool operator< (const YourCustomType& lhs, const YourCustomType& rhs) {
     *         return compareTo(lhs.data1, rhs.data1,
     *                          lhs.data2, rhs.data2,
     *                          ...
     *                          lhs.dataN, rhs.dataN);
     *     }
     *
     * where data1, data2, ... dataN are the data members of your type. For example, if you had
     * a custom type
     *
     *     struct MyType {
     *         int myInt;
     *         string myString;
     *     };
     *
     * you would define the function
     *
     *     bool operator< (const MyType& lhs, const MyType& rhs) {
     *         return compareTo(lhs.myInt,    rhs.myInt,
     *                          lhs.myString, rhs.myString);
     *     }
     *
     * Hope this helps!
     */
    return std::less<T>();
}

/*
 * Utility traits type that always contains a value that's false.
 */
template <typename... Args> struct Fail {
    static constexpr bool value = false;
};

} // namespace collections
} // namespace stanfordcpplib

#endif // _collections_h

/////////////////////// END code extracted from StanfordCPPLib/collections/collections.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/observable.h ///////////////////////
/*
 * File: observable.h
 * ------------------
 * This file defines an abstract superclass named <code>Observable</code> that
 * allows objects to store lists of observers, which are other objects that are
 * notified when some part of the state of the observable object changes.
 * This is an example of the classic Observer/Observable design pattern.
 *
 * @author Marty Stepp
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/10/25
 * - added addObserver/removeObserver overloads that accept reference param
 * @version 2016/11/20
 * - refactored to use template for event type
 * @version 2014/10/08
 * - removed 'using namespace' statement
 * - fixed bug in error string on removeObserver (said 'addObserver')
 * @version 2014/03/09
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _observable_h
#define _observable_h

#include <set>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

// forward declarations
template <class T>
class Observer;

/**
 * This abstract superclass allows objects to store lists of observers,
 * which are other objects that would like to be notified when some part of the
 * state of the observable object changes.
 *
 * The intended usage is that you should extend Observable in the object you
 * want to be watched, then call notifyObservers in its code at appropriate
 * places.  Then create some other object that extends Observer and defines an
 * update method, and attach it to the Observable so it will be notified.
 */
template <typename T>
class Observable {
public:
    /**
     * Adds the given observer object to this observable object's internal list
     * of observers.  The observer's update method will be called when the
     * notifyObservers method is called afterward.
     * Precondition: obs != nullptr
     */
    void addObserver(Observer<T>* obs);

    /**
     * Adds the given observer object to this observable object's internal list
     * of observers.  The observer's update method will be called when the
     * notifyObservers method is called afterward.
     */
    void addObserver(Observer<T>& obs);

    /**
     * Calls the update method of all observers that have been added previously
     * to this observable object.
     * The given argument can be passed to provide extra information to the
     * observers if necessary.  If no argument is passed, nullptr is used.
     */
    void notifyObservers(T arg = T());

    /**
     * Removes the given observer object from this observable object's internal
     * list of observers.  The observer will no longer be notified.
     */
    void removeObserver(Observer<T>* obs);

    /**
     * Removes the given observer object from this observable object's internal
     * list of observers.  The observer will no longer be notified.
     */
    void removeObserver(Observer<T>& obs);

private:
    // a list of observers to notify when notifyObservers is called
    std::set<Observer<T>*> m_observers;
};

/**
 * An object that wishes to be notified when the state of an observable object
 * changes.
 */
template <typename T>
class Observer {
public:
    /**
     * Called by an Observable to inform this observer that its state changed.
     * The 'obs' parameter will be a pointer to the observable object itself
     * on which the state change occurred.  The 'arg' parameter will be
     * the extra information passed by the Observable when it called
     * notifyObservers, if any.
     */
    virtual void update(Observable<T>* obs, const T& arg = T()) = 0;
};

template <typename T>
void Observable<T>::addObserver(Observer<T>* obs) {
    if (!obs) {
        error("Observable::addObserver: null observer passed");
    }
    m_observers.insert(obs);
}

template <typename T>
void Observable<T>::addObserver(Observer<T>& obs) {
    addObserver(&obs);
}

template <typename T>
void Observable<T>::notifyObservers(T arg) {
    for (Observer<T>* obs : m_observers) {
        obs->update(this, arg);
    }
}

template <typename T>
void Observable<T>::removeObserver(Observer<T>* obs) {
    if (!obs) {
        error("Observable::removeObserver: null observer passed");
    }
    m_observers.erase(obs);
}

template <typename T>
void Observable<T>::removeObserver(Observer<T>& obs) {
    removeObserver(&obs);
}

#endif // _observable_h

/////////////////////// END code extracted from StanfordCPPLib/util/observable.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/recursion.h ///////////////////////
/*
 * File: recursion.h
 * -----------------
 * This file includes a few utility functions related to recursion.
 * You can use them to print a debug message that is indented relative
 * to the level of recursion you are currently nested in.
 *
 * @author Marty Stepp
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2016/10/30
 * - initial version (extracted from exceptions.h)
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _recursion_h
#define _recursion_h

#include <string>

/**
 * Returns number of calls deep we are in the current recursive function.
 * For example, if f() calls f() calls f(), this function returns 3.
 *
 * NOTE: Doesn't usually work when used with 'static' functions, because their names
 * are not exported or revealed to the internal stack trace grabber.
 * So if you want to use this function, make your function non-static.
 */
int getRecursionIndentLevel();

/**
 * Returns a string of indentation that can be used to pretty-print recursive calls
 * at their corresponding level of nesting.
 * Indents by 4 spaces per level but can be overridden by passing 'indenter' param.
 *
 * NOTE: Doesn't usually work when used with static functions, because their names
 * are not exported or revealed to the internal stack trace grabber.
 * So if you want to use this function, make your function non-static.
 */
std::string recursionIndent(const std::string& indenter = "    ");

#endif // _recursion_h

/////////////////////// END code extracted from StanfordCPPLib/util/recursion.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/system/exceptions.h ///////////////////////
/*
 * File: exceptions.h
 * ------------------
 * This file contains a top-level exception handler to print exceptions thrown
 * by student code on the console.
 * It also contains some wizardry to try to retrieve a stack trace when the
 * exception is thrown, though it is hard to consistently do this on all platforms.
 * 
 * @author Marty Stepp
 * @version 2018/09/25
 * - add 'force' parameter to setTopLevelExceptionHandlerEnabled
 *   (helps it to work better with threads)
 * - added doc comments for new documentation generation
 * @version 2016/11/07
 * - added cleanupFunctionNameForStackTrace
 * @version 2016/10/30
 * - moved recursion functions to recursion.h/cpp
 * @version 2014/11/12
 * - made printStackTrace function publicly available
 * - added top-level signal handler (for null-pointer derefs etc.)
 * @since 2014/11/05
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _exceptions_h
#define _exceptions_h

#include <iostream>

namespace exceptions {
/**
 * Strips some extraneous text from a function's name/header to make it look
 * better when printed in a stack trace.
 * e.g. basic_string -> string, removes std::, removes some weird compiler gibberish.
 */
std::string cleanupFunctionNameForStackTrace(std::string function);

/**
 * Called by C++ lib's main wrapper so that the stack trace knows the program's name.
 * (Taken from argv[0].)
 */
std::string& getProgramNameForStackTrace();

/**
 * Returns whether the top-level exception handler is enabled.
 * Initially false.
 */
bool getTopLevelExceptionHandlerEnabled();

/**
 * Prints a stack trace to the system standard error console (cerr).
 * (Stack traces are highly OS- and compiler-dependent, so this function
 *  may not work perfectly on all platforms.  It has been tested to work
 *  on Linux with GCC/G++, Mac OS X with clang++, and Windows with MinGW.)
 */
void printStackTrace();

/**
 * Prints a stack trace to the given output stream.
 * Defaults to the system standard error console (cerr).
 * (Stack traces are highly OS- and compiler-dependent, so this function
 *  may not work perfectly on all platforms.  It has been tested to work
 *  on Linux with GCC/G++, Mac OS X with clang++, and Windows with MinGW.)
 */
void printStackTrace(std::ostream& out);

/**
 * Called by C++ lib's main wrapper so that the stack trace knows the program's name.
 * (Taken from argv[0].)
 */
void setProgramNameForStackTrace(char* programName);

/**
 * Sets whether the top-level exception handler is enabled.
 * If the optional 'force' parameter is passed, will set the handler again
 * even if it was set before.
 */
void setTopLevelExceptionHandlerEnabled(bool enabled, bool force = false);

/**
 * Whether the given function should be filtered out when displaying a stack trace.
 * Not meant to be called by clients.
 */
bool shouldFilterOutFromStackTrace(const std::string& function);
}

#endif // _exceptions_h

/////////////////////// END code extracted from StanfordCPPLib/system/exceptions.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/vector.h ///////////////////////
/*
 * File: vector.h
 * --------------
 * This file exports the <code>Vector</code> class, which provides an
 * efficient, safe, convenient replacement for the array type in C++.
 *
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2019/02/04
 * - changed internal implementation to wrap std collections
 * @version 2018/09/06
 * - refreshed doc comments for new documentation generation
 * @version 2018/01/07
 * - added front, back, removeFront, removeBack, pop_front, pop_back, push_front
 * @version 2017/11/15
 * - added contains, indexOf, lastIndexOf, removeValue, reverse, shuffle, sort
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2016/12/09
 * - added iterator version checking support
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/12
 * - bug fix for constructor based on initializer list
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as {1, 2, 3}
 *   in constructor, addAll, +, +=
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/10/13
 * - nulled out pointer fields in destructor after deletion to avoid double-free
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 * @version 2014/10/19
 * - added subList method
 * @version 2014/10/10
 * - removed usage of __foreach macro
 * 2014/07/09
 * - changed checkVectorIndex range checking function into a private member
 *   function to avoid unused-function errors on some newer compilers
 * 2014/04/27
 * - fixed bug in addAll method that was not returning reference properly.
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _vector_h
#define _vector_h

#include <algorithm>
#include <initializer_list>
#include <iostream>
#include <iterator>
#include <sstream>
#include <string>
#include <vector>
#include <deque>
#include <type_traits>
#include <functional>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * This class stores an ordered list of values similar to an array.
 * It supports traditional array selection using square brackets, but
 * also supports inserting and deleting elements.  It is similar in
 * function to the STL <code>vector</code> type, but is simpler both
 * to use and to implement.
 */
template <typename ValueType>
class Vector {
public:
    /**
     * Initializes a new empty vector.
     * @bigoh O(1)
     */
    Vector() = default;

    /**
     * Initializes a new vector, creating an array with <code>n</code>
     * elements, each of which is initialized to <code>value</code>.
     * If <code>value</code> is missing, the elements are initialized
     * to the default value for the type.
     * @bigoh O(N)
     */
    explicit Vector(int n, ValueType value = ValueType());

    /**
     * Uses an initializer list to set up the vector.
     * @bigoh O(N)
     */
    Vector(std::initializer_list<ValueType> list);

    /**
     * Frees any heap storage allocated by this vector.
     * @bigoh O(1)
     */
    virtual ~Vector() = default;

    /**
     * Adds a new value to the end of this vector.
     * @bigoh O(1)
     */
    void add(const ValueType& value);

    /**
     * Adds all elements of the given other vector to this vector.
     * Returns a reference to this vector.
     * Identical in behavior to the += operator.
     * @bigoh O(N)
     */
    Vector<ValueType>& addAll(const Vector<ValueType>& v);

    /**
     * Returns the element at index (size - 1) in this vector (without removing it).
     * @throw ErrorException if vector is empty
     * @bigoh O(1)
     */
    ValueType& back();

    /**
     * Returns the element at index (size - 1) in this vector (without removing it).
     * @throw ErrorException if vector is empty
     * @bigoh O(1)
     */
    const ValueType& back() const;

    /**
     * Removes all elements from this vector.
     * @bigoh O(1)
     */
    void clear();

    /**
     * Returns true if the vector contains the given value.
     * The ValueType must have an == operator to use this method.
     * @bigoh O(N)
     */
    bool contains(const ValueType& value) const;

    /**
     * Guarantees that the vector's internal array is at least the given length.
     * If necessary, resizes the array to be the given length or larger.
     * @bigoh O(N)
     */
    void ensureCapacity(int cap);

    /**
     * Compares two vectors for equality.
     * Returns <code>true</code> if this vector contains exactly the same
     * values as the given other vector.
     * Identical in behavior to the == operator.
     * @bigoh O(N)
     */
    bool equals(const Vector<ValueType>& v) const;

    /**
     * Returns the element at index 0 in this vector (without removing it).
     * @throw ErrorExceptoin if vector is empty
     * @bigoh O(1)
     */
    ValueType& front();

    /**
     * Returns the element at index 0 in this vector (without removing it).
     * @throw ErrorExceptoin if vector is empty
     * @bigoh O(1)
     */
    const ValueType& front() const;

    /**
     * Returns the element at the specified index in this vector.
     * Similar in behavior to the [] operator.
     * @throw ErrorException if the index is not in the array range
     * @bigoh O(1)
     */
    const ValueType& get(int index) const;

    /**
     * Returns the index of the first occurrence of the given value.
     * If the value is not found in the vector, returns -1.
     * The ValueType must have an == operator to use this method.
     * @bigoh O(N)
     */
    int indexOf(const ValueType& value) const;

    /**
     * Inserts the element into this vector before the specified index.
     * All subsequent elements are shifted one position to the right.
     * @throw ErrorException if the index is not in the array range from 0
     * up to and including the length of the vector.
     * @bigoh O(N)
     */
    void insert(int index, const ValueType& value);

    /**
     * Returns <code>true</code> if this vector contains no elements.
     * @bigoh O(1)
     */
    bool isEmpty() const;

    /**
     * Returns the index of the last occurrence of the given value.
     * If the value is not found in the vector, returns -1.
     * The ValueType must have an == operator to use this method.
     * @bigoh O(N)
     */
    int lastIndexOf(const ValueType& value) const;

    /**
     * Calls the specified function on each element of the vector in
     * ascending index order.
     * @bigoh O(N)
     */
    void mapAll(std::function<void (const ValueType&)> fn) const;

    /**
     * Removes and returns the first value of this vector.
     * Equivalent to removeFront.
     * @throw ErrorException if the vector is empty
     * @bigoh O(N)
     */
    ValueType pop_front();

    /**
     * Removes and returns the last value of this vector.
     * Equivalent to removeBack.
     * @throw ErrorException if the vector is empty
     * @bigoh O(1)
     */
    ValueType pop_back();

    /**
     * Adds a new value to the end of this vector.
     * This method is a synonym of the add method that is provided to
     * ensure compatibility with the STL <code>vector</code> class.
     * @bigoh O(1)
     */
    void push_back(const ValueType& value);

    /**
     * Adds a new value to the start of this vector.
     * This method is equivalent to calling insert(0, value) and is provided to
     * improve compatibility with the STL <code>vector</code> class.
     * @bigoh O(N)
     */
    void push_front(const ValueType& value);

    /**
     * Removes the element at the specified index from this vector.
     * All subsequent elements are shifted one position to the left.
     * @throw ErrorException if the index is not in the array range
     * @bigoh O(N)
     */
    void remove(int index);

    /**
     * Removes and returns the element at index 0 in this vector.
     * @throw ErrorException if the vector is empty
     * @bigoh O(N)
     */
    ValueType removeFront();

    /**
     * Removes and returns the element at index (size - 1) in this vector.
     * @throw ErrorException if the vector is empty
     * @bigoh O(1)
     */
    ValueType removeBack();

    /**
     * Removes the first occurrence of the element value from this vector.
     * All subsequent elements are shifted one position to the left.
     * If the vector does not contain the given value, has no effect.
     * The ValueType must have an == operator to use this method.
     * @bigoh O(N)
     */
    void removeValue(const ValueType& value);

    /**
     * Reverses the order of the elements in this vector.
     * For example, if vector stores {1, 3, 4, 9}, changes it to store {9, 4, 3, 1}.
     * @bigoh O(N)
     */
    void reverse();

    /**
     * Replaces the element at the specified index in this vector with
     * a new value.  The previous value at that index is overwritten.
     * Similar in behavior to the [] operator.
     * @throw ErrorException if the index is not in the array range
     * @bigoh O(1)
     */
    void set(int index, const ValueType& value);
    
    /**
     * Returns the number of elements in this vector.
     * @bigoh O(1)
     */
    int size() const;

    /**
     * Rearranges the order of the elements in this vector into a random order.
     * @bigoh O(N)
     */
    void shuffle();

    /**
     * Rearranges the order of the elements in this vector into sorted order.
     * For example, if vector stores {9, 1, 4, 3}, changes it to store {1, 3, 4, 9}.
     * The ValueType must have an operator < to call this method.
     * @bigoh O(N log N)
     */
    void sort();

    /**
     * Returns a new vector containing the given subset range of elements
     * from this vector. The new vector is a deep copy, not linked to this one.
     * @throw ErrorException if the range (start .. start + length) is not
     *        within the bounds of this vector, or if length is negative
     * @bigoh O(N)
     */
    Vector<ValueType> subList(int start, int length) const;

    /**
     * Returns a new vector containing the elements from the start position
     * to the end of the vector.
     *
     * @throw ErrorException if start > size()
     * @bigoh O(N)
     */
    Vector<ValueType> subList(int start) const;

    /**
     * Converts the vector to a printable string representation
     * such as "{10, 20, 30, 40}".
     * @bigoh O(N)
     */
    std::string toString() const;

    /**
     * Overloads <code>[]</code> to select elements from this vector.
     * This extension enables the use of traditional array notation to
     * get or set individual elements.
     * @throw ErrorException if the index is not in the array range
     * @bigoh O(1)
     */
    ValueType& operator [](int index);

    /**
     * Overloads <code>[]</code> to select elements from this vector.
     * This extension enables the use of traditional array notation to
     * get or set individual elements.
     * @throw ErrorException if the index is not in the array range
     * @bigoh O(1)
     */
    const ValueType& operator [](int index) const;

    /**
     * Concatenates two vectors and returns the result.
     * @bigoh O(N)
     */
    Vector operator +(const Vector& v2) const;

    /**
     * Produces a vector formed by appending the given element to this vector.
     * @bigoh O(N)
     */
    Vector operator +(const ValueType& elem) const;

    /**
     * Adds all of the elements from <code>v2</code> to the end of this vector.
     * @bigoh O(N)
     */
    Vector& operator +=(const Vector& v2);

    /**
     * Adds the single specified value) to the end of the vector.
     * @bigoh O(1)
     */
    Vector& operator +=(const ValueType& value);


    /**
     * Compares two vectors for equality.
     * The ValueType must have an == operator.
     * @bigoh O(N)
     */
    bool operator ==(const Vector& v2) const;

    /**
     * Compares two vectors for inequality.
     * The ValueType must have a != operator.
     * @bigoh O(N)
     */
    bool operator !=(const Vector& v2) const;

    /**
     * Relational operators to compare two vectors.
     * Each element is compared pairwise to the corresponding element at the
     * same index in the other vector; for example, we first check the values
     * at index 0, then 1, and so on.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(N)
     */
    bool operator <(const Vector& v2) const;

    /**
     * Relational operators to compare two vectors.
     * Each element is compared pairwise to the corresponding element at the
     * same index in the other vector; for example, we first check the values
     * at index 0, then 1, and so on.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(N)
     */
    bool operator <=(const Vector& v2) const;

    /**
     * Relational operators to compare two vectors.
     * Each element is compared pairwise to the corresponding element at the
     * same index in the other vector; for example, we first check the values
     * at index 0, then 1, and so on.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(N)
     */
    bool operator >(const Vector& v2) const;

    /**
     * Relational operators to compare two vectors.
     * Each element is compared pairwise to the corresponding element at the
     * same index in the other vector; for example, we first check the values
     * at index 0, then 1, and so on.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(N)
     */
    bool operator >=(const Vector& v2) const;

    /*
     * Additional Vector operations
     * ----------------------------
     * In addition to the methods listed in this interface, the Vector
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement or STL iterators
     *
     * The iteration forms process the Vector in index order.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    /*
     * Implementation notes: Vector data structure
     * -------------------------------------------
     * The elements are stored in a std::vector, the regular C++ library
     * type representing a sequence of elements. We wrap std::vector because
     * it has no runtime safety checks, something that's tricky to get used
     * to when you're first learning to use these types.
     *
     * There's an edge case in the C++ libraries where std::vector<bool> doesn't
     * work as you might think it does. This is widely regarded as a mistake
     * in the language design and there's been a proposal to fix it for many
     * years now. In the interim, we get around this by falling back on the
     * std::deque type in the event that the client wants to make a
     * Vector<bool>
     */
    using ContainerType = typename std::conditional<std::is_same<ValueType, bool>::value,
                                                    std::deque<bool>,
                                                    std::vector<ValueType>>::type;

    /* Instance variables */
    ContainerType _elements;
    stanfordcpplib::collections::VersionTracker _version;

    /* Private methods */

    /*
     * Throws an ErrorException if the given index is not within the range of
     * [min..max] inclusive.
     * This is a consolidated error handler for all various Vector members that
     * accept index parameters.
     * The prefix parameter represents a text string to place at the start of
     * the error message, generally to help indicate which member threw the error.
     *
     * We make prefix a const char* rather than a std::string to avoid having to
     * construct and then destroy the prefix with each call.
     */
    void checkIndex(int index, int min, int max, const char* prefix) const;

    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

public:
    /**
     * Adds an element to the vector passed as the left-hand operatand.
     * This form makes it easier to initialize vectors in old versions of C++.
     * @bigoh O(1)
     */
    Vector& operator ,(const ValueType& value);

    using iterator = stanfordcpplib::collections::CheckedIterator<typename ContainerType::iterator>;
    using const_iterator = stanfordcpplib::collections::CheckedIterator<typename ContainerType::const_iterator>;

    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;

    /* Updates the internal version count. Only our libraries need this, and they only
     * need it in rare cases where an operation that's semantically mutating but bitwise
     * non-mutating occurs.
     */
    void updateVersion();
};

/* Implementation section */

template <typename ValueType>
Vector<ValueType>::Vector(int n, ValueType value) {
    if (n < 0) error("Cannot create a Vector with a negative number of elements.");
    _elements.assign(n, value);
}

template <typename ValueType>
Vector<ValueType>::Vector(std::initializer_list<ValueType> list)
        : _elements(list) {
}

/*
 * Implementation notes: Vector methods
 * ------------------------------------
 * The basic Vector methods are straightforward and should require
 * no detailed documentation.
 */
template <typename ValueType>
void Vector<ValueType>::add(const ValueType& value) {
    insert(size(), value);
}

template <typename ValueType>
Vector<ValueType>& Vector<ValueType>::addAll(const Vector<ValueType>& v) {
    for (const ValueType& value : v) {
        add(value);
    }
    return *this;   // BUGFIX 2014/04/27
}

template <typename ValueType>
ValueType& Vector<ValueType>::back() {
    return const_cast<ValueType&>(static_cast<const Vector &>(*this).back());
}

template <typename ValueType>
const ValueType& Vector<ValueType>::back() const {
    if (isEmpty()) {
        error("Vector::back: vector is empty");
    }
    return _elements.back();
}

template <typename ValueType>
void Vector<ValueType>::clear() {
    _elements.clear();
    _version.update();
}

template <typename ValueType>
bool Vector<ValueType>::contains(const ValueType& value) const {
    return indexOf(value) >= 0;
}

template <typename ValueType>
bool Vector<ValueType>::equals(const Vector<ValueType>& v) const {
    return stanfordcpplib::collections::equals(*this, v);
}

template <typename ValueType>
ValueType& Vector<ValueType>::front() {
    return const_cast<ValueType&>(static_cast<const Vector &>(*this).front());
}

template <typename ValueType>
const ValueType& Vector<ValueType>::front() const {
    if (isEmpty()) {
        error("Vector::front: vector is empty");
    }
    return _elements.front();
}

template <typename ValueType>
const ValueType& Vector<ValueType>::get(int index) const {
    checkIndex(index, 0, size()-1, "get");
    return _elements[index];
}

template <typename ValueType>
int Vector<ValueType>::indexOf(const ValueType& value) const {
    auto result = std::find(_elements.begin(), _elements.end(), value);
    if (result == _elements.end()) return -1;
    return result - _elements.begin();
}

template <typename ValueType>
void Vector<ValueType>::insert(int index, const ValueType& value) {
    checkIndex(index, 0, size(), "insert");
    _elements.insert(_elements.begin() + index, value);
    _version.update();
}

template <typename ValueType>
bool Vector<ValueType>::isEmpty() const {
    return _elements.empty();
}

template <typename ValueType>
int Vector<ValueType>::lastIndexOf(const ValueType& value) const {
    auto result = std::find(_elements.rbegin(), _elements.rend(), value);
    if (result == _elements.rend()) return -1;

    /* These iterators are going in the reverse direction, and so the index they give is the number of
     * steps from the end of the range, not from the beginning. Reverse this before returning the
     * value.
     */
    return (size() - 1) - (result - _elements.rbegin());
}

/*
 * Implementation notes: mapAll
 * ----------------------------
 * The various versions of the mapAll function apply the function or
 * function object to each element in ascending index order.
 */
template <typename ValueType>
void Vector<ValueType>::mapAll(std::function<void (const ValueType&)> fn) const {
    for (const auto& elem: _elements) {
        fn(elem);
    }
}

template <typename ValueType>
ValueType Vector<ValueType>::pop_back() {
    if (isEmpty()) {
        error("Vector::pop_back: vector is empty");
    }
    auto result = _elements.back();
    _elements.pop_back();
    _version.update();
    return result;
}

template <typename ValueType>
ValueType Vector<ValueType>::pop_front() {
    if (isEmpty()) {
        error("Vector::pop_front: vector is empty");
    }
    auto result = _elements.front();
    _elements.erase(_elements.begin());
    _version.update();
    return result;
}

template <typename ValueType>
void Vector<ValueType>::push_back(const ValueType& value) {
    insert(size(), value);
}

template <typename ValueType>
void Vector<ValueType>::push_front(const ValueType& value) {
    insert(0, value);
}

template <typename ValueType>
void Vector<ValueType>::remove(int index) {
    checkIndex(index, 0, size() - 1, "remove");
    _elements.erase(_elements.begin() + index);
    _version.update();
}

template <typename ValueType>
ValueType Vector<ValueType>::removeBack() {
    return pop_back();
}

template <typename ValueType>
ValueType Vector<ValueType>::removeFront() {
    return pop_front();
}

template <typename ValueType>
void Vector<ValueType>::removeValue(const ValueType& value) {
    int index = indexOf(value);
    if (index >= 0) {
        remove(index);
    }
}

template <typename ValueType>
void Vector<ValueType>::reverse() {
    std::reverse(begin(), end());
}

template <typename ValueType>
void Vector<ValueType>::set(int index, const ValueType& value) {
    checkIndex(index, 0, size()-1, "set");
    _elements[index] = value;
}

template <typename ValueType>
int Vector<ValueType>::size() const {
    return _elements.size();
}

template <typename ValueType>
void Vector<ValueType>::shuffle() {
    for (int i = 0; i < size() - 1; i++) {
        std::swap(_elements[i], _elements[randomInteger(i, size() - 1)]);
    }
}

template <typename ValueType>
void Vector<ValueType>::sort() {
    std::sort(begin(), end());
}

template <typename ValueType>
Vector<ValueType> Vector<ValueType>::subList(int start, int length) const {
    checkIndex(start, 0, size(), "subList");
    checkIndex(start + length, 0, size(), "subList");
    if (length < 0) {
        error("Vector::subList: length cannot be negative");
    }
    Vector<ValueType> result;
    for (int i = start; i < start + length; i++) {
        result.add(get(i));
    }
    return result;
}

template <typename ValueType>
Vector<ValueType> Vector<ValueType>::subList(int start) const {
    return subList(start, size() - start);
}

template <typename ValueType>
std::string Vector<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

/*
 * Implementation notes: Vector selection
 * --------------------------------------
 * The following code implements traditional array selection using
 * square brackets for the index.
 */
template <typename ValueType>
ValueType& Vector<ValueType>::operator [](int index) {
    return const_cast<ValueType&>(static_cast<const Vector &>(*this)[index]);
}
template <typename ValueType>
const ValueType& Vector<ValueType>::operator [](int index) const {
    checkIndex(index, 0, size()-1, "operator []");
    return _elements[index];
}

template <typename ValueType>
Vector<ValueType> Vector<ValueType>::operator +(const Vector& v2) const {
    Vector<ValueType> result = *this;
    return result.addAll(v2);
}

template <typename ValueType>
Vector<ValueType> Vector<ValueType>::operator +(const ValueType& elem) const {
    Vector<ValueType> result = *this;
    return result += elem;
}

template <typename ValueType>
Vector<ValueType>& Vector<ValueType>::operator +=(const Vector& v2) {
    return addAll(v2);
}

template <typename ValueType>
Vector<ValueType>& Vector<ValueType>::operator +=(const ValueType& value) {
    add(value);
    return *this;
}

template <typename ValueType>
bool Vector<ValueType>::operator ==(const Vector& v2) const {
    return equals(v2);
}

template <typename ValueType>
bool Vector<ValueType>::operator !=(const Vector& v2) const {
    return !equals(v2);
}

template <typename ValueType>
bool Vector<ValueType>::operator <(const Vector& v2) const {
    return stanfordcpplib::collections::compare(*this, v2) < 0;
}

template <typename ValueType>
bool Vector<ValueType>::operator <=(const Vector& v2) const {
    return stanfordcpplib::collections::compare(*this, v2) <= 0;
}

template <typename ValueType>
bool Vector<ValueType>::operator >(const Vector& v2) const {
    return stanfordcpplib::collections::compare(*this, v2) > 0;
}

template <typename ValueType>
bool Vector<ValueType>::operator >=(const Vector& v2) const {
    return stanfordcpplib::collections::compare(*this, v2) >= 0;
}

template <typename ValueType>
void Vector<ValueType>::checkIndex(int index, int min, int max, const char* prefix) const {
    if (index < min || index > max) {
        std::ostringstream out;
        out << "Vector::" << prefix << ": index of " << index
            << " is outside of valid range ";
        if (isEmpty()) {
            out << " (empty vector)";
        } else {
            out << "[";
            if (min < max) {
                out << min << ".." << max;
            } else if (min == max) {
                out << min;
            } // else min > max, no range, empty vector
            out << "]";
        }
        error(out.str());
    }
}

/*
 * Implementation notes: The , operator
 * ------------------------------------
 * The comma operator works adding the right operand to the vector and
 * then returning the vector by reference so that it is set for the next
 * value in the chain.
 */
template <typename ValueType>
Vector<ValueType>& Vector<ValueType>::operator ,(const ValueType& value) {
    add(value);
    return *this;
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Vector<ValueType>& vec) {
    return stanfordcpplib::collections::writeCollection(os, vec);
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Vector<ValueType>& vec) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, vec, element, /* descriptor */ "Vector::operator >>");
}


/*
 * Implementation notes: Iterator support
 * --------------------------------------
 * We used the checked iterator type, which requires us to provide information
 * about the full range of values available.
 */
template <typename ValueType>
typename Vector<ValueType>::iterator Vector<ValueType>::begin() {
    return { &_version, _elements.begin(), _elements };
}
template <typename ValueType>
typename Vector<ValueType>::const_iterator Vector<ValueType>::begin() const {
    return { &_version, _elements.begin(), _elements };
}
template <typename ValueType>
typename Vector<ValueType>::iterator Vector<ValueType>::end() {
    return { &_version, _elements.end(), _elements };
}
template <typename ValueType>
typename Vector<ValueType>::const_iterator Vector<ValueType>::end() const {
    return { &_version, _elements.end(), _elements };
}

template <typename ValueType>
void Vector<ValueType>::updateVersion() {
    _version.update();
}

/*
 * Template hash function for vectors.
 * Requires the element type in the Vector to have a hashCode function.
 */
template <typename ValueType>
int hashCode(const Vector<ValueType>& vec) {
    return stanfordcpplib::collections::hashCodeCollection(vec);
}

/*
 * Function: randomElement
 * Usage: element = randomElement(v);
 * ----------------------------------
 * Returns a randomly chosen element of the given vector.
 * Throws an error if the vector is empty.
 */
template <typename T>
const T& randomElement(const Vector<T>& vec) {
    return stanfordcpplib::collections::randomElementIndexed(vec);
}

/*
 * Randomly rearranges the elements of the given vector.
 */
template <typename T>
void shuffle(Vector<T>& v) {
    v.shuffle();
}

#endif // _vector_h

/////////////////////// END code extracted from StanfordCPPLib/collections/vector.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/strlib.h ///////////////////////
/*
 * File: strlib.h
 * --------------
 * This file exports several useful string functions that are not
 * included in the C++ string library.
 * 
 * @version 2018/11/14
 * - added std::to_string for bool, char, pointer, and generic template type T
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2018/09/02
 * - added padLeft, padRight
 * @version 2016/11/09
 * - added boolalpha to writeGenericValue (improves bool printing in
 *   collection toString output)
 * @version 2016/10/30
 * - added overloads that take type char instead of string:
 *   stringContains, stringIndexOf, stringJoin, stringLastIndexOf, stringReplace,
 *   stringSplit, toLowerCase, toUpperCase
 * @version 2016/10/26
 * - bug fix for stringLastIndexOf default index arg
 * @version 2016/10/13
 * - modified writeGenericValue, writeQuotedString to return ostream
 * @version 2016/08/03
 * - modified readGenericValue not to throw error() on parse failures
 *   (needed to support idiomatic silent-failing >> operators)
 * @version 2015/10/26
 * - added charToInteger/integerToChar functions
 * @version 2015/08/02
 * - added htmlEncode/Decode functions (not 100% perfect but works for common cases)
 * @version 2014/10/19
 * - alphabetized functions
 * - added several 'inPlace' variants of existing functions that return strings
 * @version 2014/10/08
 * - removed dependency on 'using namespace' statement
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _strlib_h
#define _strlib_h

#include <iostream>
#include <sstream>
#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * Returns the string "true" if b is true, or "false" if b is false.
 */
std::string boolToString(bool b);

/**
 * Returns the string "true" if b is nonzero, or "false" if b is 0.
 */
std::string boolToString(int b);

/**
 * Returns an integer equivalent of the given numeric character.
 * For example, charToInteger('3') returns the int 3.
 * If the character is not '0' through '9', throws an error.
 */
int charToInteger(char c);

/**
 * Returns a single-character string containing the given character.
 * For example, charToString('Q') returns the string "Q".
 */
std::string charToString(char c);

/**
 * Converts a floating-point number into the corresponding string form.
 * For example, calling <code>doubleToString(23.45)</code> returns
 * the string <code>"23.45"</code>.
 * Equivalent to realToString.
 */
std::string doubleToString(double d);

/**
 * Returns <code>true</code> if the string <code>str</code> ends with
 * the specified suffix.
 */
bool endsWith(const std::string& str, const std::string& suffix);

/**
 * Returns <code>true</code> if the string <code>str</code> ends with
 * the specified character.
 */
bool endsWith(const std::string& str, char suffix);

/**
 * Returns <code>true</code> if <code>s1</code> and <code>s2</code> are
 * equal discounting differences in case.
 */
bool equalsIgnoreCase(const std::string& s1, const std::string& s2);

/**
 * Converts the given string from an HTML-encoded version to its decoded
 * equivalent; the opposite of htmlEncode. Any escaped HTML character entities
 * will be replaced by their unescaped equivalents.
 * For example, <code>htmlEncode("&lt;p class=&quot;abc&quot;&gt;I love you &amp; me&lt;/p&gt;")
 * returns "<p class=\"abc\">I love you & me</p>".
 */
std::string htmlDecode(const std::string& s);

/**
 * Converts the given string into an HTML-encoded equivalent version, with
 * any relevant HTML character entities replaced by escaped equivalents.
 * For example, <code>htmlEncode("<p class=\"abc\">I love you & me</p>") returns
 * "&lt;p class=&quot;abc&quot;&gt;I love you &amp; me&lt;/p&gt;".
 */
std::string htmlEncode(const std::string& s);

/**
 * Converts an integer into the corresponding numeric character.
 * For example, calling <code>integerToChar(3)</code> returns
 * the char <code>'3'</code>.
 * @throw ErrorException if the given integer is not a single-digit number from 0-9 inclusive
 */
char integerToChar(int n);

/**
 * Converts an integer into the corresponding string of digits.
 * For example, calling <code>integerToString(123)</code> returns
 * the string <code>"123"</code>.
 */
std::string integerToString(int n, int radix = 10);

/**
 * Converts an integer into the corresponding string of digits.
 * For example, calling <code>longToString(123)</code> returns
 * the string <code>"123"</code>.
 */
std::string longToString(long n, int radix = 10);

/**
 * Inserts spaces at the start of the given string until it is at least
 * the given length.
 * You can optionally pass a fill character (other than space) as a third parameter.
 *
 * Note that if you are printing strings and want your output to line up
 * at a given number of characters, you may be better served using the built-in
 * C++ ostream manipulators such as setw(int), left, and right, as defined in
 * the iomanip library.
 */
std::string padLeft(const std::string& s, int length, char fill = ' ');

/**
 * Inserts spaces at the end of the given string until it is at least
 * the given length.
 * You can optionally pass a fill character (other than space) as a third parameter.
 *
 * Note that if you are printing strings and want your output to line up
 * at a given number of characters, you may be better served using the built-in
 * C++ ostream manipulators such as setw(int), left, and right, as defined in
 * the iomanip library.
 */
std::string padRight(const std::string& s, int length);

/**
 * Returns a hexadecimal string for the given pointer, such as "0x3f0427b".
 * Returns "nullptr" if p is a null pointer.
 */
std::string pointerToString(void* p);

/**
 * Converts a floating-point number into the corresponding string form.
 * For example, calling <code>realToString(23.45)</code> returns
 * the string <code>"23.45"</code>.
 */
std::string realToString(double d);

/**
 * Returns <code>true</code> if the string <code>str</code> starts with
 * the specified prefix.
 */
bool startsWith(const std::string& str, char prefix);

/**
 * Returns <code>true</code> if the string <code>str</code> starts with
 * the specified character.
 */
bool startsWith(const std::string& str, const std::string& prefix);

/**
 * Returns true if the given character occurs somewhere in s.
 */
bool stringContains(const std::string& s, char ch);

/**
 * Returns true if the given substring occurs somewhere in s.
 */
bool stringContains(const std::string& s, const std::string& substring);

/**
 * Returns the index of the start of the first occurrence of the given character
 * in s, if it occurs in s.  If it does not occur, returns -1.
 * This function is very similar to string.find, but find returns string::npos
 * when the string is not found.
 */
int stringIndexOf(const std::string& s, char ch, int startIndex = 0);

/**
 * Returns the index of the start of the first occurrence of the given substring
 * in s, if it occurs in s.  If it does not occur, returns -1.
 * This function is very similar to string.find, but find returns string::npos
 * when the string is not found.
 */
int stringIndexOf(const std::string& s, const std::string& substring, int startIndex = 0);

/**
 * Returns true if the given string is either "true" or "false".
 */
bool stringIsBool(const std::string& str);

/**
 * Returns true if the given string could be converted to an real number
 * successfully by the stringToReal function, which will be true if
 * the string has the format of a real number such as "3.14" or "-46".
 * Equivalent to stringIsReal.
 */
bool stringIsDouble(const std::string& str);   // alias

/**
 * Returns true if the given string could be converted to an integer
 * successfully by the stringToInteger function, which will be true if
 * the string has the format of an integer such as "1234" or "-8".
 * Optionally accepts a radix (base) parameter if base-10 is not desired.
 */
bool stringIsInteger(const std::string& str, int radix = 10);

/**
 * Returns true if the given string could be converted to a long
 * successfully by the stringToLong function, which will be true if
 * the string has the format of an integer such as "1234" or "-8".
 * Optionally accepts a radix (base) parameter if base-10 is not desired.
 */
bool stringIsLong(const std::string& str, int radix = 10);

/**
 * Returns true if the given string could be converted to an real number
 * successfully by the stringToReal function, which will be true if
 * the string has the format of a real number such as "3.14" or "-46".
 */
bool stringIsReal(const std::string& str);

/**
 * Combines the elements of the given vector into a single string,
 * with the given delimiter separating neighboring elements, and returns it.
 * For example, joining the elements of the vector
 * {"Hi", "there", "", "Jim"} with the delimiter '?' returns "Hi?there??Jim".
 */
std::string stringJoin(const Vector<std::string>& v, char delimiter = '\n');

/**
 * Combines the elements of the given STL vector into a single string,
 * with the given delimiter separating neighboring elements, and returns it.
 * For example, joining the elements of the vector
 * {"Hi", "there", "", "Jim"} with the delimiter "??" returns "Hi??there????Jim".
 */
std::string stringJoin(const Vector<std::string>& v, const std::string& delimiter = "\n");

/**
 * Returns the index of the start of the last occurrence of the given character
 * in s, if it occurs in s.  If it does not occur, returns -1.
 * This function is very similar to string.rfind, but rfind returns string::npos
 * when the string is not found.
 */
int stringLastIndexOf(const std::string& s, char ch, int startIndex = (int) std::string::npos);

/**
 * Returns the index of the start of the last occurrence of the given substring
 * in s, if it occurs in s.  If it does not occur, returns -1.
 * This function is very similar to string.rfind, but rfind returns string::npos
 * when the string is not found.
 */
int stringLastIndexOf(const std::string& s, const std::string& substring, int startIndex = (int) std::string::npos);

/**
 * Returns a new string formed by replacing any occurrences of the given 'old'
 * character with the given replacement character in 'str'.
 * Note that this is NOT a regular expression replacement; it looks for the
 * 'old' string literally.  If you want regular expressions, see regexpr.h.
 * The 'inPlace' variant modifies an existing string rather than returning a new one,
 * and returns the number of occurrences of 'old' were replaced.
 */
std::string stringReplace(const std::string& str, char old, char replacement, int limit = -1);

/**
 * Returns a new string formed by replacing any occurrences of the given 'old'
 * text with the given replacement text in 'str'.
 * Note that this is NOT a regular expression replacement; it looks for the
 * 'old' string literally.  If you want regular expressions, see regexpr.h.
 * The 'inPlace' variant modifies an existing string rather than returning a new one,
 * and returns the number of occurrences of 'old' were replaced.
 */
std::string stringReplace(const std::string& str, const std::string& old, const std::string& replacement, int limit = -1);

/**
 * A variant of stringReplace, except that it accepts the string as a reference
 * and modifies it in-place rather than returning a new string.
 */
int stringReplaceInPlace(std::string& str, char old, char replacement, int limit = -1);

/**
 * A variant of stringReplace, except that it accepts the string as a reference
 * and modifies it in-place rather than returning a new string.
 */
int stringReplaceInPlace(std::string& str, const std::string& old, const std::string& replacement, int limit = -1);

/**
 * Returns a vector whose elements are strings formed by splitting the
 * given string 'str' by the given separator character.
 * For example, splitting "Hi there  Jim!" on " " returns
 * {"Hi", "there", "", "Jim!"}.
 */
Vector<std::string> stringSplit(const std::string& str, char delimiter, int limit = -1);

/**
 * Returns a vector whose elements are strings formed by splitting the
 * given string 'str' by the given separator text.
 * For example, splitting "Hi there  Jim!" on " " returns
 * {"Hi", "there", "", "Jim!"}.
 */
Vector<std::string> stringSplit(const std::string& str, const std::string& delimiter, int limit = -1);

/**
 * If str is "true", returns the bool value true.
 * If str is "false", returns the bool value false.
 * @throw ErrorException if str is any other value than "true" or "false"
 */
bool stringToBool(const std::string& str);

/**
 * Converts a single-character string into its corresponding char value.
 * For example, stringToChar("hello") returns the char 'h'.
 * @throw ErrorException if the given string does not contain exactly 1 character
 */
char stringToChar(const std::string& str);

/**
 * Converts a string representing a real number into its corresponding
 * value.
 * Equivalent to stringToReal.
 * @throw ErrorException if the string is not a legal floating-point number
 *        or contains extraneous characters other than whitespace
 */
double stringToDouble(const std::string& str);   // alias

/**
 * Converts a string of digits into an integer.
 * The function accepts an optional radix (base); for example,
 * stringToInteger("234", 16) assumes that the string is in base-16 and
 * returns 2*16*16 + 3*16 + 4 = 564.
 * @throw ErrorException if the string is not a legal integer or contains
 *        extraneous characters other than whitespace
 */
int stringToInteger(const std::string& str, int radix = 10);

/**
 * Converts a string of digits into a long.
 * The function accepts an optional radix (base); for example,
 * stringToLong("234", 16) assumes that the string is in base-16 and
 * returns 2*16*16 + 3*16 + 4 = 564.
 * @throw ErrorException if the string is not a legal long or contains
 *        extraneous characters other than whitespace
 */
long stringToLong(const std::string& str, int radix = 10);

/**
 * Converts a string representing a real number into its corresponding
 * value.
 * Equivalent to stringToDouble.
 * @throw ErrorException if the string is not a legal floating-point number or
 * contains extraneous characters other than whitespace
 */
double stringToReal(const std::string& str);

/**
 * Returns a new character in which the given uppercase character has been
 * converted into its lowercase equivalent.
 */
char toLowerCase(char ch);

/**
 * Returns a new string in which all uppercase characters have been converted
 * into their lowercase equivalents.
 */
std::string toLowerCase(const std::string& str);

/**
 * Modifies the given string in-place such that all uppercase characters have
 * been converted into their lowercase equivalents.
 */
void toLowerCaseInPlace(std::string& str);

/**
 * Returns a new character in which the given lowercase character has been
 * converted into its uppercase equivalent.
 */
char toUpperCase(char ch);

/**
 * Returns a new string in which all lowercase characters have been converted
 * into their uppercase equivalents.
 */
std::string toUpperCase(const std::string& str);

/**
 * Modifies the given string in-place such that all lowercase characters have
 * been converted into their uppercase equivalents.
 */
void toUpperCaseInPlace(std::string& str);

/**
 * Returns a new string after removing any whitespace characters
 * from the beginning and end of the argument.
 */
std::string trim(const std::string& str);

/**
 * Modifies the given string in-place where any whitespace characters
 * from the beginning and end of the argument are removed.
 */
void trimInPlace(std::string& str);

/**
 * Returns a new string after removing any whitespace characters
 * from the end of the argument.
 */
std::string trimEnd(const std::string& str);

/**
 * Modifies the given string in-place to remove any whitespace characters
 * from its end.
 */
void trimEndInPlace(std::string& str);

/**
 * Returns a new string after removing any whitespace characters
 * from the beginning of the argument.
 */
std::string trimStart(const std::string& str);

/**
 * Modifies the given string in-place to remove removing any whitespace characters
 * from the beginning of it.
 */
void trimStartInPlace(std::string& str);

/**
 * Returns a URL-decoded version of the given string, where any %xx character
 * codes are converted back to the equivalent characters.
 */
std::string urlDecode(const std::string& str);

/**
 * Modifies the given string in-place into a URL-decoded version of itself,
 * where any %xx character codes are converted back to the equivalent characters.
 */
void urlDecodeInPlace(std::string& str);

/**
 * Returns a URL-encoded version of the given string, where most non-
 * alphabetic characters are replaced by %xx character codes.
 */
std::string urlEncode(const std::string& str);

/**
 * Modifies the given string in-place into a URL-encoded version of itself,
 * where most non- alphabetic characters are replaced by %xx character codes.
 */
void urlEncodeInPlace(std::string& str);

// add to_string overloads for some common types missing from C++ standard
namespace std {
/**
 * String-to-bool conversion function.
 * If str is "true", returns the bool value true.
 * If str is "false", returns the bool value false.
 * @throw ErrorException if str is any other value than "true" or "false"
 */
bool stob(const std::string& str);

/**
 * String-to-char conversion function.
 * Converts a single-character string into its corresponding char value.
 * For example, stringToChar("hello") returns the char 'h'.
 * @throw ErrorException if the given string does not contain exactly 1 character
 */
char stoc(const std::string& str);

/**
 * Returns the string "true" if b is true, or "false" if b is false.
 */
std::string to_string(bool b);

/**
 * Returns a single-character string containing the given character.
 * For example, charToString('Q') returns the string "Q".
 */
std::string to_string(char c);

/**
 * Returns a hexadecimal string for the given pointer, such as "0x3f0427b".
 * Returns "nullptr" if p is a null pointer.
 */
std::string to_string(void* p);

/**
 * Generic to_string function for any type that has an operator <<.
 */
template <typename T>
std::string to_string(const T& value) {
    std::ostringstream out;
    out << value;   // if you get an error here, your type might not have a << operator
    return out.str();
}
} // namespace std

#endif // _strlib_h

/////////////////////// END code extracted from StanfordCPPLib/util/strlib.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/stringutils.h ///////////////////////
/*
 * File: stringutils.h
 * -------------------
 * This file contains declarations of utility functions related to strings.
 * Arguably some of this functionality could be moved into strlib.{h,cpp},
 * but it is mostly written to support autograders so it is placed here.
 * 
 * @author Marty Stepp
 * @version 2017/10/20
 * - changed string to const string& in all functions
 * @version 2016/11/09
 * - added trimToSize function
 * @since 2014/03/01
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _stringutils_h
#define _stringutils_h

#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * @private
 */
namespace stringutils {
int charsDifferent(const std::string& s1, const std::string& s2);
std::string collapseSpaces(const std::string& s);
Vector<std::string> explodeLines(const std::string& s);
int height(const std::string& s);
std::string implode(const Vector<std::string>& v, const std::string& delimiter = "\n");
std::string indent(const std::string& s, int spaces);

/*
 * Removes blank lines and collapses multiple spaces into one.
 * Used to facilitate approximate output matching.
 */
std::string makeSloppy(const std::string& s);
std::string removeBlankLines(const std::string& s);
std::string toLowerCase(const std::string& s);
std::string trimR(const std::string& s);
std::string trimToHeight(const std::string& s, int height, const std::string& suffix = "...");
std::string trimToSize(const std::string& s, int width, int height, const std::string& suffix = " ...");
std::string trimToWidth(const std::string& s, int width, const std::string& suffix = " ...");
std::string stripWhitespace(const std::string& s);
std::string truncate(const std::string& s, int length, const std::string& suffix = " ...");
std::string toPrintable(int ch);
int width(const std::string& s);
} // namespace stringutils

#endif // _stringutils_h

/////////////////////// END code extracted from StanfordCPPLib/util/stringutils.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/intrange.h ///////////////////////
/*
 * File: intrange.h
 * ----------------
 * This file exports the <code>IntRange</code> class, which represents an iterable
 * contiguous range of integers that can be processed using a for-each loop.
 * The range is not stored all in memory, so it does not require O(N) space.
 *
 * See intrange.cpp for the implementation of each member.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2018/08/25
 * - renamed from range.h to intrange.h
 * @version 2018/03/12
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _intrange_h
#define _intrange_h

#include <iostream>
#include <iterator>
#include <limits>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * An IntRange is an iterable contiguous range of integers.
 * It can be processed using a for-each loop.
 * The integers are not actually all stored in this object, so it does not
 * require O(N) memory usage.
 */
class IntRange {
private:
    /**
     * Internal iterator for looping over a range.
     */
    class IntRangeIterator : public std::iterator<std::random_access_iterator_tag, int> {
    private:
        const IntRange* r;
        int val;

    public:
        IntRangeIterator(const IntRange* r, bool end) {
            this->r = r;
            this->val = (end ? r->max() + 1 : r->min());
        }

        IntRangeIterator(const IntRangeIterator& itr)
            : r(itr.r),
              val(itr.val) {
            // empty
        }

        IntRangeIterator& operator ++() {
            val++;
            if (!r->contains(val)) {
                val = r->max() + 1;
            }
            return *this;
        }

        IntRangeIterator operator ++(int) {
            IntRangeIterator copy(*this);
            operator++();
            return copy;
        }

        IntRangeIterator& operator --() {
            val--;
            return *this;
        }

        IntRangeIterator operator --(int) {
            IntRangeIterator copy(*this);
            operator--();
            return copy;
        }

        bool operator ==(const IntRangeIterator& rhs) {
            return r == rhs.r && val == rhs.val;
        }

        bool operator !=(const IntRangeIterator& rhs) {
            return !(*this == rhs);
        }

        bool operator <(const IntRangeIterator& rhs) {
            if (r != rhs.r) {
                error("Range Iterator::operator <: Iterators are in different ranges");
            }
            return val < rhs.val;
        }

        bool operator <=(const IntRangeIterator& rhs) {
            if (r != rhs.r) {
                error("Range Iterator::operator <=: Iterators are in different ranges");
            }
            return val <= rhs.val;
        }

        bool operator >(const IntRangeIterator& rhs) {
            if (r != rhs.r) {
                error("Range Iterator::operator >: Iterators are in different ranges");
            }
            return val > rhs.val;
        }

        bool operator >=(const IntRangeIterator& rhs) {
            if (r != rhs.r) {
                error("Range Iterator::operator >=: Iterators are in different ranges");
            }
            return val >= rhs.val;
        }

        IntRangeIterator operator +(const int& rhs) {
            return IntRangeIterator(r, val + rhs);
        }

        IntRangeIterator operator +=(const int& rhs) {
            val += rhs;
            return *this;
        }

        IntRangeIterator operator -(const int& rhs) {
            return IntRangeIterator(r, val - rhs);
        }

        IntRangeIterator operator -=(const int& rhs) {
            val -= rhs;
            return *this;
        }

        int operator -(const IntRangeIterator& rhs) {
            if (r != rhs.r) {
                error("Range Iterator::operator -: Iterators are in different ranges");
            }
            return val - rhs.val;
        }

        int operator *() {
            return val;
        }

        int* operator ->() {
            return &val;
        }

        int operator [](int k) {
            return val + k;
        }
    };

    int _min;
    int _max;

    friend std::istream& operator >>(std::istream& input, IntRange& r);

public:
    /**
     * Constructs a range from 0 (inclusive) of the given length.
     * Its endpoints are [0 .. length-1].
     */
    IntRange(int length = 0);

    /**
     * Constructs a range from minValue to maxValue (inclusive).
     */
    IntRange(int minValue, int maxValue);

    /**
     * Returns an iterator over the elements of this range.
     */
    IntRangeIterator begin() const;

    /**
     * Returns true if the given integer is within the bounds of this range.
     */
    bool contains(int n) const;

    /**
     * Returns true if the given range is entirely contained within this range.
     */
    bool contains(const IntRange& r) const;

    /**
     * Returns true if this range contains no integers, meaning that its max
     * is less than its min.
     * Equivalent to isEmpty.
     */
    bool empty() const;

    IntRangeIterator end() const;

//    bool intersects(const Range& r) const;

    /**
     * Returns true if this range contains no integers, meaning that its max
     * is less than its min.
     * Equivalent to empty.
     */
    bool isEmpty() const;

    /**
     * Returns the number of integers in the range.
     * Equivalent to size.
     */
    int length() const;

    /**
     * Returns the maximum value in the range, inclusive.
     */
    int max() const;

    /**
     * Returns the minimum value in the range.
     */
    int min() const;

    /**
     * Returns the number of integers in the range.
     * Equivalent to length.
     */
    int size() const;

    /**
     * Returns a string representation of this range,
     * such as "[1 .. 10]".
     */
    std::string toString() const;
};

/**
 * Returns an integer hash code for this range.
 */
int hashCode(const IntRange& r);

/**
 * Convenience functions for constructing a range.
 * See Range constructor.
 */
IntRange range(int length = 0);
IntRange range(int min, int max);

/**
 * Relational operators for comparing ranges.
 * Ranges are ordered by their min values with ties broken by max values.
 */
bool operator <(const IntRange& r1, const IntRange& r2);
bool operator <=(const IntRange& r1, const IntRange& r2);
bool operator ==(const IntRange& r1, const IntRange& r2);
bool operator !=(const IntRange& r1, const IntRange& r2);
bool operator >(const IntRange& r1, const IntRange& r2);
bool operator >=(const IntRange& r1, const IntRange& r2);

/**
 * Writes the given range to the given output stream in its toString format.
 */
std::ostream& operator <<(std::ostream& out, const IntRange& r);

/**
 * Reads the given range to the given input stream in its toString format.
 */
std::istream& operator >>(std::istream& input, IntRange& r);


/////////////////////////////////////////////////////////////////////
// IntRange2D
/////////////////////////////////////////////////////////////////////

/**
 * An IntRange2D is an iterable contiguous 2-dimensional range of integers.
 * It can be processed using a for-each loop to emit the range as a series
 * of Point objects in y-major (default) or x-major order.
 * The points are not actually all stored in this object, so it does not
 * require O(WxH) memory usage.
 */
class IntRange2D {
private:
    /**
     * Internal iterator for looping over a 2D range.
     */
    class IntRange2DIterator : public std::iterator<std::input_iterator_tag, Point> {
    private:
        const IntRange2D* r;
        int x;
        int y;

    public:
        IntRange2DIterator(const IntRange2D* r, bool end) {
            this->r = r;
            if (end) {
                this->x = r->maxX() + 1;
                this->y = r->maxY() + 1;
            } else {
                this->x = r->minX();
                this->y = r->minY();
            }
        }

        IntRange2DIterator(const IntRange2DIterator& itr)
            : r(itr.r),
              x(itr.x),
              y(itr.y) {
            // empty
        }

        IntRange2DIterator& operator ++() {
            if (r->isYMajor()) {
                x++;
                if (x > r->maxX()) {
                    x = r->minX();
                    y++;
                }
            } else {
                y++;
                if (y > r->maxY()) {
                    y = r->minY();
                    x++;
                }
            }
            if (!r->contains(x, y)) {
                x = r->maxX() + 1;
                y = r->maxY() + 1;
            }
            return *this;
        }

        IntRange2DIterator operator ++(int) {
            IntRange2DIterator copy(*this);
            operator++();
            return copy;
        }

        IntRange2DIterator& operator --() {
            if (r->isYMajor()) {
                x--;
                if (x < r->minX()) {
                    x = r->maxX();
                    y--;
                }
            } else {
                y--;
                if (y < r->minY()) {
                    y = r->maxY();
                    x--;
                }
            }
            return *this;
        }

        IntRange2DIterator operator --(int) {
            IntRange2DIterator copy(*this);
            operator--();
            return copy;
        }

        bool operator ==(const IntRange2DIterator& rhs) const {
            return r == rhs.r && x == rhs.x && y == rhs.y;
        }

        bool operator !=(const IntRange2DIterator& rhs) const {
            return !(*this == rhs);
        }

        bool operator <(const IntRange2DIterator& rhs) const {
            if (r != rhs.r) {
                error("Range2D Iterator::operator <: Iterators are in different ranges");
            }
            return x < rhs.x || (x == rhs.x && y < rhs.y);
        }

        bool operator <=(const IntRange2DIterator& rhs) const {
            if (r != rhs.r) {
                error("Range2D Iterator::operator <=: Iterators are in different ranges");
            }
            return (*this < rhs) || (*this == rhs);
        }

        bool operator >(const IntRange2DIterator& rhs) const {
            if (r != rhs.r) {
                error("Range2D Iterator::operator >: Iterators are in different ranges");
            }
            return (rhs < *this);
        }

        bool operator >=(const IntRange2DIterator& rhs) const {
            if (r != rhs.r) {
                error("Range2D Iterator::operator >=: Iterators are in different ranges");
            }
            return (*this > rhs) || (*this == rhs);
        }

        Point operator *() const {
            return Point(x, y);
        }

        Point* operator ->() const {
            return new Point(x, y);
        }
    };

    int _minX;
    int _minY;
    int _maxX;
    int _maxY;
    bool _yMajor;

    friend std::istream& operator >>(std::istream& input, IntRange2D& r);

public:
    /**
     * Constructs a 2D range of the given width and height, default 0.
     * Its bounds will be [0,0 .. w-1,h-1] inclusive.
     * The yMajor parameter indicates whether the range will emit its members
     * in y-major (default) or x-major order.
     */
    IntRange2D(int width = 0, int height = 0, bool yMajor = true);

    /**
     * Constructs a 2D range between the given min/max locations, inclusive.
     * The yMajor parameter indicates whether the range will emit its members
     * in y-major (default) or x-major order.
     */
    IntRange2D(int minX, int minY, int maxX, int maxY, bool yMajor = true);

    /**
     * Returns an iterator over the elements of this 2D range.
     */
    IntRange2DIterator begin() const;

    /**
     * Returns true if the given x/y location is contained in this 2D range.
     */
    bool contains(int x, int y) const;

    /**
     * Returns true if the given 2D range is entirely contained in this 2D range.
     */
    bool contains(const IntRange2D& r) const;

    /**
     * Returns true if this range does not contain any integers in one dimension
     * or the other or both (if max X/Y is less than min X/Y).
     * Equivalent to isEmpty.
     */
    bool empty() const;

    /**
     * Returns an iterator at the end of the elements of this 2D range.
     */
    IntRange2DIterator end() const;

    /**
     * Returns the range of y-values in this 2D range.
     * For example, in the range [0,0 .. 4,7], the height is 8.
     */
    int height() const;

//    bool intersects(const Range2D& r) const;

    /**
     * Returns true if this range does not contain any integers in one dimension
     * or the other or both (if max X/Y is less than min X/Y).
     * Equivalent to empty.
     */
    bool isEmpty() const;

    /**
     * Returns true if this range should emit its integers in y-major order
     * as passed to the constructor (default true).
     */
    bool isYMajor() const;

    /**
     * Returns the maximum x-value in this 2D range.
     */
    int maxX() const;

    /**
     * Returns the maximum y-value in this 2D range.
     */
    int maxY() const;

    /**
     * Returns the minimum x-value in this 2D range.
     */
    int minX() const;

    /**
     * Returns the minimum y-value in this 2D range.
     */
    int minY() const;

    /**
     * Returns the total number of integers in this 2D range.
     * For example, in the range [0,0 .. 4,7], the size is 5x8 = 40.
     */
    int size() const;

    /**
     * Returns the range of x-values in this 2D range.
     * For example, in the range [0,0 .. 4,7], the height is 5.
     */
    int width() const;

    /**
     * Returns a string representation of this 2D range,
     * such as "[0,0 .. 4,7]".
     */
    std::string toString() const;
};

/**
 * Returns an integer hash code of this 2D range.
 */
int hashCode(const IntRange2D& r);

/**
 * Convenience function for constructing a 2D range.
 * See Range2D constructors.
 */
IntRange2D range2d(int width = 0, int height = 0, bool yMajor = false);

/**
 * Convenience function for constructing a 2D range.
 * See Range2D constructors.
 */
IntRange2D range2d(int minX, int minY, int maxX, int maxY, bool yMajor = false);

/**
 * Relational operators for comparing 2D ranges.
 * Ranges are ordered by their minX values, then minY, then maxX, then maxY.
 */
bool operator <(const IntRange2D& r1, const IntRange2D& r2);
bool operator <=(const IntRange2D& r1, const IntRange2D& r2);
bool operator ==(const IntRange2D& r1, const IntRange2D& r2);
bool operator !=(const IntRange2D& r1, const IntRange2D& r2);
bool operator >(const IntRange2D& r1, const IntRange2D& r2);
bool operator >=(const IntRange2D& r1, const IntRange2D& r2);

/**
 * Writes the given 2D range to the given output stream in its toString format.
 */
std::ostream& operator <<(std::ostream& out, const IntRange2D& r);

/**
 * Reads the given 2D range to the given input stream in its toString format.
 */
std::istream& operator >>(std::istream& input, IntRange2D& r);

#endif // _intrange_h

/////////////////////// END code extracted from StanfordCPPLib/util/intrange.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/io/filelib.h ///////////////////////
/*
 * File: filelib.h
 * ---------------
 * This file exports a standardized set of tools for working with
 * files.  The library offers at least some portability across the
 * file systems used in the three supported platforms: Mac OSX,
 * Windows, and Linux.  Directory and search paths are allowed to
 * contain separators in any of the supported styles, which usually
 * makes it possible to use the same code on different platforms.
 * 
 * @version 2018/10/23
 * - added getAbsolutePath
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2016/11/12
 * - added fileSize, readEntireStream
 * @version 2016/08/12
 * - added second overload of openFileDialog that accepts path parameter
 * @version 2015/04/12
 * - added promptUserForFile overload without stream parameter
 * @version 2014/10/19
 * - alphabetized function declarations
 * - converted many funcs to take const string& rather than string for efficiency
 * - added listDirectory overload that returns a Vector
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _filelib_h
#define _filelib_h

#include <iostream>
#include <fstream>
#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * Creates a new directory for the specified path.  The
 * <code>createDirectory</code> function does not report an error if
 * the directory already exists.  Unlike <code>createDirectoryPath</code>,
 * <code>createDirectory</code> does not create missing directories
 * along the path.
 * @throw ErrorException if some component of <code>path</code> does not exist
 */
void createDirectory(const std::string& path);

/**
 * Creates a new directory for the specified path.   If intermediate
 * components of <code>path</code> do not exist, this function creates
 * them as needed.
 */
void createDirectoryPath(const std::string& path);

/**
 * Adds an extension to a file name if none already exists.  If the
 * <code>extension</code> argument begins with a leading <code>*</code>,
 * any existing extension in <code>filename</code> is replaced by
 * <code>ext</code>.
 */
std::string defaultExtension(const std::string& filename, const std::string& ext);

/**
 * Deletes the specified file.
 * @throw ErrorException if the file does not exist or cannot be deleted
 */
void deleteFile(const std::string& filename);

/**
 * Expands a filename into a canonical name for the platform.
 */
std::string expandPathname(const std::string& filename);

/**
 * Returns <code>true</code> if the specified file exists.
 */
bool fileExists(const std::string& filename);

/**
 * Returns the size of the given file in bytes.
 * Returns -1 if the file does not exist or cannot be read.
 */
int fileSize(const std::string& filename);

/**
 * Returns the canonical name of a file found using a search path.
 * The <code>findOnPath</code> function is similar to
 * <code>openOnPath</code>, except that it doesn't actually
 * return an open stream.  If no matching file is found,
 * <code>findOnPath</code> returns the empty string.
 */
std::string findOnPath(const std::string& path, const std::string& filename);

/**
 * Returns an absolute filename for the given file or directory.
 * This converts from, for example, "temp/foo.txt" to "/Users/jsmith12/Documents/temp/foo.txt".
 */
std::string getAbsolutePath(const std::string& path);

/**
 * Returns an absolute filename for the current directory.
 */
std::string getCurrentDirectory();

/**
 * Returns the standard directory path separator used on this platform.
 */
std::string getDirectoryPathSeparator();

/**
 * Returns the extension of <code>filename</code>.  The extension
 * consists of the separating dot and all subsequent characters.
 * If no dot exists in the final component, <code>getExtension</code>
 * returns the empty string.  These semantics ensure that concatenating
 * the root and the extension always returns the original filename.
 */
std::string getExtension(const std::string& filename);

/**
 * Returns all but the last component of a path name.  The components
 * of the path name can be separated by any of the directory path
 * separators (forward or reverse slashes).  The special cases are
 * illustrated by the following examples:
 *
 *<pre>
 *    getHead("a/b")  = "a"     getTail("a/b")   = "b"
 *    getHead("a")    = ""      getTail("a")     = "a"
 *    getHead("/a")   = "/"     getTail("/a")    = "a"
 *    getHead("/")    = "/"     getTail("/")     = ""
 *</pre>
 */
std::string getHead(const std::string& filename);

/**
 * Returns the root of <code>filename</code>.  The root consists
 * of everything in <code>filename</code> up to the last dot and
 * the subsequent extension.  If no dot appears in the final component
 * of the filename, <code>getRoot</code> returns the entire name.
 */
std::string getRoot(const std::string& filename);

/**
 * Returns the standard search path separator used on this platform.
 */
std::string getSearchPathSeparator();

/**
 * Returns the last component of a path name.  The components of the
 * path name can be separated by any of the directory path separators
 * (forward or reverse slashes).  For details on the interpretation of
 * special cases, see the comments for the <code>getHead</code> function.
 */
std::string getTail(const std::string& filename);

/**
 * Returns the operating system's "temp" folder.
 * Can be useful if your program needs to store temporary files.
 */
std::string getTempDirectory();

/**
 * Returns <code>true</code> if the specified file is a directory.
 */
bool isDirectory(const std::string& filename);

/**
 * Returns <code>true</code> if the specified file is a regular file,
 * not a symbolic link or directory.
 */
bool isFile(const std::string& filename);

/**
 * Returns <code>true</code> if the specified file is a symbolic link.
 */
bool isSymbolicLink(const std::string& filename);

/**
 * Adds an alphabetized list of the files in the specified directory
 * to the string vector <code>list</code>.  This list excludes the
 * names <code>.</code> and <code>..</code> entries.
 */
void listDirectory(const std::string& path, Vector<std::string>& list);

/**
 * Adds an alphabetized list of the files in the specified directory
 * to the STL string vector <code>list</code>.  This list excludes the
 * names <code>.</code> and <code>..</code> entries.
 */
void listDirectory(const std::string& path, Vector<std::string>& list);

/**
 * Adds an alphabetized list of the files in the specified directory
 * to a vector that is returned.  This list excludes the
 * names <code>.</code> and <code>..</code> entries.
 */
Vector<std::string> listDirectory(const std::string& path);

/**
 * Determines whether the filename matches the specified pattern.  The
 * pattern string is interpreted in much the same way that a Unix shell
 * expands filenames and supports the following wildcard options:
 *
 *<pre>
 *    ?      Matches any single character
 *    *      Matches any sequence of characters
 *    [...]  Matches any of the specified characters
 *    [^...] Matches any character <i>except</i> the specified ones
 *</pre>
 *
 * The last two options allow a range of characters to be specified in the
 * form <code>a-z</code>.
 */
bool matchFilenamePattern(const std::string& filename, const std::string& pattern);

/**
 * Opens the file input stream <code>stream</code> using the specified
 * filename.  This function is similar to the <code>open</code>
 * method of the stream classes, but uses a C++ <code>string</code>
 * object instead of the older C-style string.  If the operation
 * succeeds, <code>openFile</code> returns <code>true</code>;
 * if it fails, <code>openFile</code> sets the failure flag in the
 * stream and returns <code>false</code>.
 */
bool openFile(std::ifstream& stream, const std::string& filename);

/**
 * Opens the file output stream <code>stream</code> using the specified
 * filename.  This function is similar to the <code>open</code>
 * method of the stream classes, but uses a C++ <code>string</code>
 * object instead of the older C-style string.  If the operation
 * succeeds, <code>openFile</code> returns <code>true</code>;
 * if it fails, <code>openFile</code> sets the failure flag in the
 * stream and returns <code>false</code>.
 */
bool openFile(std::ofstream& stream, const std::string& filename);

/**
 * Opens a dialog that allows the user to choose a file to read.
 * The dialog begins in the current directory.
 */
std::string openFileDialog(std::ifstream& stream);

/**
 * Opens a dialog that allows the user to choose a file to read.
 * The <code>title</code> parameter is displayed in the dialog title.
 * The dialog begins in the current directory.
 */
std::string openFileDialog(std::ifstream& stream,
                           const std::string& title);

/**
 * Opens a dialog that allows the user to choose a file to read.
 * The <code>title</code> parameter is displayed in the dialog title.
 * The <code>path</code> parameter is used to set the working directory.
 */
std::string openFileDialog(std::ifstream& stream,
                           const std::string& title,
                           const std::string& path);

/**
 * Opens a dialog that allows the user to choose a file to write.
 * The dialog begins in the current directory.
 */
std::string openFileDialog(std::ofstream& stream);

/**
 * Opens a dialog that allows the user to choose a file to write.
 * The <code>title</code> parameter is displayed in the dialog title.
 * The dialog begins in the current directory.
 */
std::string openFileDialog(std::ofstream& stream,
                           const std::string& title);

/**
 * Opens a dialog that allows the user to choose a file to write.
 * The <code>title</code> parameter is displayed in the dialog title.
 * The <code>path</code> parameter is used to set the working directory.
 */
std::string openFileDialog(std::ofstream& stream,
                           const std::string& title,
                           const std::string& path);

/**
 * Opens a dialog that allows the user to choose a file name to read or write.
 * The <code>title</code> parameter is displayed in the dialog title.
 * The <code>path</code> parameter is used to set the working directory.
 * If the <code>path</code> is omitted, the dialog begins in the current directory.
 */
std::string openFileDialog(const std::string& title = "Open File ...",
                           const std::string& path = "");

/**
 * Opens a file to read using a search path.  If <code>openOnPath</code>
 * is successful, it returns the first path name on the search path
 * for which <code>stream.open</code> succeeds.  The <code>path</code>
 * argument consists of a list of directories that are prepended to the
 * filename, unless <code>filename</code> begins with an absolute
 * directory marker, such as <code>/</code> or <code>~</code>.
 * The directories in the search path may be separated either
 * by colons (Unix or Mac OS) or semicolons (Windows).  If the file
 * cannot be opened, the failure bit is set in the <code>stream</code>
 * parameter, and the <code>openOnPath</code> function returns the
 * empty string.
 */
std::string openOnPath(std::ifstream& stream,
                       const std::string& path,
                       const std::string& filename);

/**
 * Opens a file to write using a search path.  If <code>openOnPath</code>
 * is successful, it returns the first path name on the search path
 * for which <code>stream.open</code> succeeds.  The <code>path</code>
 * argument consists of a list of directories that are prepended to the
 * filename, unless <code>filename</code> begins with an absolute
 * directory marker, such as <code>/</code> or <code>~</code>.
 * The directories in the search path may be separated either
 * by colons (Unix or Mac OS) or semicolons (Windows).  If the file
 * cannot be opened, the failure bit is set in the <code>stream</code>
 * parameter, and the <code>openOnPath</code> function returns the
 * empty string.
 */
std::string openOnPath(std::ofstream& stream,
                       const std::string& path,
                       const std::string& filename);

/**
 * Asks the user for the name of a file to read.
 * The file is opened using the reference parameter <code>stream</code>.
 * The function returns the name of the file.
 * If the requested file cannot be opened, the user is given additional chances
 * to type a valid file name.
 *
 * The optional <code>prompt</code> argument provides an input prompt
 * for the user.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Unable to open that file.  Try again.".
 */
std::string promptUserForFile(std::ifstream& stream,
                              const std::string& prompt = "",
                              const std::string& reprompt = "");

/**
 * Asks the user for the name of a file to read.
 * The file is opened using the reference parameter <code>stream</code>.
 * The function returns the name of the file.
 * If the requested file cannot be opened, the user is given additional chances
 * to type a valid file name.
 *
 * The optional <code>prompt</code> argument provides an input prompt
 * for the user.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Unable to open that file.  Try again.".
 */
std::string promptUserForFile(std::ofstream& stream,
                              const std::string& prompt = "",
                              const std::string& reprompt = "");

/**
 * Asks the user for the name of a file to read.
 * The function returns the name of the file.
 * If the requested file cannot be opened, the user is given additional chances
 * to type a valid file name.
 *
 * The optional <code>prompt</code> argument provides an input prompt
 * for the user.
 *
 * The also optional <code>reprompt</code> argument provides an output message
 * displayed each time if the user types a file that is not found.
 * If no value is passed, defaults to, "Unable to open that file.  Try again.".
 */
std::string promptUserForFile(const std::string& prompt = "",
                              const std::string& reprompt = "");

/**
 * Reads the entire contents of the specified input stream into the
 * string vector <code>lines</code>.  The client is responsible for
 * opening and closing the stream.  The vector can be either an STL
 * <code>vector</code> or a <code>Vector</code> as defined in the
 * Stanford C++ libraries.
 */
void readEntireFile(std::istream& is, Vector<std::string>& lines);

/**
 * Reads the entire contents of the specified input stream into the
 * string STL vector <code>lines</code>.  The client is responsible for
 * opening and closing the stream.  The vector can be either an STL
 * <code>vector</code> or a <code>Vector</code> as defined in the
 * Stanford C++ libraries.
 */
void readEntireFile(std::istream& is, Vector<std::string>& lines);

/**
 * An overload of readEntireFile that just returns the whole file as a very
 * long single string, rather than a vector of lines.
 * @throw ErrorException if the file is not found or cannot be read.
 */
std::string readEntireFile(const std::string& filename);

/**
 * An overload of readEntireFile that just reads the whole file as a very
 * long single string, rather than a vector of lines.
 *
 * This version fills an output reference with the text read.
 * Returns true if the read was successful or false if the file was not found
 * or unable to be opened for reading.
 */
bool readEntireFile(const std::string& filename, std::string& out);

/**
 * Reads the contents of the given stream until its end and returns them as
 * a string.
 */
std::string readEntireStream(std::istream& input);

/**
 * Reads the contents of the given stream until its end and stores them
 * in the given string 'out' by reference.
 */
void readEntireStream(std::istream& input, std::string& out);

/**
 * Renames a file.
 * @throw ErrorException if the old file does not exist, cannot be read,
 *        the new file name already exists,
 *        or the old file cannot otherwise be renamed to the new file name
 */
void renameFile(const std::string& oldname, const std::string& newname);

/**
 * Moves the given input stream back to its beginning, so that it can
 * be read again from start to finish.
 */
void rewindStream(std::istream& input);

/**
 * Changes the current directory to the specified path.
 */
void setCurrentDirectory(const std::string& path);

/**
 * Opens the given file and writes the given text into it.
 * Normally this function replaces any previous contents of the file, but
 * if the optional 'append' parameter is passed, the given text is added
 * at the end of the file, retaining any previous contents.
 * Returns true if the write was successful and false if the file was unable
 * to be opened for writing.
 */
bool writeEntireFile(const std::string& filename,
                     const std::string& text,
                     bool append = false);

/**
 * Platform-dependent functions that differ by operating system.
 * @private
 */
namespace platform {
    std::string file_openFileDialog(const std::string& title, const std::string& mode, const std::string& path);
    void filelib_createDirectory(const std::string& path);
    void filelib_deleteFile(const std::string& path);
    std::string filelib_expandPathname(const std::string& filename);
    bool filelib_fileExists(const std::string& filename);
    std::string filelib_getAbsolutePath(const std::string& path);
    std::string filelib_getCurrentDirectory();
    std::string filelib_getDirectoryPathSeparator();
    std::string filelib_getSearchPathSeparator();
    std::string filelib_getTempDirectory();
    bool filelib_isDirectory(const std::string& filename);
    bool filelib_isFile(const std::string& filename);
    bool filelib_isSymbolicLink(const std::string& filename);
    void filelib_listDirectory(const std::string& path, Vector<std::string>& list);
    void filelib_setCurrentDirectory(const std::string& path);
}

#endif // _filelib_h

/////////////////////// END code extracted from StanfordCPPLib/io/filelib.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/deque.h ///////////////////////
/*
 * File: deque.h
 * -------------
 * This file exports the <code>Deque</code> class, a collection
 * in which values can be added and removed from the front or back.
 * It combines much of the functionality of a stack and a queue.
 * 
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2019/02/04
 * - changed internal implementation to wrap std collections
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - added constructor support for std initializer_list usage, such as {1, 2, 3}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/10/29
 * - added comparison operators ==, !=, <, etc.
 * @since 2014/10/29
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _deque_h
#define _deque_h

#include <deque>
#include <initializer_list>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Deque<ValueType>
 * -----------------------
 * This class models a linear structure called a <b><i>deque</i></b>
 * in which values can be added and removed at either end.
 * This discipline allows first-in/first-out (FIFO) and/or
 * last-in/first-out (LIFO) behavior. That is the defining
 * feature of deques.
 */
template <typename ValueType>
class Deque {
public:
    /*
     * Constructor: Deque
     * Usage: Deque<ValueType> deque;
     * ------------------------------
     * Initializes a new empty deque.
     */
    Deque() = default;

    /*
     * Constructor: Deque
     * Usage: Deque<ValueType> queue {1, 2, 3};
     * ----------------------------------------
     * Initializes a new deque that stores the given elements from front-back.
     */
    Deque(std::initializer_list<ValueType> list);

    /*
     * Destructor: ~Deque
     * ------------------
     * Frees any heap storage associated with this deque.
     */
    virtual ~Deque() = default;
    
    /*
     * Method: add
     * Usage: deque.add(value);
     * ------------------------
     * Adds <code>value</code> to the end of the deque.
     * A synonym for the enqueueBack method.
     */
    void add(const ValueType& value);
    void addBack(const ValueType& value);
    void addFront(const ValueType& value);

    /*
     * Method: back
     * Usage: ValueType last = deque.back();
     * -------------------------------------
     * Returns the last value in the deque by reference.
     */
    const ValueType& back() const;

    /*
     * Method: clear
     * Usage: deque.clear();
     * ---------------------
     * Removes all elements from the deque.
     */
    void clear();
    
    /*
     * Method: dequeue
     * Usage: ValueType first = deque.dequeue();
     * -----------------------------------------
     * Removes and returns the first item in the deque.
     * A synonym for the dequeueFront method.
     */
    ValueType dequeue();
    ValueType dequeueBack();
    ValueType dequeueFront();

    /*
     * Method: enqueue
     * Usage: deque.enqueue(value);
     * ----------------------------
     * Adds <code>value</code> to the end of the deque.
     * A synonym for the enqueueBack method.
     */
    void enqueue(const ValueType& value);
    void enqueueBack(const ValueType& value);
    void enqueueFront(const ValueType& value);
    
    /*
     * Method: equals
     * Usage: if (deque.equals(deque2)) ...
     * ------------------------------------
     * Compares two deques for equality.
     * Returns <code>true</code> if this deque contains exactly the same
     * values as the given other deque.
     * Identical in behavior to the == operator.
     */
    bool equals(const Deque<ValueType>& deque2) const;
    
    /*
     * Method: front
     * Usage: ValueType first = deque.front();
     * ---------------------------------------
     * Returns the first value in the deque by reference.
     */
    const ValueType& front() const;

    /*
     * Method: isEmpty
     * Usage: if (deque.isEmpty()) ...
     * -------------------------------
     * Returns <code>true</code> if the deque contains no elements.
     */
    bool isEmpty() const;
    
    /*
     * Method: peek
     * Usage: ValueType first = deque.peek();
     * --------------------------------------
     * Returns the first value in the deque, without removing it.  For
     * compatibility with the STL classes, this method is also exported
     * under the name <code>front</code>, in which case it returns the
     * value by reference.
     * A synonym for the peekFront method.
     */
    const ValueType& peek() const;
    const ValueType& peekBack() const;
    const ValueType& peekFront() const;

    /*
     * Method: remove
     * Usage: ValueType first = deque.remove();
     * ----------------------------------------
     * Removes and returns the first item in the deque.
     * A synonym for the dequeue method.
     */
    ValueType remove();
    ValueType removeBack();
    ValueType removeFront();

    /*
     * Method: size
     * Usage: int n = deque.size();
     * ----------------------------
     * Returns the number of values in the deque.
     */
    int size() const;
    
    /*
     * Returns an STL deque object with the same elements as this Deque.
     */
    std::deque<ValueType> toStlDeque() const;
    
    /*
     * Method: toString
     * Usage: string str = deque.toString();
     * -------------------------------------
     * Converts the deque to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operators: ==, !=, <, >, <=, >=
     * Usage: if (deque1 == deque2) ...
     * Usage: if (deque1 < deque2) ...
     * ...
     * --------------------------------
     * Relational operators to compare two deques.
     * The ==, != operators require that the ValueType has a == operator
     * so that the elements can be tested for equality.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator ==(const Deque& deque2) const;
    bool operator !=(const Deque& deque2) const;
    bool operator <(const Deque& deque2) const;
    bool operator <=(const Deque& deque2) const;
    bool operator >(const Deque& deque2) const;
    bool operator >=(const Deque& deque2) const;

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    template <typename T>
    friend int hashCode(const Deque<T>& s);
    
    template <typename T>
    friend std::ostream& operator <<(std::ostream& os, const Deque<T>& deque);

private:
    // Instance variables
    std::deque<ValueType> _elements;
    stanfordcpplib::collections::VersionTracker _version;

public:

    using iterator = stanfordcpplib::collections::CheckedIterator<typename std::deque<ValueType>::iterator>;
    using const_iterator = stanfordcpplib::collections::CheckedIterator<typename std::deque<ValueType>::const_iterator>;

    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;
};

template <typename ValueType>
Deque<ValueType>::Deque(std::initializer_list<ValueType> list) : _elements(list) {

}

template <typename ValueType>
void Deque<ValueType>::add(const ValueType& value) {
    enqueue(value);
}

template <typename ValueType>
void Deque<ValueType>::addBack(const ValueType& value) {
    enqueueBack(value);
}

template <typename ValueType>
void Deque<ValueType>::addFront(const ValueType& value) {
    enqueueFront(value);
}

template <typename ValueType>
const ValueType& Deque<ValueType>::back() const {
    if (isEmpty()) {
        error("Deque::back: Attempting to read back of an empty deque");
    }
    return _elements.back();
}

template <typename ValueType>
void Deque<ValueType>::clear() {
    _elements.clear();
    _version.update();
}

/*
 * Implementation notes: dequeue, peek
 * -----------------------------------
 * These methods must check for an empty deque and report an error
 * if there is no first element.
 */
template <typename ValueType>
ValueType Deque<ValueType>::dequeue() {
    return dequeueFront();
}

template <typename ValueType>
ValueType Deque<ValueType>::dequeueBack() {
    if (isEmpty()) {
        error("Deque::dequeueBack: Attempting to dequeue from an empty deque");
    }
    auto result = _elements.back();
    _elements.pop_back();
    _version.update();
    return result;
}

template <typename ValueType>
ValueType Deque<ValueType>::dequeueFront() {
    if (isEmpty()) {
        error("Deque::dequeueFront: Attempting to dequeue from an empty deque");
    }
    auto result = _elements.front();
    _elements.pop_front();
    _version.update();
    return result;
}

template <typename ValueType>
void Deque<ValueType>::enqueue(const ValueType& value) {
    enqueueBack(value);
}

template <typename ValueType>
void Deque<ValueType>::enqueueBack(const ValueType& value) {
    _elements.push_back(value);
    _version.update();
}

template <typename ValueType>
void Deque<ValueType>::enqueueFront(const ValueType& value) {
    _elements.push_front(value);
    _version.update();
}

template <typename ValueType>
bool Deque<ValueType>::equals(const Deque<ValueType>& deque2) const {
    return _elements == deque2._elements;
}

template <typename ValueType>
const ValueType& Deque<ValueType>::front() const {
    if (isEmpty()) {
        error("Deque::front: Attempting to read front of an empty deque");
    }
    return _elements.front();
}

template <typename ValueType>
bool Deque<ValueType>::isEmpty() const {
    return _elements.empty();
}

template <typename ValueType>
const ValueType& Deque<ValueType>::peek() const {
    return peekFront();
}

template <typename ValueType>
const ValueType& Deque<ValueType>::peekBack() const {
    if (isEmpty()) {
        error("Deque::peekBack: Attempting to peek at an empty deque");
    }
    return back();
}

template <typename ValueType>
const ValueType& Deque<ValueType>::peekFront() const {
    if (isEmpty()) {
        error("Deque::peekFront: Attempting to peek at an empty deque");
    }
    return front();
}

template <typename ValueType>
ValueType Deque<ValueType>::remove() {
    return dequeue();
}

template <typename ValueType>
ValueType Deque<ValueType>::removeBack() {
    if (isEmpty()) {
        error("Deque::removeBack: Attempting to remove from an empty deque");
    }
    return dequeueBack();
}

template <typename ValueType>
ValueType Deque<ValueType>::removeFront() {
    if (isEmpty()) {
        error("Deque::removeFront: Attempting to remove from an empty deque");
    }
    return dequeueFront();
}

template <typename ValueType>
int Deque<ValueType>::size() const {
    return _elements.size();
}

template <typename ValueType>
std::deque<ValueType> Deque<ValueType>::toStlDeque() const {
    return _elements;
}

template <typename ValueType>
std::string Deque<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
bool Deque<ValueType>::operator ==(const Deque& deque2) const {
    return equals(deque2);
}

template <typename ValueType>
bool Deque<ValueType>::operator !=(const Deque& deque2) const {
    return !equals(deque2);
}

template <typename ValueType>
bool Deque<ValueType>::operator <(const Deque& deque2) const {
    return stanfordcpplib::collections::compare(_elements, deque2._elements) < 0;
}

template <typename ValueType>
bool Deque<ValueType>::operator <=(const Deque& deque2) const {
    return stanfordcpplib::collections::compare(_elements, deque2._elements) <= 0;
}

template <typename ValueType>
bool Deque<ValueType>::operator >(const Deque& deque2) const {
    return stanfordcpplib::collections::compare(_elements, deque2._elements) > 0;
}

template <typename ValueType>
bool Deque<ValueType>::operator >=(const Deque& deque2) const {
    return stanfordcpplib::collections::compare(_elements, deque2._elements) >= 0;
}

template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Deque<ValueType>& deque) {
    return stanfordcpplib::collections::writeCollection(os, deque);
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Deque<ValueType>& deque) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, deque, element, /* descriptor */ "Deque::operator >>");
}

template <typename ValueType>
typename Deque<ValueType>::iterator Deque<ValueType>::begin() {
    return { &_version, _elements.begin(), _elements };
}
template <typename ValueType>
typename Deque<ValueType>::const_iterator Deque<ValueType>::begin() const {
    return { &_version, _elements.begin(), _elements };
}

template <typename ValueType>
typename Deque<ValueType>::iterator Deque<ValueType>::end() {
    return { &_version, _elements.end(), _elements };
}
template <typename ValueType>
typename Deque<ValueType>::const_iterator Deque<ValueType>::end() const {
    return { &_version, _elements.end(), _elements };
}

/*
 * Template hash function for deques.
 * Requires the element type in the deque to have a hashCode function.
 */
template <typename T>
int hashCode(const Deque<T>& deq) {
    return stanfordcpplib::collections::hashCodeCollection(deq);
}

#endif // _deque_h

/////////////////////// END code extracted from StanfordCPPLib/collections/deque.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/queue.h ///////////////////////
/*
 * File: queue.h
 * -------------
 * This file exports the <code>Queue</code> class, a collection
 * in which values are ordinarily processed in a first-in/first-out
 * (FIFO) order.
 * 
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2019/02/04
 * - changed internal implementation to wrap std collections
 * @version 2018/01/23
 * - fixed bad reference bug on queue.enqueue(queue.peek())
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * - added iterators begin(), end()
 * @version 2016/09/22
 * - optimized equals, ==, != to avoid deep-copy
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as {1, 2, 3}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added comparison operators ==, !=, <, etc.
 * - added add() method as synonym for enqueue()
 * - added remove() method as synonym for dequeue()
 * - added template hashCode function
 * - optimized some functions (operator <<, toStlQueue) to avoid making unneeded deep copy
 * @version 2014/10/10
 * - removed dependency on 'using namespace' statement
 * - removed usage of __foreach macro
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _queue_h
#define _queue_h

#include <initializer_list>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Queue<ValueType>
 * -----------------------
 * This class models a linear structure called a <b><i>queue</i></b>
 * in which values are added at one end and removed from the other.
 * This discipline gives rise to a first-in/first-out behavior (FIFO)
 * that is the defining feature of queues.
 */
template <typename ValueType>
class Queue {
public:
    /*
     * Constructor: Queue
     * Usage: Queue<ValueType> queue;
     * ------------------------------
     * Initializes a new empty queue.
     */
    Queue() = default;

    /*
     * Constructor: Queue
     * Usage: Queue<ValueType> queue {1, 2, 3};
     * ----------------------------------------
     * Initializes a new queue that stores the given elements from front-back.
     */
    Queue(std::initializer_list<ValueType> list);

    /*
     * Destructor: ~Queue
     * ------------------
     * Frees any heap storage associated with this queue.
     */
    virtual ~Queue() = default;
    
    /*
     * Method: add
     * Usage: queue.add(value);
     * ------------------------
     * Adds <code>value</code> to the end of the queue.
     * A synonym for the enqueue method.
     */
    void add(const ValueType& value);

    /*
     * Method: back
     * Usage: ValueType last = queue.back();
     * -------------------------------------
     * Returns the last value in the queue by reference.
     */
    const ValueType& back() const;

    /*
     * Method: clear
     * Usage: queue.clear();
     * ---------------------
     * Removes all elements from the queue.
     */
    void clear();
    
    /*
     * Method: dequeue
     * Usage: ValueType first = queue.dequeue();
     * -----------------------------------------
     * Removes and returns the first item in the queue.
     */
    ValueType dequeue();

    /*
     * Method: enqueue
     * Usage: queue.enqueue(value);
     * ----------------------------
     * Adds <code>value</code> to the end of the queue.
     */
    void enqueue(const ValueType& value);
    
    /*
     * Method: equals
     * Usage: if (queue.equals(queue2)) ...
     * ------------------------------------
     * Compares two queues for equality.
     * Returns <code>true</code> if this queue contains exactly the same
     * values as the given other queue.
     * Identical in behavior to the == operator.
     */
    bool equals(const Queue<ValueType>& queue2) const;
    
    /*
     * Method: front
     * Usage: ValueType first = queue.front();
     * ---------------------------------------
     * Returns the first value in the queue by reference.
     */
    const ValueType& front() const;

    /*
     * Method: isEmpty
     * Usage: if (queue.isEmpty()) ...
     * -------------------------------
     * Returns <code>true</code> if the queue contains no elements.
     */
    bool isEmpty() const;
    
    /*
     * Method: peek
     * Usage: ValueType first = queue.peek();
     * --------------------------------------
     * Returns the first value in the queue, without removing it.  For
     * compatibility with the STL classes, this method is also exported
     * under the name <code>front</code>, in which case it returns the
     * value by reference.
     */
    const ValueType& peek() const;

    /*
     * Method: remove
     * Usage: ValueType first = queue.remove();
     * ----------------------------------------
     * Removes and returns the first item in the queue.
     * A synonym for the dequeue method.
     */
    ValueType remove();

    /*
     * Method: size
     * Usage: int n = queue.size();
     * ----------------------------
     * Returns the number of values in the queue.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = queue.toString();
     * -------------------------------------
     * Converts the queue to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operator: ==
     * Usage: queue1 == queue2
     * -------------------
     * Returns <code>true</code> if <code>queue1</code> and <code>queue2</code>
     * contain the same elements.
     */
    bool operator ==(const Queue& queue2) const;

    /*
     * Operator: !=
     * Usage: queue1 != queue2
     * -------------------
     * Returns <code>true</code> if <code>queue1</code> and <code>queue2</code>
     * do not contain the same elements.
     */
    bool operator !=(const Queue& queue2) const;

    /*
     * Operators: <, >, <=, >=
     * Usage: queue1 < queue2 ...
     * --------------------------
     * Relational operators to compare two queues.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const Queue& queue2) const;
    bool operator <=(const Queue& queue2) const;
    bool operator >(const Queue& queue2) const;
    bool operator >=(const Queue& queue2) const;

    template <typename T>
    friend int hashCode(const Queue<T>& s);
    
    template <typename T>
    friend std::ostream& operator <<(std::ostream& os, const Queue<T>& queue);
    
    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    /* Instance variables */
    Deque<ValueType> _elements;
};

template <typename ValueType>
Queue<ValueType>::Queue(std::initializer_list<ValueType> list) : _elements(list) {
    // empty
}

template <typename ValueType>
void Queue<ValueType>::add(const ValueType& value) {
    enqueue(value);
}

template <typename ValueType>
const ValueType& Queue<ValueType>::back() const {
    if (isEmpty()) {
        error("Queue::back: Attempting to read back of an empty queue");
    }
    return _elements.back();
}

template <typename ValueType>
void Queue<ValueType>::clear() {
    _elements.clear();
}

/*
 * Implementation notes: dequeue, peek
 * -----------------------------------
 * These methods must check for an empty queue and report an error
 * if there is no first element.
 */
template <typename ValueType>
ValueType Queue<ValueType>::dequeue() {
    if (isEmpty()) {
        error("Queue::dequeue: Attempting to dequeue an empty queue");
    }
    return _elements.dequeueFront();
}

template <typename ValueType>
void Queue<ValueType>::enqueue(const ValueType& value) {
    _elements.enqueueBack(value);
}

template <typename ValueType>
bool Queue<ValueType>::equals(const Queue<ValueType>& queue2) const {
    return *this == queue2;
}

template <typename ValueType>
const ValueType& Queue<ValueType>::front() const {
    if (isEmpty()) {
        error("Queue::front: Attempting to read front of an empty queue");
    }
    return _elements.front();
}

template <typename ValueType>
bool Queue<ValueType>::isEmpty() const {
    return _elements.isEmpty();
}

template <typename ValueType>
const ValueType& Queue<ValueType>::peek() const {
    return front();
}

template <typename ValueType>
ValueType Queue<ValueType>::remove() {
    // this isEmpty check is also done in dequeue(), but we repeat it
    // here so that the possible error message will be more descriptive.
    if (isEmpty()) {
        error("Queue::remove: Attempting to remove from an empty queue");
    }
    return dequeue();
}

template <typename ValueType>
int Queue<ValueType>::size() const {
    return _elements.size();
}

template <typename ValueType>
std::string Queue<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
bool Queue<ValueType>::operator ==(const Queue& queue2) const {
    return _elements == queue2._elements;
}

template <typename ValueType>
bool Queue<ValueType>::operator !=(const Queue& queue2) const {
    return _elements != queue2._elements;
}

template <typename ValueType>
bool Queue<ValueType>::operator <(const Queue& queue2) const {
    return _elements < queue2._elements;
}

template <typename ValueType>
bool Queue<ValueType>::operator <=(const Queue& queue2) const {
    return _elements <= queue2._elements;
}

template <typename ValueType>
bool Queue<ValueType>::operator >(const Queue& queue2) const {
    return _elements > queue2._elements;
}

template <typename ValueType>
bool Queue<ValueType>::operator >=(const Queue& queue2) const {
    return _elements >= queue2._elements;
}

template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Queue<ValueType>& queue) {
    return os << queue._elements;
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Queue<ValueType>& queue) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, queue, queue._elements, /* descriptor */ "Queue::operator >>");
}

/*
 * Template hash function for queues.
 * Requires the element type in the queue to have a hashCode function.
 */
template <typename T>
int hashCode(const Queue<T>& q) {
    return hashCode(q._elements);
}

#endif // _queue_h

/////////////////////// END code extracted from StanfordCPPLib/collections/queue.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/stack.h ///////////////////////
/*
 * File: stack.h
 * -------------
 * This file exports the <code>Stack</code> class, which implements
 * a collection that processes values in a last-in/first-out (LIFO) order.
 * 
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2019/02/04
 * - changed internal implementation to wrap std collections
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via Vector)
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * - made const iterators public
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as {1, 2, 3}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2014/11/13
 * - added add() method as synonym for push()
 * - added remove() method as synonym for pop()
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _stack_h
#define _stack_h

#include <initializer_list>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Stack<ValueType>
 * -----------------------
 * This class models a linear structure called a <b><i>stack</i></b>
 * in which values are added and removed only from one end.
 * This discipline gives rise to a last-in/first-out behavior (LIFO)
 * that is the defining feature of stacks.  The fundamental stack
 * operations are <code>push</code> (add to top) and <code>pop</code>
 * (remove from top).
 */
template <typename ValueType>
class Stack {
public:
    /*
     * Constructor: Stack
     * Usage: Stack<ValueType> stack;
     * ------------------------------
     * Initializes a new empty stack.
     */
    Stack() = default;

    /*
     * Constructor: Stack
     * Usage: Stack<ValueType> stack {1, 2, 3};
     * ----------------------------------------
     * Initializes a new stack that stores the given elements from bottom-top.
     */
    Stack(std::initializer_list<ValueType> list);

    /*
     * Destructor: ~Stack
     * ------------------
     * Frees any heap storage associated with this stack.
     */
    virtual ~Stack() = default;
    
    /*
     * Method: add
     * Usage: stack.add(value);
     * -------------------------
     * Pushes the specified value onto the top of this stack.
     * A synonym for the push method.
     */
    void add(const ValueType& value);
    
    /*
     * Method: clear
     * Usage: stack.clear();
     * ---------------------
     * Removes all elements from this stack.
     */
    void clear();
    
    /*
     * Method: equals
     * Usage: if (stack.equals(stack2)) ...
     * ------------------------------------
     * Returns <code>true</code> if this stack contains exactly the same values
     * as the given other stack.
     * Identical in behavior to the == operator.
     */
    bool equals(const Stack<ValueType>& stack2) const;
    
    /*
     * Method: isEmpty
     * Usage: if (stack.isEmpty()) ...
     * -------------------------------
     * Returns <code>true</code> if this stack contains no elements.
     */
    bool isEmpty() const;
    
    /*
     * Method: peek
     * Usage: ValueType top = stack.peek();
     * ------------------------------------
     * Returns the value of top element from this stack, without removing
     * it.  This method signals an error if called on an empty stack.
     */
    ValueType peek() const;
    
    /*
     * Method: pop
     * Usage: ValueType top = stack.pop();
     * -----------------------------------
     * Removes the top element from this stack and returns it.  This
     * method signals an error if called on an empty stack.
     */
    ValueType pop();
    
    /*
     * Method: push
     * Usage: stack.push(value);
     * -------------------------
     * Pushes the specified value onto the top of this stack.
     */
    void push(const ValueType& value);

    /*
     * Method: remove
     * Usage: ValueType top = stack.remove();
     * -----------------------------------
     * Removes the top element from this stack and returns it.
     * A synonym for the pop method.
     */
    ValueType remove();

    /*
     * Method: size
     * Usage: int n = stack.size();
     * ----------------------------
     * Returns the number of values in this stack.
     */
    int size() const;
    
    /*
     * Method: top
     * Usage: ValueType top = stack.top();
     * ------------------------------------
     * Returns the value of top element from this stack, without removing
     * it.  This method signals an error if called on an empty stack.  For
     * compatibility with the STL classes, this method is exported
     * under the name <code>top</code>, in which case it returns the value
     * by reference.
     */
    ValueType& top();

    /*
     * Method: toString
     * Usage: string str = stack.toString();
     * -------------------------------------
     * Converts the stack to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operator: ==
     * Usage: stack1 == stack2
     * -----------------------
     * Returns <code>true</code> if <code>stack1</code> and <code>stack2</code>
     * contain the same elements.
     */
    bool operator ==(const Stack& stack2) const;

    /*
     * Operator: !=
     * Usage: stack1 != stack2
     * -----------------------
     * Returns <code>true</code> if <code>stack1</code> and <code>stack2</code>
     * do not contain the same elements.
     */
    bool operator !=(const Stack& stack2) const;

    /*
     * Operators: <, >, <=, >=
     * Usage: if (stack1 < stack2) ...
     * -------------------------------
     * Relational operators to compare two stacks.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const Stack& stack2) const;
    bool operator <=(const Stack& stack2) const;
    bool operator >(const Stack& stack2) const;
    bool operator >=(const Stack& stack2) const;

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes: Stack data structure
     * ------------------------------------------
     * The easiest way to implement a stack is to store the elements in a
     * Vector.  Doing so means that the problems of dynamic memory allocation
     * and copy assignment are already solved by the implementation of the
     * underlying Vector class.
     */

    template <typename T>
    friend int hashCode(const Stack<T>& s);
    
    template <typename T>
    friend std::ostream& operator <<(std::ostream& os, const Stack<T>& stack);
    
private:
    Vector<ValueType> _elements;
};

/*
 * Stack class implementation
 * --------------------------
 * The Stack is internally managed using a Vector.  This layered design
 * makes the implementation extremely simple, to the point that most
 * methods can be implemented in as single line.
 */

template <typename ValueType>
Stack<ValueType>::Stack(std::initializer_list<ValueType> list) : _elements(list) {

}

template <typename ValueType>
void Stack<ValueType>::add(const ValueType& value) {
    push(value);
}

template <typename ValueType>
void Stack<ValueType>::clear() {
    _elements.clear();
}

template <typename ValueType>
bool Stack<ValueType>::equals(const Stack<ValueType>& stack2) const {
    return stanfordcpplib::collections::equals(_elements, stack2._elements);
}

template <typename ValueType>
bool Stack<ValueType>::isEmpty() const {
    return size() == 0;
}

template <typename ValueType>
ValueType Stack<ValueType>::peek() const {
    if (isEmpty()) {
        error("Stack::peek: Attempting to peek at an empty stack");
    }
    return _elements.back();
}

template <typename ValueType>
ValueType Stack<ValueType>::pop() {
    if (isEmpty()) {
        error("Stack::pop: Attempting to pop an empty stack");
    }
    return _elements.pop_back();
}

template <typename ValueType>
void Stack<ValueType>::push(const ValueType& value) {
    _elements.push_back(value);
}

template <typename ValueType>
ValueType Stack<ValueType>::remove() {
    return pop();
}

template <typename ValueType>
int Stack<ValueType>::size() const {
    return _elements.size();
}

template <typename ValueType>
ValueType & Stack<ValueType>::top() {
    if (isEmpty()) {
        error("Stack::top: Attempting to read top of an empty stack");
    }
    return _elements.back();
}

template <typename ValueType>
std::string Stack<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
bool Stack<ValueType>::operator ==(const Stack& stack2) const {
    return _elements == stack2._elements;
}

template <typename ValueType>
bool Stack<ValueType>::operator !=(const Stack & stack2) const {
    return _elements != stack2._elements;
}

template <typename ValueType>
bool Stack<ValueType>::operator <(const Stack & stack2) const {
    return _elements < stack2._elements;
}

template <typename ValueType>
bool Stack<ValueType>::operator <=(const Stack & stack2) const {
    return _elements <= stack2._elements;
}

template <typename ValueType>
bool Stack<ValueType>::operator >(const Stack & stack2) const {
    return _elements > stack2._elements;
}

template <typename ValueType>
bool Stack<ValueType>::operator >=(const Stack & stack2) const {
    return _elements >= stack2._elements;
}

template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Stack<ValueType>& stack) {
    return os << stack._elements;
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Stack<ValueType>& stack) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, stack, element, /* descriptor */ "Stack::operator >>");
}

/*
 * Template hash function for stacks.
 * Requires the element type in the Stack to have a hashCode function.
 */
template <typename T>
int hashCode(const Stack<T>& s) {
    return hashCode(s._elements);
}

#endif // _stack_h

/////////////////////// END code extracted from StanfordCPPLib/collections/stack.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/io/tokenscanner.h ///////////////////////
/*
 * File: tokenscanner.h
 * --------------------
 * This file exports a <code>TokenScanner</code> class that divides
 * a string into individual logical units called <b><i>tokens</i></b>.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2018/09/23
 * - moved TokenType enum to inside TokenScanner class to avoid namespace conflicts
 *   (may break some client code)
 * - remove private/tokenpatch.h
 * @version 2016/11/26
 * - added getInput method
 * - replaced occurrences of string with const string& for efficiency
 * - alphabetized method ordering
 * - added operator << for printing a scanner
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _tokenscanner_h
#define _tokenscanner_h

#include <iostream>
#include <string>

/**
 * This class divides a string into individual tokens.  The typical
 * use of the <code>TokenScanner</code> class is illustrated by the
 * following pattern, which reads the tokens in the string variable
 * <code>input</code>:
 *
 *<pre>
 *    TokenScanner scanner(input);
 *    while (scanner.hasMoreTokens()) {
 *       string token = scanner.nextToken();
 *       ... process the token ...
 *    }
 *</pre>
 *
 * The <code>TokenScanner</code> class exports several additional methods
 * that give clients more control over its behavior.  Those methods are
 * described individually in the documentation.
 */
class TokenScanner {
public:
    /**
     * This enumerated type defines the values of the
     * <code>getTokenType</code> method.
     */
    enum TokenType {SEPARATOR, WORD, NUMBER, STRING, OPERATOR};

    /**
     * Initializes a scanner object with an empty token stream.
     */
    TokenScanner();

    /**
     * Initializes a scanner object.  The initial token stream comes from
     * the specified input stream.
     */
    TokenScanner(std::istream& infile);

    /**
     * Initializes a scanner object.  The initial token stream comes from
     * the specified string.
     */
    TokenScanner(const std::string& str);

    /**
     * Deallocates the storage associated with this scanner.
     */
    virtual ~TokenScanner();

    /**
     * Defines a new multicharacter operator.  Whenever you call
     * <code>nextToken</code> when the input stream contains operator
     * characters, the scanner returns the longest possible operator
     * string that can be read at that point.
     */
    void addOperator(const std::string& op);

    /**
     * Adds the characters in <code>str</code> to the set of characters
     * legal in a <code>WORD</code> token.  For example, calling
     * <code>addWordCharacters("_")</code> adds the underscore to the
     * set of characters that are accepted as part of a word.
     */
    void addWordCharacters(const std::string& str);

    /**
     * Reads the next character from the scanner input stream.
     */
    int getChar();

    /**
     * Returns the string that is used as the input buffer for this scanner,
     * if any. If this scanner was created using an istream instead of a
     * string, returns an empty string.
     */
    std::string getInput() const;

    /**
     * Returns the current position of the scanner in the input stream.
     * If <code>saveToken</code> has been called, this position corresponds
     * to the beginning of the saved token.  If <code>saveToken</code> is
     * called more than once, <code>getPosition</code> returns -1.
     */
    int getPosition() const;

    /**
     * Returns the string value of a token.  This value is formed by removing
     * any surrounding quotation marks and replacing escape sequences by the
     * appropriate characters.
     */
    std::string getStringValue(const std::string& token) const;

    /**
     * Returns the type of this token.  This type will match one of the
     * following enumerated type constants: <code>EOF</code>,
     * <code>SEPARATOR</code>, <code>WORD</code>, <code>NUMBER</code>,
     * <code>STRING</code>, or <code>OPERATOR</code>.
     */
    TokenType getTokenType(const std::string& token) const;

    /**
     * Returns <code>true</code> if there are additional tokens for this
     * scanner to read.
     */
    bool hasMoreTokens();

    /**
     * Tells the scanner to ignore comments.  The scanner package recognizes
     * both the slash-star and slash-slash comment format from the C-based
     * family of languages.  Calling:
     *
     *<pre>
     *    scanner.ignoreComments();
     *</pre>
     *
     * sets the parser to ignore comments.
     */
    void ignoreComments();

    /**
     * Tells the scanner to ignore whitespace characters.  By default,
     * the <code>nextToken</code> method treats whitespace characters
     * (typically spaces and tabs) just like any other punctuation mark
     * and returns them as single-character tokens.
     * Calling:
     *
     *<pre>
     *    scanner.ignoreWhitespace();
     *</pre>
     *
     * changes this behavior so that the scanner ignore whitespace characters.
     */
    void ignoreWhitespace();

    /**
     * Returns <code>true</code> if the character is valid in a word.
     */
    bool isWordCharacter(char ch) const;

    /**
     * Returns the next token from this scanner.  If <code>nextToken</code>
     * is called when no tokens are available, it returns the empty string.
     */
    std::string nextToken();

    /**
     * Pushes the specified token back into this scanner's input stream.
     * On the next call to <code>nextToken</code>, the scanner will return
     * the saved token without reading any additional characters from the
     * token stream.
     */
    void saveToken(const std::string& token);

    /**
     * Controls how the scanner treats tokens that begin with a digit.  By
     * default, the <code>nextToken</code> method treats numbers and letters
     * identically and therefore does not provide any special processing for
     * numbers.  Calling:
     *
     *<pre>
     *    scanner.scanNumbers();
     *</pre>
     *
     * changes this behavior so that <code>nextToken</code> returns the
     * longest substring that can be interpreted as a real number.
     */
    void scanNumbers();

    /**
     * Controls how the scanner treats tokens enclosed in quotation marks.  By
     * default, quotation marks (either single or double) are treated just like
     * any other punctuation character.  Calling:
     *
     *<pre>
     *    scanner.scanStrings();
     *</pre>
     *
     * changes this assumption so that <code>nextToken</code> returns a single
     * token consisting of all characters through the matching quotation mark.
     * The quotation marks are returned as part of the scanned token so that
     * clients can differentiate strings from other token types.
     */
    void scanStrings();

    /**
     * Sets the token stream for this scanner to the specified input stream.
     * Any previous token stream is discarded.
     */
    void setInput(std::istream& infile);

    /**
     * Sets the token stream for this scanner to the specified string.
     * Any previous token stream is discarded.
     */
    void setInput(const std::string& str);

    /**
     * Pushes the character <code>ch</code> back into the scanner stream.
     * The character must match the one that was read.
     */
    void ungetChar(int ch);

    /**
     * Reads the next token and makes sure it matches the string
     * <code>expected</code>.  If it does not, <code>verifyToken</code>
     * throws an error.
     * @throw ErrorException if the next token does not match the given string
     */
    void verifyToken(const std::string& expected);

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    /*
     * Private type: StringCell
     * ------------------------
     * This type is used to construct linked lists of cells, which are used
     * to represent both the stack of saved tokens and the set of defined
     * operators.  These types cannot use the Stack and Lexicon classes
     * directly because tokenscanner.h is an extremely low-level interface,
     * and doing so would create circular dependencies in the .h files.
     */
    struct StringCell {
        std::string str;
        StringCell *link;
    };

    enum NumberScannerState {
        INITIAL_STATE,
        BEFORE_DECIMAL_POINT,
        AFTER_DECIMAL_POINT,
        STARTING_EXPONENT,
        FOUND_EXPONENT_SIGN,
        SCANNING_EXPONENT,
        FINAL_STATE
    };

    std::string buffer;              /* The original argument string */
    std::istream* isp;               /* The input stream for tokens  */
    bool stringInputFlag;            /* Flag indicating string input */
    bool ignoreWhitespaceFlag;       /* Scanner ignores whitespace   */
    bool ignoreCommentsFlag;         /* Scanner ignores comments     */
    bool scanNumbersFlag;            /* Scanner parses numbers       */
    bool scanStringsFlag;            /* Scanner parses strings       */
    std::string wordChars;           /* Additional word characters   */
    StringCell* savedTokens;         /* Stack of saved tokens        */
    StringCell* operators;           /* List of multichar operators  */

    /* Private method prototypes */
    void initScanner();
    bool isOperator(const std::string& op);
    bool isOperatorPrefix(const std::string& op);
    std::string scanNumber();
    std::string scanString();
    std::string scanWord();
    void skipSpaces();

    friend std::ostream& operator <<(std::ostream& out, const TokenScanner& scanner);
};

/**
 * Prints the token scanner to the given output stream.
 */
std::ostream& operator <<(std::ostream& out, const TokenScanner& scanner);

#endif // _tokenscanner_h

/////////////////////// END code extracted from StanfordCPPLib/io/tokenscanner.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/map.h ///////////////////////
/*
 * File: map.h
 * -----------
 * This file exports the template class <code>Map</code>, which
 * maintains a collection of <i>key</i>-<i>value</i> pairs.
 * 
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2019/02/04
 * - changed internal implementation to wrap std collections
 * @version 2018/03/19
 * - added constructors that accept a comparison function
 * @version 2018/03/10
 * - added methods front, back
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2016/12/09
 * - added iterator version checking support
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - bug fix for operators <, <=, >, >= (was comparing only keys!)
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as
 *   {{"a", 1}, {"b", 2}, {"c", 3}} in constructor, addAll, putAll,
 *   removeAll, retainAll, and operators +, +=, -, -=, *, *=
 * - added addAll method
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/10/13
 * - nulled out pointer fields in destructor after deletion to avoid double-free
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * - fixed bug where string quotes would not show when map was printed
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added add() method as synonym for put()
 * - added template hashCode function
 * @version 2014/10/10
 * - removed usage of __foreach macro
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _map_h
#define _map_h

#include <cstdlib>
#include <initializer_list>
#include <utility>
#include <type_traits>
#include <map>
#include <functional>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Map<KeyType,ValueType>
 * -----------------------------
 * This class maintains an association between <b><i>keys</i></b> and
 * <b><i>values</i></b>.  The types used for keys and values are
 * specified using templates, which makes it possible to use
 * this structure with any data type.
 */
template <typename KeyType, typename ValueType>
class Map {
public:
    /*
     * Constructor: Map
     * Usage: Map<KeyType,ValueType> map;
     * ----------------------------------
     * Initializes a new empty map that associates keys and values of the
     * specified types.
     */
    Map();

    /*
     * Constructor: Map
     * Usage: Map<KeyType,ValueType> map(lessFunc);
     * --------------------------------------------
     * Initializes a new empty map that associates keys and values of the
     * specified types, using the given "less-than" comparison function
     * to order any keys that will be later added to it.
     * The function can accept the two keys to compare either by value
     * or by const reference.
     */
    Map(std::function<bool (const KeyType&, const KeyType&)> lessFunc);

    /*
     * Constructor: Map
     * Usage: Map<ValueType> map {{"a", 1}, {"b", 2}, {"c", 3}};
     * ---------------------------------------------------------
     * Initializes a new map that stores the given pairs.
     * Note that the pairs are stored in key-sorted order internally and not
     * necessarily the order in which they are written in the initializer list.
     */
    Map(std::initializer_list<std::pair<const KeyType, ValueType>> list);

    /*
     * Constructor: Map
     * Usage: Map<ValueType> map({{"a", 1}, {"b", 2}, {"c", 3}}, lessFunc);
     * --------------------------------------------------------------------
     * Initializes a new empty map that associates keys and values of the
     * specified types, using the given "less-than" comparison function
     * to order any keys that will be later added to it.
     * The function can accept the two keys to compare either by value
     * or by const reference.
     */
    Map(std::initializer_list<std::pair<const KeyType, ValueType>> list,
        std::function<bool (const KeyType&, const KeyType&)> lessFunc);

    /*
     * Destructor: ~Map
     * ----------------
     * Frees any heap storage associated with this map.
     */
    virtual ~Map() = default;
    
    /*
     * Method: add
     * Usage: map.add(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * A synonym for the put method.
     */
    void add(const KeyType& key, const ValueType& value);

    /*
     * Method: addAll
     * Usage: map.addAll(map2);
     * ------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     * Identical in behavior to putAll.
     */
    Map& addAll(const Map& map2);

    /*
     * Method: back
     * Usage: KeyType value = map.back();
     * ------------------------------------
     * Returns the last key in the map in the order established by the
     * <code>foreach</code> macro.  If the map is empty, generates an error.
     */
    KeyType back() const;

    /*
     * Method: clear
     * Usage: map.clear();
     * -------------------
     * Removes all entries from this map.
     */
    void clear();
    
    /*
     * Method: containsKey
     * Usage: if (map.containsKey(key)) ...
     * ------------------------------------
     * Returns <code>true</code> if there is an entry for <code>key</code>
     * in this map.
     */
    bool containsKey(const KeyType& key) const;

    /*
     * Method: equals
     * Usage: if (map.equals(map2)) ...
     * --------------------------------
     * Returns <code>true</code> if the two maps contain exactly the same
     * key/value pairs, and <code>false</code> otherwise.
     */
    bool equals(const Map& map2) const;

    /*
     * Method: front
     * Usage: KeyType value = map.front();
     * -------------------------------------
     * Returns the first key in the map in the order established by the
     * <code>foreach</code> macro.  If the map is empty, generates an error.
     */
    KeyType front() const;

    /*
     * Method: get
     * Usage: ValueType value = map.get(key);
     * --------------------------------------
     * Returns the value associated with <code>key</code> in this map.
     * If <code>key</code> is not found, <code>get</code> returns the
     * default value for <code>ValueType</code>.
     */
    ValueType get(const KeyType& key) const;

    /*
     * Method: isEmpty
     * Usage: if (map.isEmpty()) ...
     * -----------------------------
     * Returns <code>true</code> if this map contains no entries.
     */
    bool isEmpty() const;
    
    /*
     * Method: keys
     * Usage: Vector<KeyType> keys = map.keys();
     * -----------------------------------------
     * Returns a collection containing all keys in this map.
     * Note that this implementation makes a deep copy of the keys,
     * so it is inefficient to call on large maps.
     */
    Vector<KeyType> keys() const;
    
    /*
     * Method: mapAll
     * Usage: map.mapAll(fn);
     * ----------------------
     * Iterates through the map entries and calls <code>fn(key, value)</code>
     * for each one.  The keys are processed in ascending order, as defined
     * by the comparison function.
     */
    void mapAll(std::function<void (const KeyType&, const ValueType&)> fn) const;

    /*
     * Method: put
     * Usage: map.put(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * Any previous value associated with <code>key</code> is replaced
     * by the new value.
     */
    void put(const KeyType& key, const ValueType& value);

    /*
     * Method: putAll
     * Usage: map.putAll(map2);
     * ------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     * Identical in behavior to addAll.
     */
    Map& putAll(const Map& map2);

    /*
     * Method: remove
     * Usage: map.remove(key);
     * -----------------------
     * Removes any entry for <code>key</code> from this map.
     */
    void remove(const KeyType& key);

    /*
     * Method: removeAll
     * Usage: map.removeAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will not be removed.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     */
    Map& removeAll(const Map& map2);

    /*
     * Method: retainAll
     * Usage: map.retainAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are not contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will be removed.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     */
    Map& retainAll(const Map& map2);

    /*
     * Method: size
     * Usage: int nEntries = map.size();
     * ---------------------------------
     * Returns the number of entries in this map.
     */
    int size() const;
    
    /*
     * Method: toString
     * Usage: string str = map.toString();
     * -----------------------------------
     * Converts the map to a printable string representation.
     */
    std::string toString() const;

    /*
     * Method: values
     * Usage: Vector<ValueType> values = map.values();
     * -----------------------------------------------
     * Returns a collection containing all values in this map.
     * Note that this implementation makes a deep copy of the values,
     * so it is inefficient to call on large maps.
     */
    Vector<ValueType> values() const;

    /*
     * Operator: []
     * Usage: map[key]
     * ---------------
     * Selects the value associated with <code>key</code>.  This syntax
     * makes it easy to think of a map as an "associative array"
     * indexed by the key type.  If <code>key</code> is already present
     * in the map, this function returns a reference to its associated
     * value.  If key is not present in the map, a new entry is created
     * whose value is set to the default for the value type.
     */
    ValueType& operator [](const KeyType& key);
    ValueType operator [](const KeyType& key) const;

    /*
     * Operator: ==
     * Usage: if (map1 == map2) ...
     * ----------------------------
     * Compares two maps for equality.
     */
    bool operator ==(const Map& map2) const;

    /*
     * Operator: !=
     * Usage: if (map1 != map2) ...
     * ----------------------------
     * Compares two maps for inequality.
     */
    bool operator !=(const Map& map2) const;

    /*
     * Operators: <, <=, >, >=
     * Usage: if (map1 < map2) ...
     * ---------------------------
     * Relational operators to compare two maps.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const Map& map2) const;
    bool operator <=(const Map& map2) const;
    bool operator >(const Map& map2) const;
    bool operator >=(const Map& map2) const;

    /*
     * Operator: +
     * Usage: map1 + map2
     * ------------------
     * Returns the union of the two maps, equivalent to a copy of the first map
     * with addAll called on it passing the second map as a parameter.
     * If the two maps both contain a mapping for the same key, the mapping
     * from the second map is favored.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map operator +(const Map& map2) const;

    /*
     * Operator: +=
     * Usage: map1 += map2;
     * --------------------
     * Adds all key/value pairs from the given map to this map.
     * Equivalent to calling addAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map& operator +=(const Map& map2);

    /*
     * Operator: -
     * Usage: map1 - map2
     * ------------------
     * Returns the difference of the two maps, equivalent to a copy of the first map
     * with removeAll called on it passing the second map as a parameter.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map operator -(const Map& map2) const;

    /*
     * Operator: -=
     * Usage: map1 -= map2;
     * --------------------
     * Removes all key/value pairs from the given map to this map.
     * Equivalent to calling removeAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map& operator -=(const Map& map2);

    /*
     * Operator: *
     * Usage: map1 * map2
     * ------------------
     * Returns the intersection of the two maps, equivalent to a copy of the first map
     * with retainAll called on it passing the second map as a parameter.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map operator *(const Map& map2) const;

    /*
     * Operator: *=
     * Usage: map1 *= map2;
     * ---------------------
     * Removes all key/value pairs that are not found in the given map from this map.
     * Equivalent to calling retainAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    Map& operator *=(const Map& map2);

    /*
     * Additional Map operations
     * -------------------------
     * In addition to the methods listed in this interface, the Map
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * All iteration is guaranteed to proceed in the order established by
     * the comparison function passed to the constructor, which ordinarily
     * matches the order of the key type.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    using MapType = std::map<KeyType, ValueType, std::function<bool(const KeyType&, const KeyType&)>>;
    MapType _elements;
    stanfordcpplib::collections::VersionTracker _version;

public:
    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods in
     * the public portion of the interface would make that interface more
     * difficult to understand for the average client.
     */

    using const_iterator = stanfordcpplib::collections::ProjectingIterator<stanfordcpplib::collections::CheckedIterator<typename MapType::const_iterator>>;
    using iterator = const_iterator;

    const_iterator begin() const;
    const_iterator end() const;
};

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::Map() : _elements(stanfordcpplib::collections::checkedLess<KeyType>()) {
    // Handled in initializer
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::Map(std::function<bool(const KeyType&, const KeyType&)> lessFunc)
        : _elements(lessFunc) {
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::Map(std::initializer_list<std::pair<const KeyType, ValueType>> list)
        : _elements(list, stanfordcpplib::collections::checkedLess<KeyType>()) {
    // Handled in initializer
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>::Map(std::initializer_list<std::pair<const KeyType, ValueType>> list,
                             std::function<bool(const KeyType&, const KeyType&)> lessFunc)
        : _elements(list, lessFunc) {
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::add(const KeyType& key,
                                  const ValueType& value) {
    put(key, value);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::addAll(const Map& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
KeyType Map<KeyType, ValueType>::back() const {
    if (isEmpty()) {
        error("Map::back: map is empty");
    }
    return _elements.rbegin()->first;
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::clear() {
    _elements.clear();
    _version.update();
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::containsKey(const KeyType& key) const {
    return !!_elements.count(key);
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::equals(const Map<KeyType, ValueType>& map2) const {
    return stanfordcpplib::collections::equalsMap(*this, map2);
}

template <typename KeyType, typename ValueType>
KeyType Map<KeyType, ValueType>::front() const {
    if (isEmpty()) {
        error("Map::front: map is empty");
    }
    return _elements.begin()->first;
}

template <typename KeyType, typename ValueType>
ValueType Map<KeyType, ValueType>::get(const KeyType& key) const {
    auto itr = _elements.find(key);
    return itr == _elements.end()? ValueType() : itr->second;
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::isEmpty() const {
    return _elements.empty();
}

template <typename KeyType,typename ValueType>
Vector<KeyType> Map<KeyType, ValueType>::keys() const {
    Vector<KeyType> keyset;
    for (const auto& entry: _elements) {
        keyset.add(entry.first);
    }
    return keyset;
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::mapAll(std::function<void (const KeyType&, const ValueType&)> fn) const {
    for (const auto& entry: _elements) {
        fn(entry.first, entry.second);
    }
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::put(const KeyType& key,
                                  const ValueType& value) {
    int presize = size();
    _elements[key] = value;
    if (presize != size()) _version.update();
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::putAll(const Map& map2) {
    for (const KeyType& key : map2) {
        put(key, map2.get(key));
    }
    return *this;
}

template <typename KeyType, typename ValueType>
void Map<KeyType, ValueType>::remove(const KeyType& key) {
    _elements.erase(key);
    _version.update();
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::removeAll(const Map& map2) {
    for (const KeyType& key : map2) {
        if (containsKey(key) && get(key) == map2.get(key)) {
            remove(key);
        }
    }
    return *this;
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::retainAll(const Map& map2) {
    Vector<KeyType> toRemove;
    for (const KeyType& key : *this) {
        if (!map2.containsKey(key) || get(key) != map2.get(key)) {
            toRemove.add(key);
        }
    }
    for (const KeyType& key : toRemove) {
        remove(key);
    }
    return *this;
}

template <typename KeyType, typename ValueType>
int Map<KeyType, ValueType>::size() const {
    return _elements.size();
}

template <typename KeyType, typename ValueType>
std::string Map<KeyType, ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename KeyType,typename ValueType>
Vector<ValueType> Map<KeyType, ValueType>::values() const {
    Vector<ValueType> values;
    for (const auto& entry: _elements) {
        values.add(entry.second);
    }
    return values;
}

template <typename KeyType, typename ValueType>
ValueType& Map<KeyType, ValueType>::operator [](const KeyType& key) {
    auto presize = size();
    auto& result = _elements[key];

    /* If the size was updated, we must have inserted something. */
    if (presize != size()) _version.update();
    return result;
}

template <typename KeyType, typename ValueType>
ValueType Map<KeyType, ValueType>::operator [](const KeyType& key) const {
    return get(key);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType> Map<KeyType, ValueType>::operator +(const Map& map2) const {
    Map<KeyType, ValueType> result = *this;
    return result.putAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::operator +=(const Map& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType> Map<KeyType, ValueType>::operator -(const Map& map2) const {
    Map<KeyType, ValueType> result = *this;
    return result.removeAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::operator -=(const Map& map2) {
    return removeAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType> Map<KeyType, ValueType>::operator *(const Map& map2) const {
    Map<KeyType, ValueType> result = *this;
    return result.retainAll(map2);
}

template <typename KeyType, typename ValueType>
Map<KeyType, ValueType>& Map<KeyType, ValueType>::operator *=(const Map& map2) {
    return retainAll(map2);
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator ==(const Map& map2) const {
    return equals(map2);
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator !=(const Map& map2) const {
    return !equals(map2);   // BUGFIX 2016/01/27, thanks to O. Zeng
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator <(const Map& map2) const {
    return stanfordcpplib::collections::compareMaps(*this, map2) < 0;
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator <=(const Map& map2) const {
    return stanfordcpplib::collections::compareMaps(*this, map2) <= 0;
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator >(const Map& map2) const {
    return stanfordcpplib::collections::compareMaps(*this, map2) > 0;
}

template <typename KeyType, typename ValueType>
bool Map<KeyType, ValueType>::operator >=(const Map& map2) const {
    return stanfordcpplib::collections::compareMaps(*this, map2) >= 0;
}

template <typename KeyType, typename ValueType>
typename Map<KeyType, ValueType>::iterator Map<KeyType, ValueType>::begin() const {
    return iterator({ &_version, _elements.begin(), _elements });
}

template <typename KeyType, typename ValueType>
typename Map<KeyType, ValueType>::iterator Map<KeyType, ValueType>::end() const {
    return iterator({ &_version, _elements.end(), _elements });
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename KeyType, typename ValueType>
std::ostream& operator <<(std::ostream& os,
                          const Map<KeyType, ValueType>& map) {
    return stanfordcpplib::collections::writeMap(os, map);
}

template <typename KeyType, typename ValueType>
std::istream& operator >>(std::istream& is, Map<KeyType,ValueType>& map) {
    KeyType key;
    ValueType value;
    return stanfordcpplib::collections::readMap(is, map, key, value, /* descriptor */ std::string("Map::operator >>"));
}

/*
 * Template hash function for maps.
 * Requires the key and value types in the Map to have a hashCode function.
 */
template <typename K, typename V>
int hashCode(const Map<K, V>& map) {
    return stanfordcpplib::collections::hashCodeMap(map);
}

/*
 * Function: randomKey
 * Usage: element = randomKey(map);
 * --------------------------------
 * Returns a randomly chosen key of the given map.
 * Throws an error if the map is empty.
 */
template <typename K, typename V>
const K& randomKey(const Map<K, V>& map) {
    return stanfordcpplib::collections::randomElement(map);
}

#endif // _map_h

/////////////////////// END code extracted from StanfordCPPLib/collections/map.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/set.h ///////////////////////
/*
 * File: set.h
 * -----------
 * This file exports the <code>Set</code> class, which implements a
 * collection for storing a set of distinct elements.
 * 
 * @version 2019/02/04
 * - changed internal implementation to wrap std collections
 * @version 2018/03/19
 * - added constructors that accept a comparison function
 * @version 2018/03/10
 * - added methods front, back
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via Map)
 * @version 2016/12/06
 * - slight speedup bug fix in equals() method
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/11
 * - added containsAll, isSupersetOf methods
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as {1, 2, 3}
 *   in constructor, addAll, containsAll, isSubsetOf, isSupersetOf, removeAll,
 *   retainAll, and operators +, +=, -, -=, *, *=
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 * @version 2014/10/10
 * - removed use of __foreach macro
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _set_h
#define _set_h

#include <initializer_list>
#include <iostream>
#include <set>
#include <functional>
#include <type_traits>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/* Traits type for the Set, which wraps an underlying Map. */
namespace stanfordcpplib {
    namespace collections {
        template <typename T> struct SetTraits {
            using ValueType = T;
            using MapType   = Map<T, bool>;
            static std::string name() {
                return "Set";
            }

            /* The Set type does allow you to construct the underlying Map by handing
             * along a std::function.
             */
            template <typename Function>
            static MapType construct(Function comparator) {
                static_assert(std::is_assignable<std::function<bool(const ValueType&, const ValueType&)>, Function>::value,
                              "Oops! Seems like you tried to initialize a Set incorrectly. Click here for details.");
                /*
                 * Hello student! If you are reading this message, it means that you tried to
                 * initialize a Set improperly. For example, you might have tried to write
                 * something like this:
                 *
                 *     Set<int> mySet = 137; // Oops!
                 *
                 * Here, for example, you're trying to assign an int to a Set<int>.
                 *
                 * or perhaps you had a function like this one:
                 *
                 *     void myFunction(Set<int>& mySet);
                 *
                 * and you called it by writing
                 *
                 *     myFunction(someSet + someOtherSet); // Oops!
                 *     myFunction({ });                    // Oops!
                 *
                 * In these cases, you're trying to pass a value into a function that takes
                 * its argument by (non-const) reference. C++ doesn't allow you to do this.
                 *
                 * To see where the actual error comes from, look in the list of error messages
                 * in Qt Creator. You should see a line that says "required from here" that
                 * points somewhere in your code. That's the actual line you wrote that caused
                 * the problem, so double-click on that error message and see where it takes
                 * you. Now you know where to look!
                 *
                 * Hope this helps!
                 */
                return MapType(comparator);
            }

            /* You can also default-construct it. */
            static MapType construct() {
                return {};
            }

            /* However, you can't pass in any other arguments. */
            template <typename... Args>
            static void construct(MapType &, Args&&...) {
                static_assert(Fail<Args...>::value, "Oops! Seems like you tried to initialize a Set incorrectly. Click here for details.");

                /*
                 * Hello student! If you are reading this message, it means that you tried to
                 * initialize a Set improperly. For example, you might have tried to write
                 * something like this:
                 *
                 *     Set<int> mySet = 137; // Oops!
                 *
                 * Here, for example, you're trying to assign an int to a Set<int>.
                 *
                 * or perhaps you had a function like this one:
                 *
                 *     void myFunction(Set<int>& mySet);
                 *
                 * and you called it by writing
                 *
                 *     myFunction(someSet + someOtherSet); // Oops!
                 *     myFunction({ });                    // Oops!
                 *
                 * In these cases, you're trying to pass a value into a function that takes
                 * its argument by (non-const) reference. C++ doesn't allow you to do this.
                 *
                 * To see where the actual error comes from, look in the list of error messages
                 * in Qt Creator. You should see a line that says "required from here" that
                 * points somewhere in your code. That's the actual line you wrote that caused
                 * the problem, so double-click on that error message and see where it takes
                 * you. Now you know where to look!
                 *
                 * Hope this helps!
                 */
                error("static_assert failed?");
            }
        };
    }
}

/*
 * A set of elements stored in sorted order. The elements must be comparable
 * using the < operator in order to be stored here.
 */
template <typename ValueType>
    using Set = stanfordcpplib::collections::GenericSet<stanfordcpplib::collections::SetTraits<ValueType>>;

#endif // _set_h

/////////////////////// END code extracted from StanfordCPPLib/collections/set.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/hashmap.h ///////////////////////
/*
 * File: hashmap.h
 * ---------------
 * This file exports the <code>HashMap</code> class, which stores
 * a set of <i>key</i>-<i>value</i> pairs.
 * 
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2019/02/04
 * - changed internal implementation to wrap std collections
 * @version 2018/03/10
 * - added methods front, back
 * @version 2017/11/30
 * - bug fix for iterator version checking support
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2016/10/14
 * - modified floating-point equality tests to use floatingPointEqual function
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as
 *   {{"a", 1}, {"b", 2}, {"c", 3}} in constructor, putAll, removeAll, retainAll,
 *   operators +, +=, -, -=, *, *=
 * - added addAll method
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * - fixed bug where string quotes would not show when map was printed
 * @version 2015/06/19
 * - fixed deepCopy code that was causing copies to have different hash code than
 *   the original they were copied from (credit to SL Wen Zhang for finding the bug)
 * @version 2014/11/13
 * - added add() method as synonym for put()
 * - added template hashCode function
 * - moved hashCode functions to hashcode.h/cpp
 * @version 2014/10/29
 * - moved hashCode functions out to hashcode.h
 * @version 2014/10/10
 * - added comparison operators ==, !=
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _hashmap_h
#define _hashmap_h

#include <cstdlib>
#include <initializer_list>
#include <string>
#include <utility>
#include <unordered_map>
#include <functional>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: HashMap<KeyType,ValueType>
 * ---------------------------------
 * This class implements an efficient association between
 * <b><i>keys</i></b> and <b><i>values</i></b>.  This class is
 * identical to the <a href="Map-class.html"><code>Map</code></a> class
 * except for the fact that it uses a hash table as its underlying
 * representation.  Although the <code>HashMap</code> class operates in
 * constant time, the iterator for <code>HashMap</code> returns the
 * values in a seemingly random order.
 */
template <typename KeyType, typename ValueType>
class HashMap {
public:
    /*
     * Constructor: HashMap
     * Usage: HashMap<KeyType,ValueType> map;
     * --------------------------------------
     * Initializes a new empty map that associates keys and values of
     * the specified types.  The type used for the key must define
     * the <code>==</code> operator, and there must be a free function
     * with the following signature:
     *
     *<pre>
     *    int hashCode(KeyType key);
     *</pre>
     *
     * that returns a positive integer determined by the key.  This interface
     * exports <code>hashCode</code> functions for <code>string</code> and
     * the C++ primitive types.
     */
    HashMap() = default;

    /*
     * Constructor: HashMap
     * Usage: HashMap<ValueType> map {{"a", 1}, {"b", 2}, {"c", 3}};
     * -------------------------------------------------------------
     * Initializes a new map that stores the given pairs.
     * Note that the pairs are stored in unpredictable order internally and not
     * necessarily the order in which they are written in the initializer list.
     */
    HashMap(std::initializer_list<std::pair<const KeyType, ValueType>> list);

    /*
     * Destructor: ~HashMap
     * --------------------
     * Frees any heap storage associated with this map.
     */
    virtual ~HashMap() = default;

    /*
     * Method: add
     * Usage: map.add(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * A synonym for the put method.
     */
    void add(const KeyType& key, const ValueType& value);

    /*
     * Method: addAll
     * Usage: map.addAll(map2);
     * ------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     * Identical in behavior to putAll.
     */
    HashMap& addAll(const HashMap& map2);

    /*
     * Method: back
     * Usage: KeyType value = map.back();
     * ----------------------------------
     * Returns the last key in the map in the order established by the
     * <code>foreach</code> macro.
     * Note that since the keys are stored in an unpredictable order,
     * this is not necessarily equal to the "largest" key value in any particular
     * sorting order; it is just the key that would happen to be emitted last
     * from a for-each loop.
     * If the map is empty, generates an error.
     */
    KeyType back() const;

    /*
     * Method: clear
     * Usage: map.clear();
     * -------------------
     * Removes all entries from this map.
     */
    void clear();

    /*
     * Method: containsKey
     * Usage: if (map.containsKey(key)) ...
     * ------------------------------------
     * Returns <code>true</code> if there is an entry for <code>key</code>
     * in this map.
     */
    bool containsKey(const KeyType& key) const;

    /*
     * Method: equals
     * Usage: if (map.equals(map2)) ...
     * --------------------------------
     * Returns <code>true</code> if the two maps contain exactly the same
     * key/value pairs, and <code>false</code> otherwise.
     */
    bool equals(const HashMap& map2) const;

    /*
     * Method: front
     * Usage: KeyType value = map.front();
     * -----------------------------------
     * Returns the first key in the map in the order established by the
     * <code>foreach</code> macro.
     * Note that since the keys are stored in an unpredictable order,
     * this is not necessarily equal to the "smallest" key value in any particular
     * sorting order; it is just the key that would happen to be emitted first
     * from a for-each loop.
     * If the map is empty, generates an error.
     */
    KeyType front() const;

    /*
     * Method: get
     * Usage: ValueType value = map.get(key);
     * --------------------------------------
     * Returns the value associated with <code>key</code> in this map.
     * If <code>key</code> is not found, <code>get</code> returns the
     * default value for <code>ValueType</code>.
     */
    ValueType get(const KeyType& key) const;

    /*
     * Method: isEmpty
     * Usage: if (map.isEmpty()) ...
     * -----------------------------
     * Returns <code>true</code> if this map contains no entries.
     */
    bool isEmpty() const;
    
    /*
     * Method: keys
     * Usage: Vector<KeyType> keys = map.keys();
     * -----------------------------------------
     * Returns a collection containing all keys in this map.
     * Note that this implementation makes a deep copy of the keys,
     * so it is inefficient to call on large maps.
     */
    Vector<KeyType> keys() const;

    /*
     * Method: mapAll
     * Usage: map.mapAll(fn);
     * ----------------------
     * Iterates through the map entries and calls <code>fn(key, value)</code>
     * for each one.  The keys are processed in an undetermined order.
     */
    void mapAll(std::function<void(const KeyType&, const ValueType&)> fn) const;

    /*
     * Method: put
     * Usage: map.put(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * Any previous value associated with <code>key</code> is replaced
     * by the new value.
     */
    void put(const KeyType& key, const ValueType& value);

    /*
     * Method: putAll
     * Usage: map.putAll(map2);
     * ---------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     */
    HashMap& putAll(const HashMap& map2);

    /*
     * Method: remove
     * Usage: map.remove(key);
     * -----------------------
     * Removes any entry for <code>key</code> from this map.
     * If the given key is not found, has no effect.
     */
    void remove(const KeyType& key);

    /*
     * Method: removeAll
     * Usage: map.removeAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will not be removed.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     */
    HashMap& removeAll(const HashMap& map2);

    /*
     * Method: retainAll
     * Usage: map.retainAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are not contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will be removed.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     */
    HashMap& retainAll(const HashMap& map2);

    /*
     * Method: size
     * Usage: int nEntries = map.size();
     * ---------------------------------
     * Returns the number of entries in this map.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = map.toString();
     * -----------------------------------
     * Converts the map to a printable string representation.
     */
    std::string toString() const;

    /*
     * Method: values
     * Usage: Vector<ValueType> values = map.values();
     * -----------------------------------------------
     * Returns a collection containing all values in this map.
     * Note that this implementation makes a deep copy of the values,
     * so it is inefficient to call on large maps.
     */
    Vector<ValueType> values() const;

    /*
     * Operator: []
     * Usage: map[key]
     * ---------------
     * Selects the value associated with <code>key</code>.  This syntax
     * makes it easy to think of a map as an "associative array"
     * indexed by the key type.  If <code>key</code> is already present
     * in the map, this function returns a reference to its associated
     * value.  If key is not present in the map, a new entry is created
     * whose value is set to the default for the value type.
     */
    ValueType& operator [](const KeyType& key);
    ValueType operator [](const KeyType& key) const;

    /*
     * Operator: +
     * Usage: map1 + map2
     * ------------------
     * Returns the union of the two maps, equivalent to a copy of the first map
     * with addAll called on it passing the second map as a parameter.
     * If the two maps both contain a mapping for the same key, the mapping
     * from the second map is favored.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap operator +(const HashMap& map2) const;

    /*
     * Operator: +=
     * Usage: map1 += map2;
     * --------------------
     * Adds all key/value pairs from the given map to this map.
     * Equivalent to calling addAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap& operator +=(const HashMap& map2);

    /*
     * Operator: -
     * Usage: map1 - map2
     * ------------------
     * Returns the difference of the two maps, equivalent to a copy of the first map
     * with removeAll called on it passing the second map as a parameter.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap operator -(const HashMap& map2) const;

    /*
     * Operator: -=
     * Usage: map1 -= map2;
     * --------------------
     * Removes all key/value pairs from the given map to this map.
     * Equivalent to calling removeAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap& operator -=(const HashMap& map2);

    /*
     * Operator: *
     * Usage: map1 * map2
     * ------------------
     * Returns the intersection of the two maps, equivalent to a copy of the first map
     * with retainAll called on it passing the second map as a parameter.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap operator *(const HashMap& map2) const;

    /*
     * Operator: *=
     * Usage: map1 *= map2;
     * ---------------------
     * Removes all key/value pairs that are not found in the given map from this map.
     * Equivalent to calling retainAll(map2).
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     */
    HashMap& operator *=(const HashMap& map2);

    /*
     * Additional HashMap operations
     * -----------------------------
     * In addition to the methods listed in this interface, the HashMap
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * The HashMap class makes no guarantees about the order of iteration.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    static_assert(stanfordcpplib::collections::IsHashable<KeyType>::value,
                  "Oops! You tried using a type as a key in our HashMap without making it hashable. Click this error for more details.");
    /*
     * Hello CS106 students! If you got directed to this line of code in a compiler error,
     * it probably means that you tried making a HashMap with a custom struct or class type
     * as the key type or a HashSet with a custom struct as a value type. (The same also
     * applies for LinkedHashMap and LinkedHashSet.)
     *
     * In order to have a type be a key type in a HashMap - or to have a type be a value type
     * in a HashSet - it needs to have a hashCode function defined and be capable of being
     * compared using the == operator. If you were directed here, one of those two conditions
     * wasn't met.
     *
     * There are two ways to fix this. The first option would simply be to not use your custom
     * type as a key in the HashMap or value in a HashSet. This is probably the easiest option.
     *
     * The second way to fix this is to explicitly define a hashCode() and operator== function
     * for your type. To do so, first define hashCode as follows:
     *
     *     int hashCode(const YourCustomType& obj) {
     *         return hashCode(obj.data1, obj.data2, ..., obj.dataN);
     *     }
     *
     * where data1, data2, ... dataN are the data members of your type. For example, if you had
     * a custom type
     *
     *     struct MyType {
     *         int myInt;
     *         string myString;
     *     };
     *
     * you would define the function
     *
     *     int hashCode(const MyType& obj) {
     *         return hashCode(obj.myInt, obj.myString);
     *     }
     *
     * Second, define operator== as follows:
     *
     *     bool operator== (const YourCustomType& lhs, const YourCustomType& rhs) {
     *         return lhs.data1 == rhs.data1 &&
     *                lhs.data2 == rhs.data2 &&
     *                         ...
     *                lhs.dataN == rhs.dataN;
     *     }
     *
     * Using the MyType example from above, we'd write
     *
     *     bool operator== (const MyType& lhs, const MyType& rhs) {
     *         return lhs.myInt == rhs.myInt && lhs.myString == rhs.myString;
     *     }
     *
     * Hope this helps!
     */

    struct Hasher {
        std::size_t operator()(const KeyType& key) const {
            return hashCode(key);
        }
    };

    std::unordered_map<KeyType, ValueType, Hasher> _elements;
    stanfordcpplib::collections::VersionTracker _version;

    /* Private methods */

public:
    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

    /*
     * Iterator support
     */

    using const_iterator = stanfordcpplib::collections::ProjectingIterator<stanfordcpplib::collections::CheckedIterator<typename std::unordered_map<KeyType, ValueType, Hasher>::const_iterator>>;
    using iterator = const_iterator;

    iterator begin() const;
    iterator end() const;

    /*
     * Hashing support.
     */
    bool operator== (const HashMap& rhs) const;
    bool operator!= (const HashMap& rhs) const;

    template <typename K, typename V>
    friend int hashCode(const HashMap<K, V>& map);
};

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>::HashMap(std::initializer_list<std::pair<const KeyType, ValueType>> list)
        : _elements(list) {
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::add(const KeyType& key, const ValueType& value) {
    put(key, value);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::addAll(const HashMap& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
KeyType HashMap<KeyType, ValueType>::back() const {
    if (isEmpty()) {
        error("HashMap::back: map is empty");
    }

    return std::next(_elements.begin(), _elements.size() - 1)->first;
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::clear() {
    _elements.clear();
    _version.update();
}

template <typename KeyType, typename ValueType>
bool HashMap<KeyType, ValueType>::containsKey(const KeyType& key) const {
    return !!_elements.count(key);
}

template <typename KeyType, typename ValueType>
bool HashMap<KeyType, ValueType>::equals(const HashMap<KeyType, ValueType>& map2) const {
    return stanfordcpplib::collections::equalsMap(*this, map2);
}

template <typename KeyType, typename ValueType>
KeyType HashMap<KeyType, ValueType>::front() const {
    if (isEmpty()) {
        error("HashMap::front: map is empty");
    }
    return *begin();
}

template <typename KeyType, typename ValueType>
ValueType HashMap<KeyType, ValueType>::get(const KeyType& key) const {
    auto itr = _elements.find(key);
    return itr == _elements.end()? ValueType() : itr->second;
}

template <typename KeyType, typename ValueType>
bool HashMap<KeyType, ValueType>::isEmpty() const {
    return _elements.empty();
}

template <typename KeyType, typename ValueType>
Vector<KeyType> HashMap<KeyType, ValueType>::keys() const {
    Vector<KeyType> keyset;
    for (const auto& entry: _elements) {
        keyset.add(entry.first);
    }
    return keyset;
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::mapAll(std::function<void (const KeyType&, const ValueType&)> fn) const {
    for (const auto& entry: _elements) {
        fn(entry.first, entry.second);
    }
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::put(const KeyType& key, const ValueType& value) {
    int presize = size();
    _elements[key] = value;

    if (presize != size()) _version.update();
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::putAll(const HashMap& map2) {
    for (const KeyType& key : map2) {
        put(key, map2.get(key));
    }
    return *this;
}

template <typename KeyType, typename ValueType>
void HashMap<KeyType, ValueType>::remove(const KeyType& key) {
    auto itr = _elements.find(key);
    if (itr != _elements.end()) {
        _elements.erase(itr);
        _version.update();
    }
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::removeAll(const HashMap& map2) {
    for (const KeyType& key : map2) {
        if (containsKey(key) && get(key) == map2.get(key)) {
            remove(key);
        }
    }
    return *this;
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::retainAll(const HashMap& map2) {
    Vector<KeyType> toRemove;
    for (const KeyType& key : *this) {
        if (!map2.containsKey(key) || get(key) != map2.get(key)) {
            toRemove.add(key);
        }
    }
    for (const KeyType& key : toRemove) {
        remove(key);
    }
    return *this;
}

template <typename KeyType, typename ValueType>
int HashMap<KeyType, ValueType>::size() const {
    return _elements.size();
}

template <typename KeyType, typename ValueType>
std::string HashMap<KeyType, ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename KeyType, typename ValueType>
Vector<ValueType> HashMap<KeyType, ValueType>::values() const {
    Vector<ValueType> values;
    for (const auto& entry: _elements) {
        values.add(entry.second);
    }
    return values;
}

template <typename KeyType, typename ValueType>
ValueType& HashMap<KeyType, ValueType>::operator [](const KeyType& key) {
    int presize = size();
    ValueType& result = _elements[key];

    if (presize != size()) _version.update();
    return result;
}

template <typename KeyType, typename ValueType>
ValueType HashMap<KeyType, ValueType>::operator [](const KeyType& key) const {
    return get(key);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType> HashMap<KeyType, ValueType>::operator +(const HashMap& map2) const {
    HashMap<KeyType, ValueType> result = *this;
    return result.putAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::operator +=(const HashMap& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType> HashMap<KeyType, ValueType>::operator -(const HashMap& map2) const {
    HashMap<KeyType, ValueType> result = *this;
    return result.removeAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::operator -=(const HashMap& map2) {
    return removeAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType> HashMap<KeyType, ValueType>::operator *(const HashMap& map2) const {
    HashMap<KeyType, ValueType> result = *this;
    return result.retainAll(map2);
}

template <typename KeyType, typename ValueType>
HashMap<KeyType, ValueType>& HashMap<KeyType, ValueType>::operator *=(const HashMap& map2) {
    return retainAll(map2);
}

template <typename KeyType, typename ValueType>
typename HashMap<KeyType, ValueType>::iterator HashMap<KeyType, ValueType>::begin() const {
    return iterator({ &_version, _elements.begin(), _elements });
}

template <typename KeyType, typename ValueType>
typename HashMap<KeyType, ValueType>::iterator HashMap<KeyType, ValueType>::end() const {
    return iterator({ &_version, _elements.end(), _elements });
}

template <typename KeyType, typename ValueType>
bool HashMap<KeyType, ValueType>::operator == (const HashMap<KeyType, ValueType>& rhs) const {
    return stanfordcpplib::collections::equalsMap(*this, rhs);
}

template <typename KeyType, typename ValueType>
bool HashMap<KeyType, ValueType>::operator != (const HashMap<KeyType, ValueType>& rhs) const {
    return !(*this == rhs);
}

template <typename KeyType, typename ValueType>
int hashCode(const HashMap<KeyType, ValueType>& map) {
    return stanfordcpplib::collections::hashCodeMap(map, false);
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename KeyType, typename ValueType>
std::ostream& operator <<(std::ostream& os,
                          const HashMap<KeyType, ValueType>& map) {
    return stanfordcpplib::collections::writeMap(os, map);
}

template <typename KeyType, typename ValueType>
std::istream& operator >>(std::istream& is,
                          HashMap<KeyType, ValueType>& map) {
    KeyType key;
    ValueType value;
    return stanfordcpplib::collections::readMap(is, map, key, value, /* descriptor */ std::string("HashMap::operator >>"));
}

/*
 * Function: randomKey
 * Usage: element = randomKey(map);
 * --------------------------------
 * Returns a randomly chosen key of the given map.
 * Throws an error if the map is empty.
 */
template <typename K, typename V>
const K& randomKey(const HashMap<K, V>& map) {
    return stanfordcpplib::collections::randomElement(map);
}

#endif // _hashmap_h

/////////////////////// END code extracted from StanfordCPPLib/collections/hashmap.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/hashset.h ///////////////////////
/*
 * File: hashset.h
 * ---------------
 * This file exports the <code>HashSet</code> class, which
 * implements an efficient abstraction for storing sets of values.
 * 
 * @version 2019/02/04
 * - changed internal implementation to wrap std collections
 * @version 2018/03/10
 * - added methods front, back
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via HashMap)
 * @version 2016/12/06
 * - slight speedup bug fix in equals() method
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/11
 * - added containsAll, isSupersetOf methods
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as {1, 2, 3}
 *   in constructor, addAll, containsAll, isSubsetOf, isSupersetOf, removeAll,
 *   retainAll, and operators +, +=, -, -=, *, *=
 * - bug fix in hashCode function
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added template hashCode function
 * @version 2014/10/10
 * - removed foreach patch
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _hashset_h
#define _hashset_h

#include <initializer_list>
#include <iostream>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/* Traits type for the HashSet, which wraps an underlying HashMap. */
namespace stanfordcpplib {
    namespace collections {
        template <typename T> struct HashSetTraits {
            using ValueType = T;
            using MapType   = HashMap<T, bool>;
            static std::string name() {
                return "HashSet";
            }
            /* You can default-construct a LinkedHashSet. */
            static MapType construct() {
                return {};
            }

            /* However, you can't pass in any other arguments. */
            template <typename... Args>
            static void construct(Args&&...) {
                static_assert(Fail<Args...>::value, "Oops! Seems like you tried to initialize a LinkedHashSet incorrectly. Click here for details.");

                /*
                 * Hello student! If you are reading this message, it means that you tried to
                 * initialize a HashSet improperly. For example, you might have tried to
                 * write something like this:
                 *
                 *     HashSet<int> mySet = 137; // Oops!
                 *
                 * Here, for example, you're trying to assign an int to a LinkedHashSet<int>.
                 *
                 * or perhaps you had a function like this one:
                 *
                 *     void myFunction(LinkedHashSet<int>& mySet);
                 *
                 * and you called it by writing
                 *
                 *     myFunction(someSet + someOtherSet); // Oops!
                 *     myFunction({ });                    // Oops!
                 *
                 * In these cases, you're trying to pass a value into a function that takes
                 * its argument by (non-const) reference. C++ doesn't allow you to do this.
                 *
                 * To see where the actual error comes from, look in the list of error messages
                 * in Qt Creator. You should see a line that says "required from here" that
                 * points somewhere in your code. That's the actual line you wrote that caused
                 * the problem, so double-click on that error message and see where it takes
                 * you. Now you know where to look!
                 *
                 * Hope this helps!
                 */
                error("static_assert succeeded?");
            }
        };
    }
}

/*
 * A set of elements stored in no particular order. Elements can only be stored here
 * if they support a function
 *
 *     int hashCode(ValueType);
 *
 * that returns a nonnegative integer, along with equality comparison using ==.
 */
template <typename ValueType>
    using HashSet = stanfordcpplib::collections::GenericSet<stanfordcpplib::collections::HashSetTraits<ValueType>>;

#endif // _hashset_h

/////////////////////// END code extracted from StanfordCPPLib/collections/hashset.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/graph.h ///////////////////////
/*
 * File: graph.h
 * -------------
 * This file exports a parameterized Graph class used to represent graphs,
 * which consist of a set of nodes (vertices) and a set of arcs (edges).
 * 
 * @version 2019/08/13
 * - fixed compiler error with Graph default constructor on older g++ compilers
 * @version 2018/09/07
 * - reformatted doc-style comments
 * @version 2018/03/10
 * - added methods front, back
 * - fixed compiler issue with getArcSet call
 * @version 2017/11/14
 * - added nodeCount, arcCount, getNodeNames
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via Map)
 * - fixed bug in getInverseNeighborNames function
 * @version 2016/12/01
 * - removed memory leaks of graph node and arc structures
 * - fixed bug in containsNode method (was returning false positives)
 * - fixed bugs in some node/arc methods (should not crash on empty/null args)
 * @version 2016/11/29
 * - added getNeighborNames, getInverseNeighborNames
 * @version 2016/11/26
 * - added getInverseArcSet
 * @version 2016/11/19
 * - changed addNode to not throw when adding duplicates
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added iterator begin(), end() support so that students can directly
 *   for-each over the vertices of a graph.
 * - added comparison operators ==, !=, <, etc.
 * - added template hashCode function
 * @version 2014/10/20
 * - converted functions to accept const string& rather than string for speed
 * - added iterator/for-each support over nodes; begin() / end() members
 * - updated various methods that accept node/arc pointers to verify
 *   that those nodes/arcs are part of the graph first, and to check for null
 * @version 2014/10/10
 * - removed use of __foreach macro
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _graph_h
#define _graph_h

#include <string>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * This class represents a graph with the specified node and arc types.
 * The <code>NodeType</code> and <code>ArcType</code> parameters indicate
 * the structure type or class used for nodes and arcs, respectively.
 * These types can contain any fields or methods required by the client,
 * but must contain the following fields required by the <code>Graph</code>
 * package itself:
 *
 * <p>The <code>NodeType</code> definition must include:
 * <ul>
 *   <li>A <code>string</code> field called <code>name</code>
 *   <li>A <code>Set&lt;ArcType *&gt;</code> field called <code>arcs</code>
 * </ul>
 *
 * <p>The <code>ArcType</code> definition must include:
 * <ul>
 *   <li>A <code>NodeType *</code> field called <code>start</code>
 *   <li>A <code>NodeType *</code> field called <code>finish</code>
 * </ul>
 */
template <typename NodeType, typename ArcType>
class Graph {
public:
    /**
     * Creates an empty graph.
     * @bigoh O(1)
     */
    Graph();
    
    /**
     * Frees the internal storage allocated to represent the graph.
     * @bigoh O(V + E)
     */
    virtual ~Graph();
    
    /**
     * Adds a directed arc to the graph from node n1 to n2.
     * If either node is not found in the graph, said node will be added to the graph.
     * Returns a pointer to the arc in case the client needs to capture this value.
     * @bigoh O(log V + log E)
     */
    ArcType* addArc(const std::string& n1, const std::string& n2);

    /**
     * Adds a directed arc to the graph from node n1 to n2.
     * If either node is not found in the graph, said node will be added to the graph.
     * Returns a pointer to the arc in case the client needs to capture this value.
     *
     * @throw ErrorException if any pointer passed is null
     * @bigoh O(log V + log E)
     */
    ArcType* addArc(NodeType* n1, NodeType* n2);

    /**
     * Adds the given arc to the graph.
     * If the start/finish nodes passed are not already part of the graph,
     * they are added to the graph.
     * Returns a pointer to the arc in case the client needs to capture this value.
     *
     * Memory management: Once you hand me this ArcType* pointer, our code owns it.
     * We will delete/free it when done with it.
     * You do not need to (and should not) free it yourself.
     *
     * @throw ErrorException if any pointer passed is null
     * @bigoh O(log V + log E)
     */
    ArcType* addArc(ArcType* arc);

    /**
     * Adds a node to the graph.  The first version of this method
     * creates a new node of the appropriate type and initializes its
     * fields; the second assumes that the client has already created
     * the node and simply adds it to the graph.
     * Returns a pointer to the node.
     * If a node with the given name is already present, does nothing.
     *
     * Memory management: Once you hand me this NodeType* pointer, our code owns it.
     * We will delete/free it when done with it.
     * You do not need to (and should not) free it yourself.
     *
     * @throw ErrorException if any pointer passed is null
     * @bigoh O(log V)
     */
    NodeType* addNode(const std::string& name);

    /**
     * Adds a node to the graph.
     * This version assumes that the client has already created the node structure
     * and simply adds it to the graph.
     * Returns a pointer to the node.
     * If a node with the given name is already present, does nothing.
     *
     * Memory management: Once you hand me this NodeType* pointer, our code owns it.
     * We will delete/free it when done with it.
     * You do not need to (and should not) free it yourself.
     *
     * @throw ErrorException if any pointer passed is null
     * @bigoh O(log V)
     */
    NodeType* addNode(NodeType* node);

    /**
     * Returns the number of arcs in the graph.
     * @bigoh O(1)
     */
    int arcCount() const;

    /**
     * Returns the last node in the graph in the order as would be returned by
     * a for-each loop or iterator.
     * @throw ErrorException if the graph is empty
     * @bigoh O(1)
     */
    NodeType* back() const;

    /**
     * Reinitializes the graph to be empty, removing all nodes and arcs
     * and freeing any heap storage used by their corresponding internal structures.
     * @bigoh O(V + E)
     */
    void clear();

    /**
     * Removes all arcs from the graph, freeing the heap storage used by their
     * corresponding internal structures. The graph's nodes remain intact.
     * @bigoh O(E)
     */
    void clearArcs();

    /**
     * Removes all arcs from the graph that start from the given node,
     * freeing the heap storage used by their corresponding internal structures.
     * The graph's nodes remain intact.
     * If the given node pointer is null or not found in the graph, has no effect.
     * @bigoh O(log V + E)
     */
    void clearArcs(NodeType* node);

    /**
     * Removes all arcs from the graph that start from the given node,
     * freeing the heap storage used by their corresponding internal structures.
     * The graph's nodes remain intact.
     * If the given node is not found in the graph, has no effect.
     * @bigoh O(E log E)
     */
    void clearArcs(const std::string& name);

    /**
     * Returns true if there exists an arc directly between the given two nodes.
     * If either node is null or is not contained in this graph, returns false.
     * @bigoh O(log E)
     */
    bool containsArc(NodeType* node1, NodeType* node2) const;

    /**
     * Returns true if there exists an arc directly between the given two nodes.
     * If either node is not contained in this graph, returns false.
     * @bigoh O(log E)
     */
    bool containsArc(const std::string& node1, const std::string& node2) const;

    /**
     * Returns true if the given arc exists in this graph.
     * If the given arc is null or either of its nodes are not contained in
     * this graph, returns false.
     * @bigoh O(log E)
     */
    bool containsArc(ArcType* arc) const;

    /**
     * Returns true if there exists a node in this graph with the given name.
     * @bigoh O(log V)
     */
    bool containsNode(const std::string& name) const;

    /**
     * Returns true if the given node is part of this graph.
     * If the pointer passed is null, returns false.
     * @bigoh O(log V)
     */
    bool containsNode(NodeType* node) const;

    /**
     * Compares two graphs for equality.
     * Returns <code>true</code> if this graph contains exactly the same
     * nodes, arcs, and connections as the given other graph.
     * Identical in behavior to the == operator.
     * @bigoh O(V log V + E log E)
     */
    bool equals(const Graph<NodeType, ArcType>& graph2) const;
    
    /**
     * Returns the first node in the graph in the order as would be returned by
     * a for-each loop or iterator.
     * @throw ErrorException if the graph is empty
     * @bigoh O(1)
     */
    NodeType* front() const;

    /**
     * Returns the arc, if any, from node1 to node2.
     * If multiple arcs exist between the given two nodes, which is returned is unspecified.
     * If either pointer passed is null or no such arc exists, returns a null pointer.
     * @bigoh O(log V + log E)
     */
    ArcType* getArc(NodeType* node1, NodeType* node2) const;

    /**
     * Returns the arc, if any, from node1 to node2.
     * If multiple arcs exist between the given two nodes, which is returned is unspecified.
     * If no such arc exists, returns a null pointer.
     * @bigoh O(log V + log E)
     */
    ArcType* getArc(const std::string& node1, const std::string& node2) const;

    /**
     * Returns the set of all arcs in the graph.
     * @bigoh O(1)
     */
    const Set<ArcType*>& getArcSet() const;

    /**
     * Returns the set of all arcs that start at the specified node,
     * indicated as a pointer to its node structure.
     * If the pointer passed is null or the given node is not found in the graph,
     * returns an empty set.
     * @bigoh O(1)
     */
    const Set<ArcType*>& getArcSet(NodeType* node) const;

    /**
     * Returns the set of all arcs that start at the specified node.
     * If the given node is not found in the graph, returns an empty set.
     * @bigoh O(1)
     */
    const Set<ArcType*>& getArcSet(const std::string& name) const;

    /**
     * Returns the set of outbound arcs to the given node from other nodes.
     * In other words, getInverseArcSet(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If any pointer passed is null, or if the given node is not found
     * in this graph, returns an empty set.
     * @bigoh O(E)
     */
    const Set<ArcType*> getInverseArcSet(NodeType* node) const;

    /**
     * Returns the set of outbound arcs to the given node from other nodes.
     * In other words, getInverseArcSet(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If the given node is not found in this graph, returns an empty set.
     * @bigoh O(E)
     */
    const Set<ArcType*> getInverseArcSet(const std::string& name) const;

    /**
     * Returns the set of strings of names of nodes that are neighbors of the
     * given node.
     * In other words, getInverseNeighborNames(n1) is the set of all strings n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If any pointer passed is null, or if the given node is not found
     * in this graph, returns an empty set.
     * @bigoh O(E)
     */
    Set<std::string> getInverseNeighborNames(NodeType* node) const;

    /**
     * Returns the set of strings of names of nodes that are neighbors of the
     * given node.
     * In other words, getInverseNeighborNames(n1) is the set of all strings n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If the given node is not found in this graph, returns an empty set.
     * @bigoh O(E)
     */
    Set<std::string> getInverseNeighborNames(const std::string& node) const;

    /**
     * Returns the set of nodes that are neighbors of the specified node.
     * In other words, getInverseNeighbors(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If any pointer passed is null, or if the given node is not found
     * in this graph, returns an empty set.
     * @bigoh O(E)
     */
    Set<NodeType*> getInverseNeighbors(NodeType* node) const;

    /**
     * Returns the set of nodes that are neighbors of the specified node.
     * In other words, getInverseNeighbors(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n2 and ending at n1.
     *
     * If the given node is not found in this graph, returns an empty set.
     * @bigoh O(E)
     */
    Set<NodeType*> getInverseNeighbors(const std::string& node) const;

    /**
     * Returns the set of node names that are neighbors of the specified node.
     * In other words, getNeighbors(n1) is the set of all strings n2
     * such that there exists an arc E starting from n1 and ending at n2.
     *
     * If any pointer passed is null, or if the given node is not found
     * in this graph, returns an empty set.
     * @bigoh O(log V)
     */
    Set<std::string> getNeighborNames(NodeType* node) const;

    /**
     * Returns the set of node names that are neighbors of the specified node.
     * In other words, getNeighbors(n1) is the set of all strings n2
     * such that there exists an arc E starting from n1 and ending at n2.
     *
     * If the given node is not found in this graph, returns an empty set.
     * @bigoh O(log V)
     */
    Set<std::string> getNeighborNames(const std::string& node) const;

    /**
     * Returns the set of nodes that are neighbors of the specified node.
     * In other words, getNeighbors(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n1 and ending at n2.
     *
     * If any pointer passed is null, or if the given node is not found
     * in this graph, returns an empty set.
     * @bigoh O(log V)
     */
    Set<NodeType*> getNeighbors(NodeType* node) const;

    /**
     * Returns the set of nodes that are neighbors of the specified node.
     * In other words, getNeighbors(n1) is the set of all nodes n2
     * such that there exists an arc E starting from n1 and ending at n2.
     *
     * If the given node is not found in this graph, returns an empty set.
     * @bigoh O(log V)
     */
    Set<NodeType*> getNeighbors(const std::string& node) const;

    /**
     * Looks up a node in the name table attached to the graph and
     * returns a pointer to that node.
     * If no node with the specified name exists, returns <code>nullptr</code>.
     * @bigoh O(log V)
     */
    NodeType* getNode(const std::string& name) const;

    /**
     * Returns the set of the names of all nodes in the graph.
     * Similar to getNodeSet but returns a set of strings rather than a set
     * of pointers to nodes.
     * @bigoh O(V log V)
     */
    Set<std::string> getNodeNames() const;
    
    /**
     * Returns the set of all nodes in the graph.
     * These are direct pointers to the internal NodeType* structures in the
     * graph, so any modifications you make to them will be reflected in the graph.
     * @bigoh O(1)
     */
    const Set<NodeType*>& getNodeSet() const;

    /**
     * Returns <code>true</code> if the graph contains an arc from
     * <code>n1</code> to <code>n2</code>.
     * If any pointer passed is null, or if either node is not contained
     * in this graph, returns false.
     * @bigoh O(log V)
     */
    bool isConnected(NodeType* n1, NodeType* n2) const;

    /**
     * Returns <code>true</code> if the graph contains an arc from
     * <code>n1</code> to <code>n2</code>.
     * If either node is not contained in this graph, returns false.
     * @bigoh O(log V)
     */
    bool isConnected(const std::string& s1, const std::string& s2) const;

    /**
     * Returns true if the graph contains an edge from v1 to v2.
     * If either of the vertexes supplied is not found in the graph, returns false.
     * @bigoh O(log V)
     */
    bool isNeighbor(const std::string& node1, const std::string& node2) const;

    /**
     * Returns true if the graph contains an edge from v1 to v2.
     * If either of the vertexes supplied is null or is not found in the graph, returns false.
     * @bigoh O(log V)
     */
    bool isNeighbor(NodeType* node1, NodeType* node2) const;

    /**
     * Returns <code>true</code> if the graph contains no vertexes.
     * @bigoh O(1)
     */
    bool isEmpty() const;

    /**
     * Returns the number of nodes in the graph.
     * Equivalent to size().
     * @bigoh O(1)
     */
    int nodeCount() const;

    /**
     * Removes an arc from v1 to v2 in the graph, specified by the names of its endpoints.
     * If more than one arc connects the specified endpoints, all of them are removed.
     * If no arc connects the given endpoints, or the given arc is not found,
     * the call has no effect.
     * @bigoh O(E + log V)
     */
    void removeArc(const std::string& s1, const std::string& s2);

    /**
     * Removes an arc from v1 to v2 in the graph, specified by the node pointers
     * at its endpoints.
     * If more than one arc connects the specified endpoints, all of them are removed.
     * If no arc connects the given endpoints, or the given arc is not found,
     * the call has no effect.
     * @bigoh O(E + log V)
     */
    void removeArc(NodeType* n1, NodeType* n2);

    /**
     * Removes the given arc from the graph, specified as an arc pointer.
     * If more than one arc connects the specified endpoints, all of them are removed.
     * If no arc connects the given endpoints, or the given arc is not found,
     * the call has no effect.
     *
     * Memory management: Our code will delete/free the ArcType* object when done with it.
     * You do not need to (and should not) free it yourself.
     * @bigoh O(log E + log V)
     */
    void removeArc(ArcType* arc);

    /**
     * Removes the node with the given name from the graph.
     * Removing a node also removes all arcs that contain that node.
     * If a node name is passed that is not part of the graph,
     * the call has no effect.
     * @bigoh O(E + log V)
     */
    void removeNode(const std::string& name);

    /**
     * Removes a node from the graph, specified as a pointer value.
     * Removing a node also removes all arcs that contain that node.
     * If a node or name is passed that is null or is not part of the graph,
     * the call has no effect.
     *
     * Memory management: Our code will delete/free the NodeType* object when done with it.
     * You do not need to (and should not) free it yourself.
     * @bigoh O(E + log V)
     */
    void removeNode(NodeType* node);

    /**
     * Reads the data for an arc from the scanner.
     * The <code>forward</code> argument points to the arc in the forward direction.
     * If the arc is undirected, <code>backward</code> points to the reverse arc;
     * for directed arcs, the <code>backward</code> pointer is <code>nullptr</code>.
     *
     * The default implementation of this method is empty.
     * Clients that want to initialize other fields in the arc must override
     * this method so that it initializes one or both arc, as appropriate.
     */
    virtual void scanArcData(TokenScanner &, ArcType* /*forward*/, ArcType* /*backward*/) {
        // empty
    }

    /**
     * This method reads one "entry" for the graph, which is either a node
     * description or an arc description.  The <code>scanGraphEntry</code>
     * method returns <code>true</code> if it reads an entry, and
     * <code>false</code> at the end of file or at text that cannot be
     * recognized as a graph entry.
     *
     * Node entries consist of the name of a node (which may be quoted
     * if it contains special characters), optionally followed by data for
     * the node.  Arc descriptions have one of the following forms:
     *
     * <pre>
     * n1 -> n2
     * n1 - n2
     * </pre>
     *
     * either of which can be followed by data for the arc.
     * The first form creates a single directed arc; the second creates two arcs,
     * one in each direction.
     *
     * Clients who want to read node or arc data must override the empty
     * versions of <code>scanNodeData</code> and <code>scanArcData</code>
     * included in this interface.
     */
    virtual bool scanGraphEntry(TokenScanner& scanner);

    /**
     * Reads the data for the specified node from the scanner.
     * The default implementation of this method is empty.
     * Clients that want to initialize other fields in the node from the token
     * stream must override this method.
     */
    virtual void scanNodeData(TokenScanner&, NodeType*) {
        /* Empty */
    }

    /**
     * Returns the number of nodes in the graph.
     * Equivalent to nodeCount.
     * @bigoh O(1)
     */
    int size() const;

    /**
     * Converts the graph to a printable string representation.
     * @return a string such as <code>"{A, B, C, D, A - B, B - D, C - D}"</code>.
     * @bigoh O(V + E)
     */
    std::string toString() const;
    
    /**
     * Writes the data for the arc to the output stream.
     * The default implementation of this method is empty.
     * Clients that want to store other fields from the arc must override this
     * method so that it writes that data in a form that scanArcData can read.
     */
    virtual void writeArcData(std::ostream&, ArcType*) const {
        // empty
    }

    /**
     * Writes the data for the node to the output stream.
     * The default implementation of this method is empty.
     * Clients that want to store other fields from the node must override this
     * method so that it writes that data in a form that scanNodeData can read.
     */
    virtual void writeNodeData(std::ostream&, NodeType*) const {
        // empty
    }

    using graph_iterator = typename Set<NodeType *>::const_iterator;
    
    /**
     * Returns an STL iterator positioned at the first vertex in the graph.
     * @bigoh O(1)
     */
    graph_iterator begin() const {
        return _nodes.begin();
    }

    /**
     * Returns an STL iterator positioned after the last vertex in the graph.
     * @bigoh O(1)
     */
    graph_iterator end() const {
        return _nodes.end();
    }
    
    /**
     * Relational operators to compare two graphs.
     * The ==, != operators require that the ValueType has a == operator
     * so that the elements can be tested for equality.
     * @bigoh O(V log V + E log E)
     */
    bool operator ==(const Graph& graph2) const;

    /**
     * Relational operators to compare two graphs.
     * The ==, != operators require that the ValueType has a == operator
     * so that the elements can be tested for equality.
     * @bigoh O(V log V + E log E)
     */
    bool operator !=(const Graph& graph2) const;

    /**
     * Relational operators to compare two graphs.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(V log V + E log E)
     */
    bool operator <(const Graph& graph2) const;

    /**
     * Relational operators to compare two graphs.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(V log V + E log E)
     */
    bool operator <=(const Graph& graph2) const;

    /**
     * Relational operators to compare two graphs.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(V log V + E log E)
     */
    bool operator >(const Graph& graph2) const;

    /**
     * Relational operators to compare two graphs.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     * @bigoh O(V log V + E log E)
     */
    bool operator >=(const Graph& graph2) const;

private:
    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /**
     * This template class establishes the ordering for nodes and arcs.
     * Nodes are processed in alphabetical order by node name; arcs are
     * compared in much the same way, looking first at the start node and
     * then continuing on to look at the finish node if the start nodes
     * match.  These functions, however, indicate equality only if the
     * arguments are identical, in the sense that they are at the same
     * address.  If two distinct arcs, for example, connect the same pair
     * of nodes (which is perfectly legal in the graph abstraction and can
     * be used, for example, to represent multiple modes of travel between
     * two nodes), those arcs are not the same.
     *
     * @private
     */
    class GraphComparator {
    public:
        bool operator ()(NodeType* n1, NodeType* n2) {
            return compare(n1, n2) < 0;
        }

        bool operator ()(ArcType* a1, ArcType* a2) {
            return compare(a1, a2) < 0;
        }
    };

    Set<NodeType*> _nodes{GraphComparator()}; /* The set of nodes in the graph */
    Set<ArcType*> _arcs{GraphComparator()};   /* The set of arcs in the graph  */
    Map<std::string, NodeType*> _nodeMap;     /* A map from names to nodes     */

public:
    /**
     * These functions are part of the public interface of the class but are
     * defined here to avoid adding confusion to the Graph class.
     *
     * @private
     */
    Graph& operator =(const Graph& src);

    /**
     * These functions are part of the public interface of the class but are
     * defined here to avoid adding confusion to the Graph class.
     *
     * @private
     */
    Graph(const Graph& src);

    /**
     * Compares two nodes for ordering within a set.
     *
     * @private
     */
    static int compare(NodeType* n1, NodeType* n2) {
        if (n1 == n2) {
            return 0;
        }
        if (n1->name < n2->name) {
            return -1;
        }
        if (n1->name > n2->name) {
            return +1;
        }
        return (n1 < n2) ? -1 : +1;
    }

    /**
     * Compares two arcs for ordering within a set.
     *
     * @private
     */
    static int compare(ArcType* a1, ArcType* a2) {
        if (a1 == a2) {
            return 0;
        }
        NodeType* n1 = a1->start;
        NodeType* n2 = a2->start;
        if (n1 != n2) {
            return compare(n1, n2);
        }
        n1 = a1->finish;
        n2 = a2->finish;
        if (n1 != n2) {
            return compare(n1, n2);
        }
        return (a1 < a2) ? -1 : +1;
    }

private:
    void deepCopy(const Graph& src);
    NodeType* getExistingNode(const std::string& name, const std::string& member = "") const;
    int graphCompare(const Graph& graph2) const;
    bool isExistingArc(ArcType* arc) const;
    bool isExistingNode(NodeType* node) const;
    void verifyExistingNode(NodeType* node, const std::string& member = "") const;
    void verifyNotNull(void* p, const std::string& member = "") const;
    NodeType* scanNode(TokenScanner& scanner);
};

/*
 * Implementation notes: Graph constructor
 * ---------------------------------------
 * Even though the body of the Graph constructor is empty, important
 * work is done by the initializers, which ensure that the nodes and
 * arcs set are given the correct comparison functions.
 */

template <typename NodeType, typename ArcType>
Graph<NodeType, ArcType>::Graph() {
    // empty
}

template <typename NodeType, typename ArcType>
Graph<NodeType, ArcType>::Graph(const Graph& src) {
    deepCopy(src);
}

/*
 * Implementation notes: Graph destructor
 * --------------------------------------
 * The destructor must free all heap storage used by this graph to
 * represent the nodes and arcs.  The clear method must also reclaim
 * this memory, which means that the destructor can simply call
 * clear to do the work.
 */
template <typename NodeType, typename ArcType>
Graph<NodeType, ArcType>::~Graph() {
    clear();
}

/*
 * Implementation notes: addArc
 * ----------------------------
 * The addArc method appears in three forms, as described in the
 * interface.  The code for each form of the method, however, is
 * quite straightforward.
 */
template <typename NodeType, typename ArcType>
ArcType* Graph<NodeType, ArcType>::addArc(const std::string& s1, const std::string& s2) {
    return addArc(getExistingNode(s1, "addArc"), getExistingNode(s2, "addArc"));
}

template <typename NodeType, typename ArcType>
ArcType* Graph<NodeType, ArcType>::addArc(NodeType* n1, NodeType* n2) {
    verifyExistingNode(n1, "addArc");
    verifyExistingNode(n2, "addArc");
    ArcType* arc = getArc(n1, n2);
    if (arc) {
        return arc;
    } else {
        arc = new ArcType();
        arc->start = n1;
        arc->finish = n2;
        return addArc(arc);
    }
}

template <typename NodeType, typename ArcType>
ArcType* Graph<NodeType, ArcType>::addArc(ArcType* arc) {
    verifyNotNull(arc, "addArc");
    if (!isExistingNode(arc->start)) {
        addNode(arc->start);
    }
    if (!isExistingNode(arc->finish)) {
        addNode(arc->finish);
    }
    arc->start->arcs.add(arc);
    _arcs.add(arc);
    return arc;
}

/*
 * Implementation notes: addNode
 * -----------------------------
 * The addNode method appears in two forms: one that creates a node
 * from its name and one that assumes that the client has created
 * the new node.  In each case, the implementation must add the node
 * the set of nodes for the graph and add the name-to-node association
 * to the node map.
 */
template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::addNode(const std::string& name) {
    NodeType* node = getNode(name);
    if (node) {
        return node;   // vertex already exists
    }
    node = new NodeType();
    node->arcs = Set<ArcType*>(GraphComparator());
    node->name = name;
    return addNode(node);
}

template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::addNode(NodeType* node) {
    verifyNotNull(node, "addNode");
    NodeType* existingNode = getNode(node->name);
    if (existingNode) {
        *existingNode = *node;   // copy state from parameter
        return existingNode;
    } else {
        _nodes.add(node);
        _nodeMap[node->name] = node;
        return node;
    }
}

template <typename NodeType, typename ArcType>
int Graph<NodeType, ArcType>::arcCount() const {
    return getArcSet().size();
}

template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::back() const {
    if (this->isEmpty()) {
        error("Graph::back: graph is empty");
    }
    return this->_nodes.back();
}

/*
 * Implementation notes: clear
 * ---------------------------
 * The implementation of clear first frees the nodes and arcs in
 * their respective sets and then uses the Set class clear method
 * to ensure that these sets are empty.
 */
template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::clear() {
    for (NodeType* node : _nodes) {
        delete node;
    }
    for (ArcType* arc : _arcs) {
        delete arc;
    }
    _arcs.clear();
    _nodes.clear();
    _nodeMap.clear();
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::clearArcs() {
    Set<ArcType*> arcsCopy = getArcSet();   // makes a copy
    for (ArcType* arc : arcsCopy) {
        removeArc(arc);
    }
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::clearArcs(NodeType* node) {
    if (isExistingNode(node)) {
        Set<ArcType*> arcsCopy = getArcSet(node);   // makes a copy
        for (ArcType* arc : arcsCopy) {
            removeArc(arc);
        }
    }
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::clearArcs(const std::string& name) {
    Set<ArcType*> arcsCopy = getArcSet(name);   // makes a copy
    for (ArcType* arc : arcsCopy) {
        removeArc(arc);
    }
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::containsArc(NodeType* node1, NodeType* node2) const {
    return getArc(node1, node2) != nullptr;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::containsArc(const std::string& node1, const std::string& node2) const {
    return getArc(node1, node2) != nullptr;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::containsArc(ArcType* arc) const {
    if (!arc) {
        return false;
    } else {
        return this->getArcSet().contains(arc);
    }
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::containsNode(const std::string& name) const {
    return _nodeMap.containsKey(name);
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::containsNode(NodeType* node) const {
    if (node) {
        return _nodes.contains(node);
    } else {
        return false;
    }
}


template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::equals(const Graph<NodeType, ArcType>& graph2) const {
    return *this == graph2;
}

template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::front() const {
    if (this->isEmpty()) {
        error("Graph::front: graph is empty");
    }
    return this->_nodes.front();
}

template <typename NodeType, typename ArcType>
ArcType* Graph<NodeType, ArcType>::getArc(NodeType* node1, NodeType* node2) const {
    if (!containsNode(node1) || !containsNode(node2)) {
        return nullptr;
    }
    for (ArcType* arc : getArcSet(node1)) {
        if (arc->finish == node2) {
            return arc;
        }
    }
    return nullptr;
}

template <typename NodeType, typename ArcType>
ArcType* Graph<NodeType, ArcType>::getArc(const std::string& node1, const std::string& node2) const {
    return getArc(getNode(node1), getNode(node2));
}

template <typename NodeType, typename ArcType>
const Set<ArcType*>& Graph<NodeType, ArcType>::getArcSet() const {
    return _arcs;
}

template <typename NodeType, typename ArcType>
const Set<ArcType*>& Graph<NodeType, ArcType>::getArcSet(NodeType* node) const {
    if (isExistingNode(node)) {
        return node->arcs;
    } else {
        static Set<ArcType*> set;   // empty
        return set;
    }
}

template <typename NodeType, typename ArcType>
const Set<ArcType*>& Graph<NodeType, ArcType>::getArcSet(const std::string& name) const {
    return getArcSet(getNode(name));
}

template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::getExistingNode(const std::string& name, const std::string& member) const {
    NodeType* node = _nodeMap.get(name);
    if (!node) {
        error("Graph::" + member + ": no node named " + name);
    }
    return node;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isExistingArc(ArcType* arc) const {
    return arc && _arcs.contains(arc);
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isExistingNode(NodeType* node) const {
    return node && _nodeMap.containsKey(node->name) && _nodeMap.get(node->name) == node;
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::verifyExistingNode(NodeType* node, const std::string& member) const {
    verifyNotNull(node, member);
    if (!isExistingNode(node)) {
        error("Graph::" + member + ": node not found in graph");
    }
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::verifyNotNull(void* p, const std::string& member) const {
    if (!p) {
        error("Graph::" + member + ": parameter cannot be null");
    }
}

template <typename NodeType, typename ArcType>
const Set<ArcType*> Graph<NodeType, ArcType>::getInverseArcSet(NodeType* node) const {
    Set<ArcType*> set;
    if (isExistingNode(node)) {
        for (ArcType* arc : getArcSet()) {
            if (arc->finish == node) {
                set.add(arc);
            }
        }
    }
    return set;
}

template <typename NodeType, typename ArcType>
const Set<ArcType*> Graph<NodeType, ArcType>::getInverseArcSet(const std::string& nodeName) const {
    return getInverseArcSet(getNode(nodeName));
}

template <typename NodeType, typename ArcType>
Set<std::string> Graph<NodeType, ArcType>::getInverseNeighborNames(NodeType* node) const {
    Set<std::string> set;
    if (isExistingNode(node)) {
        for (ArcType* arc : getArcSet()) {
            if (arc->finish == node) {
                set.add(arc->start->name);
            }
        }
    }
    return set;
}

template <typename NodeType, typename ArcType>
Set<std::string> Graph<NodeType, ArcType>::getInverseNeighborNames(const std::string& name) const {
    return getInverseNeighborNames(getNode(name));
}

template <typename NodeType, typename ArcType>
Set<NodeType*> Graph<NodeType, ArcType>::getInverseNeighbors(NodeType* node) const {
    Set<NodeType*> set;
    if (isExistingNode(node)) {
        for (ArcType* arc : getArcSet()) {
            if (arc->finish == node) {
                set.add(arc->start);
            }
        }
    }
    return set;
}

template <typename NodeType, typename ArcType>
Set<NodeType*> Graph<NodeType, ArcType>::getInverseNeighbors(const std::string& nodeName) const {
    return getInverseNeighbors(getNode(nodeName));
}

template <typename NodeType, typename ArcType>
Set<std::string> Graph<NodeType, ArcType>::getNeighborNames(NodeType* node) const {
    Set<std::string> neighbors;
    if (isExistingNode(node)) {
        for (ArcType* arc : node->arcs) {
            neighbors.add(arc->finish->name);
        }
    }
    return neighbors;
}

template <typename NodeType, typename ArcType>
Set<std::string> Graph<NodeType, ArcType>::getNeighborNames(const std::string& name) const {
    return getNeighborNames(getNode(name));
}

/*
 * Implementation notes: getNeighbors
 * ----------------------------------
 * This implementation recomputes the set each time, which is reasonably
 * efficient if the degree of the node is small.
 */
template <typename NodeType, typename ArcType>
Set<NodeType*> Graph<NodeType, ArcType>::getNeighbors(NodeType* node) const {
    Set<NodeType*> nodesResult{GraphComparator{}};
    if (isExistingNode(node)) {
        for (ArcType* arc : node->arcs) {
            nodesResult.add(arc->finish);
        }
    }
    return nodesResult;
}

template <typename NodeType, typename ArcType>
Set<NodeType*> Graph<NodeType, ArcType>::getNeighbors(const std::string& name) const {
    return getNeighbors(getNode(name));
}

/*
 * Implementation notes: getNode, getExistingNode
 * ----------------------------------------------
 * The getNode method simply looks up the name in the map, which correctly
 * returns nullptr if the name is not found.  Other methods in the
 * implementation call the private method getExistingNode instead,
 * which checks for a null value and signals an error.
 */
template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::getNode(const std::string& name) const {
    return _nodeMap.get(name);
}

template <typename NodeType, typename ArcType>
Set<std::string> Graph<NodeType, ArcType>::getNodeNames() const {
    Set<std::string> nodeNames;
    for (NodeType* node : _nodes) {
        nodeNames.add(node->name);
    }
    return nodeNames;
}

/*
 * Implementation notes: getNodeSet, getArcSet
 * -------------------------------------------
 * These methods simply return the set requested by the client.  The
 * sets are returned by reference for efficiency, because doing so
 * eliminates the need to copy the set.
 */
template <typename NodeType, typename ArcType>
const Set<NodeType*>& Graph<NodeType, ArcType>::getNodeSet() const {
    return _nodes;
}

/*
 * Implementation notes: isConnected
 * ---------------------------------
 * Node n1 is connected to n2 if any of the arcs leaving n1 finish at n2.
 * The two versions of this method allow nodes to be specified either as
 * node pointers or by name.
 */
template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isConnected(NodeType* n1, NodeType* n2) const {
    // don't call verifyExistingNode here because it will throw an error
    // if n1 or n2 is not found; should just make the call return false
    if (!isExistingNode(n1) || !isExistingNode(n2)) {
        return false;
    }
    for (ArcType* arc : n1->arcs) {
        if (arc->finish == n2) {
            return true;
        }
    }
    return false;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isConnected(const std::string& s1, const std::string& s2) const {
    // don't call getExistingNode here because it will throw an error
    // if s1 or s2 is not found; should just make the call return false
    return isConnected(_nodeMap.get(s1), _nodeMap.get(s2));
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isNeighbor(const std::string& node1, const std::string& node2) const {
    return isConnected(node1, node2);
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isNeighbor(NodeType* node1, NodeType* node2) const {
    return isConnected(node1, node2);
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::isEmpty() const {
    return _nodes.isEmpty();
}

template <typename NodeType, typename ArcType>
int Graph<NodeType, ArcType>::nodeCount() const {
    return getNodeSet().size();
}

/*
 * Implementation notes: removeArc
 * -------------------------------
 * These methods remove arcs from the graph, which is ordinarily simply
 * a matter of removing the arc from two sets: the set of arcs in the
 * graph as a whole and the set of arcs in the starting node.  The
 * methods that remove an arc specified by its endpoints, however,
 * must take account of the fact that there might be more than one
 * such arc and delete all of them.
 */
template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::removeArc(const std::string& s1, const std::string& s2) {
    // don't call getExistingNode here because it will throw an error
    // if s1 or s2 is not found; should just make the call have no effect
    removeArc(_nodeMap.get(s1), _nodeMap.get(s2));
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::removeArc(NodeType* n1, NodeType* n2) {
    // don't call verifyExistingNode here because it will throw an error
    // if n1 or n2 is not found; should just make the call have no effect
    if (!isExistingNode(n1) || !isExistingNode(n2)) {
        return;
    }
    Vector<ArcType*> toRemove;
    for (ArcType* arc : _arcs) {
        if (arc->start == n1 && arc->finish == n2) {
            toRemove.add(arc);
        }
    }
    for (ArcType* arc : toRemove) {
        removeArc(arc);
    }
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::removeArc(ArcType* arc) {
    if (!isExistingArc(arc)) {
        return;
    }
    arc->start->arcs.remove(arc);
    _arcs.remove(arc);
    delete arc;
}

/*
 * Implementation notes: removeNode
 * --------------------------------
 * The removeNode method must remove the specified node but must
 * also remove any arcs in the graph containing the node.  To avoid
 * changing the node set during iteration, this implementation creates
 * a vector of arcs that require deletion.
 */
template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::removeNode(const std::string& name) {
    // don't call getExistingNode here because it will throw an error
    // if name is not found; should just make the call have no effect
    removeNode(_nodeMap.get(name));
}

template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::removeNode(NodeType* node) {
    // don't call verifyExistingNode here because it will throw an error
    // if node is not found; should just make the call have no effect
    if (!isExistingNode(node)) {
        return;
    }
    Vector<ArcType*> toRemove;
    for (ArcType* arc : _arcs) {
        if (arc->start == node || arc->finish == node) {
            toRemove.add(arc);
        }
    }
    for (ArcType* arc : toRemove) {
        removeArc(arc);
    }
    _nodes.remove(node);
    _nodeMap.remove(node->name);
    delete node;
}

/*
 * Implementation notes: scanGraphEntry
 * ------------------------------------
 * The scanGraphEntry and its helper methods take a scanner that is
 * initialized to the input stream and has the options ignoreWhitespace,
 * scanStrings, and scanNumbers set.
 */
template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::scanGraphEntry(TokenScanner& scanner) {
    NodeType* n1 = scanNode(scanner);
    if (!n1) {
        return false;
    }
    std::string op = scanner.nextToken();
    if (op != "-" && op != "->") {
        scanner.saveToken(op);
        return true;
    }
    NodeType* n2 = scanNode(scanner);
    if (!n2) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("Graph::scanGraphEntry: Missing node after " + op);
#endif
        return false;
    }
    ArcType* forward = new ArcType();
    forward->start = n1;
    forward->finish = n2;
    addArc(forward);
    ArcType* backward = nullptr;
    if (op == "-") {
        backward = new ArcType();
        backward->start = n2;
        backward->finish = n1;
        addArc(backward);
    }
    scanArcData(scanner, forward, backward);
    return true;
}

template <typename NodeType, typename ArcType>
NodeType* Graph<NodeType, ArcType>::scanNode(TokenScanner& scanner) {
    std::string token = scanner.nextToken();
    switch (scanner.getTokenType(token)) {
    case TokenScanner::WORD:
        break;
    case TokenScanner::STRING:
        token = scanner.getStringValue(token);
        break;
    default:
        scanner.saveToken(token);
        return nullptr;
    }
    NodeType* node = getNode(token);
    if (!node) {
        node = new NodeType();
        node->name = token;
        scanNodeData(scanner, node);
        addNode(node);
    }
    return node;
}

/*
 * Implementation notes: size, isEmpty
 * -----------------------------------
 * These methods are defined in terms of the node set, so the implementation
 * simply forwards the request there.  Note that it is impossible for a
 * graph to have arcs if it has no nodes.
 */
template <typename NodeType, typename ArcType>
int Graph<NodeType, ArcType>::size() const {
    return _nodes.size();
}

template <typename NodeType, typename ArcType>
std::string Graph<NodeType, ArcType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

/*
 * Implementation notes: operator =, copy constructor
 * -------------------------------------------------
 * These methods ensure that copying a graph creates an entirely new
 * parallel structure of nodes and arcs.
 */
template <typename NodeType, typename ArcType>
Graph<NodeType,ArcType>&
Graph<NodeType, ArcType>::operator =(const Graph& src) {
    if (this != &src) {
        clear();
        deepCopy(src);
    }
    return *this;
}

/*
 * Private method: deepCopy
 * ------------------------
 * Common code factored out of the copy constructor and operator= to
 * copy the contents from the other graph.
 */
template <typename NodeType, typename ArcType>
void Graph<NodeType, ArcType>::deepCopy(const Graph& src) {
    for (NodeType* oldNode : src._nodes) {
        NodeType* newNode = new NodeType();
        *newNode = *oldNode;
        newNode->arcs.clear();
        addNode(newNode);
    }
    for (ArcType* oldArc : src._arcs) {
        ArcType* newArc = new ArcType();
        *newArc = *oldArc;
        newArc->start = getExistingNode(oldArc->start->name, "deepCopy");
        newArc->finish = getExistingNode(oldArc->finish->name, "deepCopy");
        addArc(newArc);
    }
}


/**
 * Compares two graphs for <, <=, ==, !=, >, >= relational operators.
 * Vertices are compared, including their neighboring arcs.
 *
 * @private
 */
template <typename NodeType, typename ArcType>
int Graph<NodeType, ArcType>::graphCompare(const Graph<NodeType, ArcType>& graph2) const {
    // optimization: if literally the same graph, return true
    if (this == &graph2) {
        return 0;
    }
    
    auto itr1 = begin();
    auto itr2 = graph2.begin();
    auto g1end = end();
    auto g2end = graph2.end();
    
    while (itr1 != g1end && itr2 != g2end) {
        // compare each pair of elements from iterators
        NodeType* node1 = *itr1;
        NodeType* node2 = *itr2;
        
        // optimization: if literally same node, equal; don't compare
        if (node1 != node2) {
            // first check names
            if (node1->name != node2->name) {
                return node1->name.compare(node2->name);
            }
            
            // then check all arcs, pairwise
            auto eitr1 = node1->arcs.begin();
            auto eitr2 = node2->arcs.begin();
            auto e1end = node1->arcs.end();
            auto e2end = node2->arcs.end();
            while (eitr1 != e1end && eitr2 != e2end) {
                ArcType* arc1 = *eitr1;
                ArcType* arc2 = *eitr2;
                
                // optimization: if literally same arc, equal; don't compare
                if (arc1 != arc2) {
                    // first check start vertex names, then end vertex names
                    if (arc1->start->name != arc2->start->name) {
                        return arc1->start->name.compare(arc2->start->name);
                    } else if (arc1->finish->name != arc2->finish->name) {
                        return arc1->finish->name.compare(arc2->finish->name);
                    }
                }
                eitr1++;
                eitr2++;
            }
            
            // if we get here, everything from me matched graph2, so either arcs equal,
            // or one is shorter than the other (fewer arcs) and is therefore less
            if (eitr1 == e1end && eitr2 == e2end) {
                // keep going
            } else if (eitr1 == e1end) {
                return -1;
            } else {
                return 1;
            }
        }
        
        // if we get here, those two vertices and their outbound arcs
        // were equal; so advance to next element
        itr1++;
        itr2++;
    }
    
    // if we get here, everything from me matched graph2, so either equal,
    // or one is shorter than the other (fewer vertices) and is therefore less
    if (itr1 == g1end && itr2 == g2end) {
        return 0;
    } else if (itr1 == g1end) {
        return -1;
    } else {
        return 1;
    }
}

/*
 * Operators
 */
template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator ==(const Graph& graph2) const {
    // optimization: if sizes not same, graphs not equal
    if (_nodes.size() != graph2._nodes.size()
            || _arcs.size() != graph2._arcs.size()
            || _nodeMap.size() != graph2._nodeMap.size()) {
        return false;
    }
    return graphCompare(graph2) == 0;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator !=(const Graph& graph2) const {
    return !(*this == graph2);
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator <(const Graph& graph2) const {
    return graphCompare(graph2) < 0;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator <=(const Graph& graph2) const {
    return graphCompare(graph2) <= 0;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator >(const Graph& graph2) const {
    return graphCompare(graph2) > 0;
}

template <typename NodeType, typename ArcType>
bool Graph<NodeType, ArcType>::operator >=(const Graph& graph2) const {
    return graphCompare(graph2) >= 0;
}

/**
 * Writes the given graph to the given output stream.
 * The insertion and extraction operators for graphs are more complicated
 * than for the standard collection types because the nodes and arcs can
 * contain client-specific data.  To ensure that this information is
 * correctly written and read by these operators, clients must override
 * the methods writeNodeData, writeArcData, scanNodeData, and scanArcData.
 */
template <typename NodeType, typename ArcType>
std::ostream& operator <<(std::ostream& os, const Graph<NodeType, ArcType>& g) {
    os << "{";
    bool started = false;
    for (NodeType* node : g.getNodeSet()) {
        if (started) {
            os << ", ";
        }
        writeGenericValue(os, node->name, stringIsInteger(node->name) || stringIsReal(node->name));
        g.writeNodeData(os, node);
        started = true;
    }
    for (ArcType* arc : g.getArcSet()) {
        os << ", ";
        writeGenericValue(os, arc->start->name, stringIsInteger(arc->start->name) || stringIsReal(arc->start->name));
        os << " -> ";
        writeGenericValue(os, arc->finish->name, stringIsInteger(arc->finish->name) || stringIsReal(arc->finish->name));
        g.writeArcData(os, arc);
    }
    return os << "}";
}

/**
 * Reads the given graph from the given input stream.
 * The insertion and extraction operators for graphs are more complicated
 * than for the standard collection types because the nodes and arcs can
 * contain client-specific data.  To ensure that this information is
 * correctly written and read by these operators, clients must override
 * the methods writeNodeData, writeArcData, scanNodeData, and scanArcData.
 */
template <typename NodeType, typename ArcType>
std::istream& operator >>(std::istream& is, Graph<NodeType, ArcType>& g) {
    TokenScanner scanner(is);
    scanner.ignoreWhitespace();
    scanner.scanNumbers();
    scanner.scanStrings();
    scanner.addOperator("->");
    std::string token = scanner.nextToken();
    if (token != "{") {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("Graph::operator >>: Missing {");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }
    g.clear();
    while (g.scanGraphEntry(scanner)) {
        token = scanner.nextToken();
        if (token == "}") {
            scanner.saveToken(token);
        } else if (token != ",") {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
            error("Graph::operator >>: Unexpected token " + token);
#endif
            is.setstate(std::ios_base::failbit);
            return is;
        }
    }
    token = scanner.nextToken();
    if (token != "}") {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("Graph::operator >>: Missing }");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }
    return is;
}

/**
 * Template hash function for graphs.
 */
template <typename NodeType, typename ArcType>
int hashCode(const Graph<NodeType, ArcType>& graph) {
    int code = hashSeed();
    for (NodeType* node : graph) {
        code = hashMultiplier() * code + hashCode(node->name);
    }
    for (ArcType* arc : graph.getArcSet()) {
        code = hashMultiplier() * code + hashCode(arc->start->name);
        code = hashMultiplier() * code + hashCode(arc->finish->name);
    }
    return (code & hashMask());
}

#endif // _graph_h

/////////////////////// END code extracted from StanfordCPPLib/collections/graph.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/gridlocation.h ///////////////////////
/*
 * File: gridlocation.h
 * --------------------
 * This file exports the <code>GridLocation</code> structure, which is a small
 * structure representing a row and column.
 * The row/column values are allowed to be negative or out of bounds; if an
 * out-of-bounds location is passed to a grid, the grid will throw an error.
 *
 * Several members of the <code>Grid</code> and <code>SparseGrid</code> classes
 * have been retrofitted to accept <code>GridLocation</code>s in place of integers
 * for row/column indexes.
 *
 * This file also declares the <code>GridLocationRange</code> class,
 * which represents a 2D range of grid locations that can be looped over.
 *
 * See gridlocation.cpp for the implementation of each member.
 *
 * @version 2018/03/12
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _gridlocation_h
#define _gridlocation_h

#include <iostream>
#include <iterator>
#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

class GridLocationRange;   // forward declaration

struct GridLocation {
public:
    /*
     * Constructs a location representing the given row and column (default 0).
     * Any indexes are allowed, including negatives and out-of-bounds indexes.
     */
    GridLocation(int row = 0, int col = 0);

    /*
     * Returns a range of locations that are <= the given range away from this one.
     * For example, if you pass 1, will return the 9 locations in range (r-1, c-1) thru (r+1, c+1).
     * The rowMajor parameter indicates whether the range will emit its members
     * in row-major (default) or column-major order.
     */
    GridLocationRange neighbors(int range = 1, bool rowMajor = true) const;

    /*
     * Returns a string representation of this location, such as "r2c17".
     */
    std::string toString() const;

    /* row and column data - may be directly accessed or modified */
    int row;
    int col;
};

/*
 * Returns an integer hash code for this grid location.
 */
int hashCode(const GridLocation& loc);

/*
 * Relational operators for comparing grid locations.
 */
bool operator <(const GridLocation& loc1, const GridLocation& loc2);
bool operator <=(const GridLocation& loc1, const GridLocation& loc2);
bool operator ==(const GridLocation& loc1, const GridLocation& loc2);
bool operator !=(const GridLocation& loc1, const GridLocation& loc2);
bool operator >(const GridLocation& loc1, const GridLocation& loc2);
bool operator >=(const GridLocation& loc1, const GridLocation& loc2);

/*
 * I/O stream operators for reading or writing locations in their toString format.
 */
std::ostream& operator <<(std::ostream& out, const GridLocation& loc);
std::istream& operator >>(std::istream& input, GridLocation& loc);


/*
 * Represents a range of grid locations.
 * The actual individual grid locations are not all created and stored in
 * this object; that would require a lot of memory usage.
 * Instead, we primarily use this class for for-each looping over a given range
 * of locations using its internal iterator.
 *
 * Common usage pattern:
 * GridLocationRange range(0, 0, 10, 5);
 * for (GridLocation loc : range) { ... }
 *
 * or, if you have a Grid collection, its locations() method returns a GridLocationRange
 * object that you can loop over directly.
 *
 * for (GridLocation loc : grid.locations()) { ... }
 */
class GridLocationRange {
private:
    /*
     * Internal iterator over range of indexes.
     */
    class GridLocationRangeIterator : public std::iterator<std::input_iterator_tag, GridLocation> {
    private:
        const GridLocationRange* glr;
        GridLocation loc;

    public:
        GridLocationRangeIterator(const GridLocationRange* glr, bool end)
                : glr(glr) {
            if (end) {
                loc.row = glr->endRow() + 1;
                loc.col = glr->endCol() + 1;
            } else {
                loc = glr->startLocation();
            }
        }

        GridLocationRangeIterator(const GridLocationRangeIterator& itr)
                : glr(itr.glr),
                  loc(itr.loc) {
            // empty
        }

        GridLocationRangeIterator& operator ++() {
            if (glr->isRowMajor()) {
                loc.col++;
                if (loc.col > glr->endCol()) {
                    loc.col = glr->startCol();
                    loc.row++;
                }
            } else {
                loc.row++;
                if (loc.row > glr->endRow()) {
                    loc.row = glr->startRow();
                    loc.col++;
                }
            }
            if (!glr->contains(loc)) {
                loc.row = glr->endRow() + 1;
                loc.col = glr->endCol() + 1;
            }
            return *this;
        }

        GridLocationRangeIterator operator ++(int) {
            GridLocationRangeIterator copy(*this);
            operator++();
            return copy;
        }

        GridLocationRangeIterator& operator --() {
            if (glr->isRowMajor()) {
                loc.col--;
                if (loc.col < glr->startCol()) {
                    loc.col = glr->endCol();
                    loc.row--;
                }
            } else {
                loc.row--;
                if (loc.row < glr->startRow()) {
                    loc.row = glr->endRow();
                    loc.col--;
                }
            }
            return *this;
        }

        GridLocationRangeIterator operator --(int) {
            GridLocationRangeIterator copy(*this);
            operator--();
            return copy;
        }

        bool operator ==(const GridLocationRangeIterator& rhs) const {
            return loc == rhs.loc;
        }

        bool operator !=(const GridLocationRangeIterator& rhs) const {
            return !(*this == rhs);
        }

        bool operator <(const GridLocationRangeIterator& rhs) const {
            if (glr != rhs.glr) {
                error("GridLocationRange Iterator::operator <: Iterators are in different ranges");
            }
            return loc < rhs.loc;
        }

        bool operator <=(const GridLocationRangeIterator& rhs) const {
            if (glr != rhs.glr) {
                error("GridLocationRange Iterator::operator <=: Iterators are in different ranges");
            }
            return loc <= rhs.loc;
        }

        bool operator >(const GridLocationRangeIterator& rhs) const {
            if (glr != rhs.glr) {
                error("GridLocationRange Iterator::operator >: Iterators are in different ranges");
            }
            return loc > rhs.loc;
        }

        bool operator >=(const GridLocationRangeIterator& rhs) const {
            if (glr != rhs.glr) {
                error("GridLocationRange Iterator::operator >=: Iterators are in different ranges");
            }
            return loc >= rhs.loc;
        }

        const GridLocation& operator *() const {
            return loc;
        }

        const GridLocation* operator ->() const {
            return &loc;
        }
    };

    GridLocation _start;
    GridLocation _end;
    bool _isRowMajor;

public:
    /*
     * Constructs a range over the given start/end locations, inclusive.
     * The isRowMajor flag indicates whether we will loop over the range in
     * row-major order (true, default) or column-major order (false).
     */
    GridLocationRange(int startRow = 0, int startCol = 0, int endRow = 0, int endCol = 0, bool isRowMajor = true);

    /*
     * Constructs a range over the given start/end locations, inclusive.
     * The isRowMajor flag indicates whether we will loop over the range in
     * row-major order (true, default) or column-major order (false).
     */
    GridLocationRange(const GridLocation& startLoc, const GridLocation& endLoc, bool isRowMajor = true);

    /*
     * Returns an iterator over the range.
     */
    GridLocationRangeIterator begin() const;

    /*
     * Returns true if this range entirely contains the given other range.
     */
    bool contains(const GridLocation& loc) const;

    /*
     * Returns an iterator at the end of the range.
     */
    GridLocationRangeIterator end() const;

    /*
     * Returns the last column in this range, inclusive.
     */
    int endCol() const;

    /*
     * Returns the last row/column location in this range, inclusive.
     */
    const GridLocation& endLocation() const;

    /*
     * Returns the last row in this range, inclusive.
     */
    int endRow() const;

    /*
     * Returns true if this range contains no rows or columns.
     */
    bool isEmpty() const;

    /*
     * Returns true if this range should be traversed in row-major order,
     * as specified at time of construction (default true).
     */
    bool isRowMajor() const;

    /*
     * Returns the first column in this range.
     */
    int startCol() const;

    /*
     * Returns the first row/column location in this range.
     */
    const GridLocation& startLocation() const;

    /*
     * Returns the first row in this range.
     */
    int startRow() const;

    /*
     * Returns a string representation of this range,
     * such as "[r1c3 .. r4c7]".
     */
    std::string toString() const;
};

/*
 * I/O stream operators for writing location ranges in their toString format.
 */
std::ostream& operator <<(std::ostream& out, const GridLocationRange& range);

#endif // _gridlocation_h

/////////////////////// END code extracted from StanfordCPPLib/collections/gridlocation.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/grid.h ///////////////////////
/*
 * File: grid.h
 * ------------
 * This file exports the <code>Grid</code> class, which offers a
 * convenient abstraction for representing a two-dimensional array.
 *
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2018/03/12
 * - added overloads that accept GridLocation: get, inBounds, locations, set, operator []
 * @version 2018/03/10
 * - added methods front, back, clear
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2016/12/09
 * - bug fix in resize method (credit to Liu Ren)
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * - made member variables actually private (oops)
 * - added size() method
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as
 *   {{1, 2, 3}, {4, 5, 6}}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/20
 * - minor bug fixes in member initializers
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 * @version 2014/10/10
 * - added resize(true) function with ability to retain old contents
 * - made ==, != operators const as they should be
 * - added comparison operators ==, !=
 * 2014/08/16
 * - added width, height functions; added mapAllColumnMajor
 * 2014/07/09
 * - changed checkGridIndexes range checking function into a private member
 *   function to avoid unused-function errors on some newer compilers
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _grid_h
#define _grid_h

#include <initializer_list>
#include <iostream>
#include <string>
#include <sstream>
#include <functional>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: Grid<ValueType>
 * ----------------------
 * This class stores an indexed, two-dimensional array.  The following code,
 * for example, creates an identity matrix of size <code>n</code>, in which
 * the elements are 1.0 along the main diagonal and 0.0 everywhere else:
 *
 *<pre>
 *    Grid&lt;double&gt; createIdentityMatrix(int n) {
 *       Grid&lt;double&gt; matrix(n, n);
 *       for (int i = 0; i &lt; n; i++) {
 *          matrix[i][i] = 1.0;
 *       }
 *       return matrix;
 *    }
 *</pre>
 */

template <typename ValueType>
class Grid {
public:
    /* Forward reference */
    class GridRow;
    class GridRowConst;

    /*
     * Constructor: Grid
     * Usage: Grid<ValueType> grid;
     *        Grid<ValueType> grid(nRows, nCols);
     * ------------------------------------------
     * Initializes a new grid.  The second form of the constructor is
     * more common and creates a grid with the specified number of rows
     * and columns.  Each element of the grid is initialized to the
     * default value for the type.  The default constructor creates an
     * empty grid for which the client must call <code>resize</code> to
     * set the dimensions.
     * The three-argument constructor also accepts an initial value and
     * fills every cell of the grid with that value.
     */
    Grid() = default;
    Grid(int _rowCount, int _columnCount);
    Grid(int _rowCount, int _columnCount, const ValueType& value);

    /*
     * This constructor uses an initializer list to set up the grid.
     * Usage: Grid<int> grid {{1, 2, 3}, {4, 5, 6}};
     */
    Grid(std::initializer_list<std::initializer_list<ValueType>> list);

    /*
     * Destructor: ~Grid
     * -----------------
     * Frees any heap storage associated with this grid.
     */
    virtual ~Grid() = default;
    
    /*
     * Method: back
     * Usage: ValueType value = grid.back();
     * -------------------------------------
     * Returns the last value in the grid in the order established by the
     * <code>foreach</code> macro.
     * This is equivalent to grid[numRows - 1][numCols - 1].
     * If the grid is empty, generates an error.
     */
    ValueType back() const;

    /*
     * Method: clear
     * Usage: grid.clear();
     * --------------------
     * Sets every value in the grid to its element type's default value.
     */
    void clear();

    /*
     * Method: equals
     * Usage: if (grid.equals(grid2)) ...
     * ----------------------------------
     * Returns <code>true</code> if this grid contains exactly the same
     * values as the given other grid.
     * Identical in behavior to the == operator.
     */
    bool equals(const Grid<ValueType>& grid2) const;
    
    /*
     * Method: fill
     * Usage: grid.fill(value);
     * ------------------------
     * Stores the given value in every cell of this grid.
     */
    void fill(const ValueType& value);

    /*
     * Method: front
     * Usage: ValueType value = grid.front();
     * --------------------------------------
     * Returns the first value in the grid in the order established by the
     * <code>foreach</code> macro.  This is equivalent to grid[0][0].
     * If the grid is empty, generates an error.
     */
    ValueType front() const;

    /*
     * Method: get
     * Usage: ValueType value = grid.get(row, col);
     * --------------------------------------------
     * Returns the element at the specified <code>row</code>/<code>col</code>
     * position in this grid.  This method signals an error if the
     * <code>row</code> and <code>col</code> arguments are outside
     * the grid boundaries.
     */
    ValueType get(int row, int col);
    const ValueType& get(int row, int col) const;
    ValueType get(const GridLocation& loc);
    const ValueType& get(const GridLocation& loc) const;

    /*
     * Method: height
     * Usage: int nRows = grid.height();
     * ---------------------------------
     * Returns the grid's height, that is, the number of rows in the grid.
     */
    int height() const;
    
    /*
     * Method: inBounds
     * Usage: if (grid.inBounds(row, col)) ...
     * ---------------------------------------
     * Returns <code>true</code> if the specified row and column position
     * is inside the bounds of the grid.
     */
    bool inBounds(int row, int col) const;
    bool inBounds(const GridLocation& loc) const;

    /*
     * Method: isEmpty
     * Usage: if (grid.isEmpty()) ...
     * ---------------------------------------
     * Returns <code>true</code> if the grid has 0 rows and/or 0 columns.
     */
    bool isEmpty() const;

    /*
     * Method: locations
     * Usage: for (GridLocation loc : grid.locations()) ...
     * ----------------------------------------------------
     * Returns a range of (row,col) locations found in this grid.
     * This allows a nice abstraction for looping over the 2D grid range
     * of indexes using a single for loop.
     * By default the locations are arranged in row-major order,
     * but if you pass the rowMajor parameter of false, the locations will be
     * returned in column-major order instead.
     */
    GridLocationRange locations(bool rowMajor = true) const;

    /*
     * Method: mapAll
     * Usage: grid.mapAll(fn);
     * -----------------------
     * Calls the specified function on each element of the grid.  The
     * elements are processed in <b><i>row-major order,</i></b> in which
     * all the elements of row 0 are processed, followed by the elements
     * in row 1, and so on.
     */
    void mapAll(std::function<void (const ValueType &)>) const;

    /*
     * Method: mapAllColumnMajor
     * Usage: grid.mapAllColumnMajor(fn);
     * ----------------------------------
     * Calls the specified function on each element of the grid.  The
     * elements are processed in <b><i>column-major order,</i></b> in which
     * all the elements of column 0 are processed, followed by the elements
     * in column 1, and so on.
     */
    void mapAllColumnMajor(std::function<void (const ValueType &)>) const;

    /*
     * Method: numCols
     * Usage: int nCols = grid.numCols();
     * ----------------------------------
     * Returns the number of columns in the grid.
     * This is equal to the grid's width.
     */
    int numCols() const;

    /*
     * Method: numRows
     * Usage: int nRows = grid.numRows();
     * ----------------------------------
     * Returns the number of rows in the grid.
     * This is equal to the grid's height.
     */
    int numRows() const;

    /*
     * Method: resize
     * Usage: grid.resize(nRows, nCols);
     * ---------------------------------
     * Reinitializes the grid to have the specified number of rows
     * and columns.  If the 'retain' parameter is true,
     * the previous grid contents are retained as much as possible.
     * If 'retain' is not passed or is false, any previous grid contents
     * are discarded.
     */
    void resize(int _rowCount, int _columnCount, bool retain = false);

    /*
     * Method: set
     * Usage: grid.set(row, col, value);
     * ---------------------------------
     * Replaces the element at the specified <code>row</code>/<code>col</code>
     * location in this grid with a new value.  This method signals an error
     * if the <code>row</code> and <code>col</code> arguments are outside
     * the grid boundaries.
     */
    void set(int row, int col, const ValueType& value);
    void set(const GridLocation& loc, const ValueType& value);

    /*
     * Method: size
     * Usage: int size = grid.size();
     * ------------------------------
     * Returns the total number of elements in the grid, which is equal to the
     * number of rows times the number of columns.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = grid.toString();
     * ------------------------------------
     * Converts the grid to a printable string representation.
     * The string returned is a 1-dimensional representation such as:
     * "{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}"
     */
    std::string toString() const;

    /*
     * Method: toString2D
     * Usage: string str = grid.toString2D();
     * --------------------------------------
     * Converts the grid to a printable string representation.
     * The string returned is a 2-dimensional representation such as:
     * "{{1, 2, 3},\n
     *   {4, 5, 6},\n
     *   {7, 8, 9}}"
     */
    std::string toString2D(
            std::string rowStart = "{",
            std::string rowEnd = "}",
            std::string colSeparator = ", ",
            std::string rowSeparator = ",\n ") const;

    /*
     * Method: width
     * Usage: int nCols = grid.width();
     * --------------------------------
     * Returns the grid's width, that is, the number of columns in the grid.
     */
    int width() const;


    /*
     * Operator: []
     * Usage:  grid[row][col]
     * ----------------------
     * Overloads <code>[]</code> to select elements from this grid.
     * This extension enables the use of traditional array notation to
     * get or set individual elements.  This method signals an error if
     * the <code>row</code> and <code>col</code> arguments are outside
     * the grid boundaries.
     */
    GridRow operator [](int row);
    const GridRowConst operator [](int row) const;
    ValueType& operator [](const GridLocation& loc);
    const ValueType& operator [](const GridLocation& loc) const;

    /*
     * Additional Grid operations
     * --------------------------
     * In addition to the methods listed in this interface, the Grid
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * The iteration forms process the grid in row-major order.
     */
    
    /*
     * Operator: ==
     * Usage: if (grid1 == grid2) ...
     * ------------------------------
     * Compares two grids for equality.
     */
    bool operator ==(const Grid& grid2) const;

    /*
     * Operator: !=
     * Usage: if (grid1 != grid2) ...
     * ------------------------------
     * Compares two grids for inequality.
     */
    bool operator !=(const Grid& grid2) const;
    
    /*
     * Operators: <, >, <=, >=
     * Usage: if (grid1 < grid2) ...
     * -----------------------------
     * Relational operators to compare two grids.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const Grid& grid2) const;
    bool operator <=(const Grid& grid2) const;
    bool operator >(const Grid& grid2) const;
    bool operator >=(const Grid& grid2) const;

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes: Grid data structure
     * -----------------------------------------
     * The Grid is internally managed as a dynamic array of elements.
     * The array itself is one-dimensional, the logical separation into
     * rows and columns is done by arithmetic computation.  The layout
     * is in row-major order, which is to say that the entire first row
     * is laid out contiguously, followed by the entire second row,
     * and so on.
     */

private:
    /* Instance variables */
    Vector<ValueType> _elements;   // The elements, in row-major order
    int _rowCount = 0;             // The number of rows in the grid
    int _columnCount = 0;          // The number of columns in the grid

    /* Private method prototypes */

    /*
     * Throws an ErrorException if the given row/col are not within the range of
     * (0,0) through (rowMax-1,colMax-1) inclusive.
     * This is a consolidated error handler for all various Grid members that
     * accept index parameters.
     * The prefix parameter represents a text string to place at the start of
     * the error message, generally to help indicate which member threw the error.
     */
    void checkIndexes(int row, int col,
                      int rowMax, int colMax,
                      std::string prefix) const;
    int gridCompare(const Grid& grid2) const;

    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

public:
    using iterator       = typename Vector<ValueType>::iterator;
    using const_iterator = typename Vector<ValueType>::const_iterator;

    iterator begin() {
        return _elements.begin();
    }
    iterator end() {
        return _elements.end();
    }

    const_iterator begin() const {
        return _elements.begin();
    }
    const_iterator end() const {
        return _elements.end();
    }

    /*
     * Private class: Grid<ValType>::GridRow
     * -------------------------------------
     * This section of the code defines a nested class within the Grid template
     * that makes it possible to use traditional subscripting on Grid values.
     */
    class GridRow {
    public:
        GridRow() : _gp(nullptr), _row(0) {
            /* Empty */
        }

        ValueType& operator [](int col) {
            _gp->checkIndexes(_row, col, _gp->_rowCount-1, _gp->_columnCount-1, "operator [][]");
            return _gp->_elements[(_row * _gp->_columnCount) + col];
        }

        ValueType operator [](int col) const {
            _gp->checkIndexes(_row, col, _gp->_rowCount-1, _gp->_columnCount-1, "operator [][]");
            return _gp->_elements[(_row * _gp->_columnCount) + col];
        }

        int size() const {
            return _gp->width();
        }

    private:
        GridRow(Grid* gridRef, int index) {
            _gp = gridRef;
            _row = index;
        }

        Grid* _gp;
        int _row;
        friend class Grid;
    };
    friend class GridRow;

    class GridRowConst {
    public:
        GridRowConst() : _gp(nullptr), _row(0) {
            /* Empty */
        }

        const ValueType operator [](int col) const {
            _gp->checkIndexes(_row, col, _gp->_rowCount-1, _gp->_columnCount-1, "operator [][]");
            return _gp->_elements[(_row * _gp->_columnCount) + col];
        }

        int size() const {
            return _gp->width();
        }

    private:
        GridRowConst(Grid* const gridRef, int index) : _gp(gridRef), _row(index) {}

        const Grid* const _gp;
        const int _row;
        friend class Grid;
    };
    friend class GridRowConst;

    template <typename T>
    friend int hashCode(const Grid<T>& g);
};

template <typename ValueType>
Grid<ValueType>::Grid(int numRows, int numCols) {
    resize(numRows, numCols);
}

template <typename ValueType>
Grid<ValueType>::Grid(int numRows, int numCols, const ValueType& value) {
    resize(numRows, numCols);
    fill(value);
}

template <typename ValueType>
Grid<ValueType>::Grid(std::initializer_list<std::initializer_list<ValueType>> list) {
    // create the grid at the proper size
    _rowCount = list.size();
    if (list.begin() != list.end()) {
        _columnCount = list.begin()->size();
    }
    resize(_rowCount, _columnCount);

    // copy the data from the initializer list into the Grid
    auto rowItr = list.begin();
    for (int row = 0; row < _rowCount; row++) {
        if (static_cast<int>(rowItr->size()) != _columnCount) {
            error("Grid::constructor: initializer list is not rectangular (must have same # cols in each row)");
        }
        auto colItr = rowItr->begin();
        for (int col = 0; col < _columnCount; col++) {
            set(row, col, *colItr);
            colItr++;
        }
        rowItr++;
    }
}

template <typename ValueType>
ValueType Grid<ValueType>::back() const {
    if (isEmpty()) {
        error("Grid::back: grid is empty");
    }
    return get(_rowCount - 1, _columnCount - 1);
}

template <typename ValueType>
void Grid<ValueType>::clear() {
    ValueType defaultValue = ValueType();
    for (int r = 0; r < _rowCount; r++) {
        for (int c = 0; c < _columnCount; c++) {
            set(r, c, defaultValue);
        }
    }
}

template <typename ValueType>
bool Grid<ValueType>::equals(const Grid<ValueType>& grid2) const {
    // optimization: if literally same grid, stop
    if (this == &grid2) {
        return true;
    }
    
    if (_rowCount != grid2._rowCount || _columnCount != grid2._columnCount) {
        return false;
    }
    for (int row = 0; row < _rowCount; row++) {
        for (int col = 0; col < _columnCount; col++) {
            if (get(row, col) != grid2.get(row, col)) {
                return false;
            }
        }
    }
    return true;
}

template <typename ValueType>
void Grid<ValueType>::fill(const ValueType& value) {
    for (int row = 0; row < _rowCount; row++) {
        for (int col = 0; col < _columnCount; col++) {
            set(row, col, value);
        }
    }

    /* This counts as a semantic update, so we must update the version. */
    _elements.updateVersion();
}

template <typename ValueType>
ValueType Grid<ValueType>::front() const {
    if (isEmpty()) {
        error("Grid::front: grid is empty");
    }
    return get(0, 0);
}

template <typename ValueType>
ValueType Grid<ValueType>::get(int row, int col) {
    checkIndexes(row, col, _rowCount-1, _columnCount-1, "get");
    return _elements[(row * _columnCount) + col];
}

template <typename ValueType>
const ValueType& Grid<ValueType>::get(int row, int col) const {
    checkIndexes(row, col, _rowCount-1, _columnCount-1, "get");
    return _elements[(row * _columnCount) + col];
}

template <typename ValueType>
ValueType Grid<ValueType>::get(const GridLocation& loc) {
    return get(loc.row, loc.col);
}

template <typename ValueType>
const ValueType& Grid<ValueType>::get(const GridLocation& loc) const {
    return get(loc.row, loc.col);
}

template <typename ValueType>
int Grid<ValueType>::height() const {
    return _rowCount;
}

template <typename ValueType>
bool Grid<ValueType>::inBounds(int row, int col) const {
    return row >= 0 && col >= 0 && row < _rowCount && col < _columnCount;
}

template <typename ValueType>
bool Grid<ValueType>::inBounds(const GridLocation& loc) const {
    return inBounds(loc.row, loc.col);
}

template <typename ValueType>
bool Grid<ValueType>::isEmpty() const {
    return _rowCount == 0 || _columnCount == 0;
}

template <typename ValueType>
GridLocationRange Grid<ValueType>::locations(bool rowMajor) const {
    return GridLocationRange(0, 0, numRows() - 1, numCols() - 1, rowMajor);
}

template <typename ValueType>
void Grid<ValueType>::mapAll(std::function<void (const ValueType &)> fn) const {
    for (int i = 0; i < _rowCount; i++) {
        for (int j = 0; j < _columnCount; j++) {
            fn(get(i, j));
        }
    }
}

template <typename ValueType>
void Grid<ValueType>::mapAllColumnMajor(std::function<void (const ValueType &)> fn) const {
    for (int j = 0; j < _columnCount; j++) {
        for (int i = 0; i < _rowCount; i++) {
            fn(get(i, j));
        }
    }
}

template <typename ValueType>
int Grid<ValueType>::numCols() const {
    return _columnCount;
}

template <typename ValueType>
int Grid<ValueType>::numRows() const {
    return _rowCount;
}

template <typename ValueType>
void Grid<ValueType>::resize(int numRows, int numCols, bool retain) {
    if (numRows < 0 || numCols < 0) {
        std::ostringstream out;
        out << "Grid::resize: Attempt to resize grid to invalid size ("
               << numRows << ", " << numCols << ")";
        error(out.str());
    }

    // optimization: don't do the resize if we are already that size
    if (numRows == this->_rowCount && numCols == this->_columnCount && retain) {
        /* We need to update the version because semantically we've changed the grid,
         * but we haven't touched our vector.
         */
        _elements.updateVersion();
        return;
    }
    
    // save backup of old array/size
    Vector<ValueType> oldElements = std::move(_elements);
    int oldnRows = this->_rowCount;
    int oldnCols = this->_columnCount;
    
    // create new empty array and set new size
    this->_rowCount = numRows;
    this->_columnCount = numCols;
    this->_elements = Vector<ValueType>(numRows * numCols, ValueType());
    
    // possibly retain old contents
    if (retain) {
        int minRows = oldnRows < numRows ? oldnRows : numRows;
        int minCols = oldnCols < numCols ? oldnCols : numCols;
        for (int row = 0; row < minRows; row++) {
            for (int col = 0; col < minCols; col++) {
                this->_elements[(row * numCols) + col] = oldElements[(row * oldnCols) + col];
            }
        }
    }
}

template <typename ValueType>
void Grid<ValueType>::set(int row, int col, const ValueType& value) {
    checkIndexes(row, col, _rowCount - 1, _columnCount - 1, "set");
    _elements[(row * _columnCount) + col] = value;
}

template <typename ValueType>
void Grid<ValueType>::set(const GridLocation& loc, const ValueType& value) {
    set(loc.row, loc.col, value);
}

template <typename ValueType>
int Grid<ValueType>::size() const {
    return _rowCount * _columnCount;
}

template <typename ValueType>
std::string Grid<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
std::string Grid<ValueType>::toString2D(
        std::string rowStart, std::string rowEnd,
        std::string colSeparator, std::string rowSeparator) const {
    std::ostringstream os;
    os << rowStart;
    int nr = numRows();
    int nc = numCols();
    for (int i = 0; i < nr ; i++) {
        if (i > 0) {
            os << rowSeparator;
        }
        os << rowStart;
        for (int j = 0; j < nc; j++) {
            if (j > 0) {
                os << colSeparator;
            }
            writeGenericValue(os, get(i, j), /* forceQuotes */ true);
        }
        os << rowEnd;
    }
    os << rowEnd;
    return os.str();
}

template <typename ValueType>
int Grid<ValueType>::width() const {
    return _columnCount;
}

template <typename ValueType>
typename Grid<ValueType>::GridRow Grid<ValueType>::operator [](int row) {
    return GridRow(this, row);
}

template <typename ValueType>
ValueType& Grid<ValueType>::operator [](const GridLocation& loc) {
    checkIndexes(loc.row, loc.col, _rowCount-1, _columnCount-1, "operator []");
    return _elements[(loc.row * _columnCount) + loc.col];
}

template <typename ValueType>
const typename Grid<ValueType>::GridRowConst
Grid<ValueType>::operator [](int row) const {
    return GridRowConst(const_cast<Grid*>(this), row);
}

template <typename ValueType>
const ValueType& Grid<ValueType>::operator [](const GridLocation& loc) const {
    checkIndexes(loc.row, loc.col, _rowCount-1, _columnCount-1, "operator []");
    return _elements[(loc.row * _columnCount) + loc.col];
}

template <typename ValueType>
bool Grid<ValueType>::operator ==(const Grid& grid2) const {
    return equals(grid2);
}

template <typename ValueType>
bool Grid<ValueType>::operator !=(const Grid& grid2) const {
    return !equals(grid2);
}

template <typename ValueType>
bool Grid<ValueType>::operator <(const Grid& grid2) const {
    return gridCompare(grid2) < 0;
}

template <typename ValueType>
bool Grid<ValueType>::operator <=(const Grid& grid2) const {
    return gridCompare(grid2) <= 0;
}

template <typename ValueType>
bool Grid<ValueType>::operator >(const Grid& grid2) const {
    return gridCompare(grid2) > 0;
}

template <typename ValueType>
bool Grid<ValueType>::operator >=(const Grid& grid2) const {
    return gridCompare(grid2) >= 0;
}

template <typename ValueType>
void Grid<ValueType>::checkIndexes(int row, int col,
                                   int rowMax, int colMax,
                                   std::string prefix) const {
    const int rowMin = 0;
    const int colMin = 0;
    if (row < rowMin || row > rowMax || col < colMin || col > colMax) {
        std::ostringstream out;
        out << "Grid::" << prefix << ": (" << row << ", " << col << ")"
            << " is outside of valid range [";
        if (rowMin < rowMax && colMin < colMax) {
            out << "(" << rowMin << ", " << colMin <<  ")..("
                << rowMax << ", " << colMax << ")";
        } else if (rowMin == rowMax && colMin == colMax) {
            out << "(" << rowMin << ", " << colMin <<  ")";
        } // else min > max, no range, empty grid
        out << "]";
        error(out.str());
    }
}

template <typename ValueType>
int Grid<ValueType>::gridCompare(const Grid& grid2) const {
    if (_rowCount != grid2._rowCount) return _rowCount - grid2._rowCount;
    if (_columnCount != grid2._columnCount) return _columnCount - grid2._columnCount;
    return stanfordcpplib::collections::compare(_elements, grid2._elements);
}

template <typename ValueType>
int hashCode(const Grid<ValueType>& g) {
    return hashCode(g._rowCount, g._columnCount, g._elements);
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const Grid<ValueType>& grid) {
    os << "{";
    int nRows = grid.numRows();
    int nCols = grid.numCols();
    for (int i = 0; i < nRows; i++) {
        if (i > 0) {
            os << ", ";
        }
        os << "{";
        for (int j = 0; j < nCols; j++) {
            if (j > 0) {
                os << ", ";
            }
            writeGenericValue(os, grid.get(i, j), /* forceQuotes */ true);
        }
        os << "}";
    }
    return os << "}";
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, Grid<ValueType>& grid) {
    Vector<Vector<ValueType>> vec2d;
    if (!(is >> vec2d)) {
        is.setstate(std::ios_base::failbit);
        return is;
    }

    int nRows = vec2d.size();
    int nCols = (nRows == 0) ? 0 : vec2d[0].size();
    grid.resize(nRows, nCols);
    for (int i = 0; i < nRows; i++) {
        for (int j = 0; j < nCols; j++) {
            grid[i][j] = vec2d[i][j];
        }
    }

    return is;
}

/*
 * Function: randomElement
 * Usage: element = randomElement(grid);
 * -------------------------------------
 * Returns a randomly chosen element of the given grid.
 * Throws an error if the grid is empty.
 */
template <typename T>
const T& randomElement(const Grid<T>& grid) {
    if (grid.isEmpty()) {
        error("randomElement: empty grid was passed");
    }

    int randomIndex = randomInteger(0, grid.size() - 1);
    int row = randomIndex / grid.numCols();
    int col = randomIndex % grid.numCols();
    return grid.get(row, col);
}

/*
 * Randomly rearranges the elements of the given grid.
 */
template <typename T>
void shuffle(Grid<T>& grid) {
    int rows = grid.numRows();
    int cols = grid.numCols();
    int length = rows * cols;
    for (int i = 0; i < length; i++) {
        int j = randomInteger(i, length - 1);
        if (i != j) {
            int r1 = i / cols;
            int c1 = i % cols;
            int r2 = j / cols;
            int c2 = j % cols;
            T temp = grid[r1][c1];
            grid[r1][c1] = grid[r2][c2];
            grid[r2][c2] = temp;
        }
    }
}

#endif // _grid_h

/////////////////////// END code extracted from StanfordCPPLib/collections/grid.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/lexicon.h ///////////////////////
/*
 * File: lexicon.h
 * ---------------
 * This file exports the <code>Lexicon</code> class, which is a
 * compact structure for storing a list of words.
 *
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @author Marty Stepp
 * @version 2018/03/10
 * - added methods front, back
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via Set)
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/12
 * - added methods addAll, containsAll, removeAll, retainAll,
 *   operators +, +=, -, -=, *, *= to better match Set/HashSet
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as {"a", "b", "c"}
 * @version 2014/11/13
 * - added comparison operators <, >= etc.
 * - added hashCode function
 * @version 2014/10/10
 * - added equals method, comparison operators ==, !=
 * - fixed inclusion of foreach macro to avoid errors
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _lexicon_h
#define _lexicon_h

#include <initializer_list>
#include <iterator>
#include <set>
#include <string>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * This class is used to represent a <b><i>lexicon,</i></b> or word list.
 * The main difference between a lexicon and a dictionary is that
 * a lexicon does not provide any mechanism for storing definitions;
 * the lexicon contains only words, with no associated information.
 * It is therefore similar to a set of strings, but with a more
 * space-efficient internal representation.  The <code>Lexicon</code>
 * class supports efficient lookup operations for words and prefixes.
 *
 * <p>As an example of the use of the <code>Lexicon</code> class, the
 * following program lists all the two-letter words in the lexicon
 * stored in <code>EnglishWords.dat</code>:
 *
 *<pre>
 *    int main() {
 *       Lexicon english("EnglishWords.dat");
 *       for (string word : english) {
 *          if (word.length() == 2) {
 *             cout << word << endl;
 *          }
 *       }
 *       return 0;
 *    }
 *</pre>
 */

class Lexicon {
public:
    /*
     * Constructor: Lexicon
     * Usage: Lexicon lex;
     *        Lexicon lex(filename);
     * -----------------------------
     * Initializes a new lexicon.  The default constructor creates an empty
     * lexicon.  The second form reads in the contents of the lexicon from
     * the specified data file.  The data file must be in one of two formats:
     * (1) a space-efficient precompiled binary format or (2) a text file
     * containing one word per line.  The Stanford library distribution
     * includes a binary lexicon file named <code>English.dat</code>
     * containing a list of words in English.  The standard code pattern
     * to initialize that lexicon looks like this:
     *
     *<pre>
     *    Lexicon english("English.dat");
     *</pre>
     */
    Lexicon();
    Lexicon(std::istream& input);
    Lexicon(const std::string& filename);

    /*
     * This constructor uses an initializer list to set up the lexicon.
     * Usage: Lexicon lex {1, 2, 3};
     */
    Lexicon(std::initializer_list<std::string> list);

    /*
     * Destructor: ~Lexicon
     * --------------------
     * The destructor deallocates any storage associated with the lexicon.
     */
    virtual ~Lexicon();

    /**
     * Adds the specified word to the lexicon, if not already present.
     * The word is converted to lowercase before adding it to the lexicon.
     * If the word contains any non-alphabetic characters (including whitespace),
     * it will not be added. The empty string cannot be added to a lexicon.
     * Returns true if the word was added successfully to the lexicon.
     */
    bool add(const std::string& word);

    /**
     * Adds all elements of the given other lexicon to this lexicon.
     * Returns a reference to this lexicon.
     * Identical in behavior to the += operator.
     */
    Lexicon& addAll(const Lexicon& lex);

    /**
     * Adds all elements of the given initializer list to this lexicon.
     * Returns a reference to this lexicon.
     * Identical in behavior to the += operator.
     */
    Lexicon& addAll(std::initializer_list<std::string> list);

    /**
     * Reads the given input stream and adds all of its words to the lexicon.
     * Each word from the stream is converted to lowercase before adding it.
     */
    void addWordsFromFile(std::istream& input);
    
    /**
     * Reads the file and adds all of its words to the lexicon.
     * Each word from the file is converted to lowercase before adding it.
     */
    void addWordsFromFile(const std::string& filename);

    /**
     * Returns the last value in the lexicon in alphabetical order.
     * If the set is empty, generates an error.
     */
    std::string back() const;

    /**
     * Removes all words from the lexicon.
     */
    void clear();

    /**
     * Returns <code>true</code> if <code>word</code> is contained in the
     * lexicon.  In the <code>Lexicon</code> class, the case of letters is
     * ignored, so "Zoo" is the same as "ZOO" or "zoo".
     * The empty string cannot be contained in a lexicon, nor can any word
     * containing any non-alphabetic characters such as punctuation or whitespace.
     */
    bool contains(const std::string& word) const;

    /**
     * Returns <code>true</code> if every value from the given other lexicon
     * is also found in this lexicon.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(const Lexicon& set2) const;

    /**
     * Returns <code>true</code> if every value from the given initializer list
     * is also found in this lexicon.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(std::initializer_list<std::string> list) const;

    /**
     * Returns true if any words in the lexicon begin with <code>prefix</code>.
     * Like <code>containsWord</code>, this method ignores the case of letters
     * so that "MO" is a prefix of "monkey" or "Monday".
     * The empty string is a prefix of every string, so this method returns
     * true when passed the empty string.
     */
    bool containsPrefix(const std::string& prefix) const;

    /**
     * Compares two lexicons for equality.
     */
    bool equals(const Lexicon& lex2) const;

    /**
     * Returns the first value in the lexicon in alphabetical order.
     * If the set is empty, <code>first</code> generates an error.
     * Equivalent to first.
     */
    std::string first() const;

    /**
     * Returns the first value in the lexicon in alphabetical order.
     * If the set is empty, generates an error.
     * Equivalent to first.
     */
    std::string front() const;

    /**
     * Adds an element to this lexicon, if it was not already there.  This
     * method is exported for compatibility with the STL <code>set</code> class.
     */
    void insert(const std::string& word);

    /**
     * Returns <code>true</code> if the lexicon contains no words.
     */
    bool isEmpty() const;

    /**
     * Returns whether every word of this lexicon is contained in the given set.
     */
    bool isSubsetOf(const Lexicon& lex2) const;

    /**
     * Returns whether every word of this lexicon is contained in the given
     * initializer list.
     */
    bool isSubsetOf(std::initializer_list<std::string> list) const;

    /**
     * Returns whether every word of the given lexicon is contained in this lexicon.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(const Lexicon& lex2) const;

    /**
     * Returns whether every word of the given list is contained in this lexicon.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(std::initializer_list<std::string> list) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    void mapAll(void (*fn)(std::string)) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    void mapAll(void (*fn)(const std::string&)) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    /**
     * Removes the specified word from the lexicon, if it was present.
     * Returns true if the word was previously contained in the lexicon;
     * in other words, if a word was removed.
     * The empty string cannot be contained in a lexicon, so passing the
     * empty string to this method returns false.
     */
    bool remove(const std::string& word);

    /**
     * Removes all elements of the given other lexicon from this lexicon.
     * Returns a reference to this lexicon.
     * Identical in behavior to the -= operator.
     */
    Lexicon& removeAll(const Lexicon& lex);

    /**
     * Removes all elements of the given other list from this lexicon.
     * Returns a reference to this lexicon.
     * Identical in behavior to the -= operator.
     */
    Lexicon& removeAll(std::initializer_list<std::string> list);

    /**
     * Removes all words from the lexicon that begin with the given prefix.
     * Returns true if the prefix was previously contained in the lexicon;
     * in other words, if any words were removed.
     * If the empty string is passed, since all words begin with the empty
     * string, all words will be removed and this method will
     * return true if the lexicon was non-empty prior to the call.
     */
    bool removePrefix(const std::string& prefix);

    /**
     * Removes all elements from this lexicon that are not contained in the given
     * other lexicon.
     * Returns a reference to this lexicon.
     * Identical in behavior to the *= operator.
     */
    Lexicon& retainAll(const Lexicon& lex);

    /**
     * Removes all elements from this lexicon that are not contained in the given
     * initializer list.
     * Returns a reference to this lexicon.
     * Identical in behavior to the *= operator.
     */
    Lexicon& retainAll(std::initializer_list<std::string> list);

    /**
     * Returns the number of words contained in the lexicon.
     */
    int size() const;

    /**
     * Converts the lexicon to a printable string representation
     * such as <code>{"a", "b", "c"}</code>.
     * Note that this can be an expensive operation if the lexicon contains
     * a large number of words.
     */
    std::string toString() const;

    /**
     * Returns true if two lexicons have the same elements.
     */
    bool operator ==(const Lexicon& lex2) const;

    /**
     * Returns true if two lexicons do not have the same elements.
     */
    bool operator !=(const Lexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons.
     */
    bool operator <(const Lexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons.
     */
    bool operator <=(const Lexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons.
     */
    bool operator >(const Lexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons.
     */
    bool operator >=(const Lexicon& lex2) const;

    /**
     * Returns the union of lexicons <code>lex1</code> and <code>lex2</code>,
     * which is the set of words that appear in at least one of the two.
     */
    Lexicon operator +(const Lexicon& lex2) const;

    /**
     * Returns the union of this lexicon and the words in the given list,
     * which is the set of words that appear in at least one of the two.
     */
    Lexicon operator +(std::initializer_list<std::string> list) const;

    /**
     * Returns the union of this lexicon and the given word.
     */
    Lexicon operator +(const std::string& word) const;

    /**
     * Returns the intersection of two lexicons,
     * which is the set of all words that appear in both.
     */
    Lexicon operator *(const Lexicon& lex2) const;

    /**
     * Returns the intersection of this lexicons and the given list,
     * which is the set of all words that appear in both.
     */
    Lexicon operator *(std::initializer_list<std::string> list) const;

    /**
     * Returns the difference of two lexicons,
     * which is all of the words that appear in <code>lex1</code> but
     * not <code>lex2</code>.
     * You can also pass an initializer list such as {"a", "b", "c"}.
     * The right hand set can be replaced by a single word, in
     * which case the operator returns a new lexicon formed by removing that word.
     */
    Lexicon operator -(const Lexicon& lex2) const;

    /**
     * Returns the difference of two lexicons,
     * which is all of the words that appear in this lexicon but not in
     * the given initializer list.
     */
    Lexicon operator -(std::initializer_list<std::string> list) const;

    /**
     * Returns a new lexicon formed by removing the given word from this lexicon.
     */
    Lexicon operator -(const std::string& word) const;

    /**
     * Adds all of the words from the given lexicon to this lexicon.
     */
    Lexicon& operator +=(const Lexicon& lex2);

    /**
     * Adds all of the words from the given list to this lexicon.
     */
    Lexicon& operator +=(std::initializer_list<std::string> list);

    /**
     * Adds the specified word to this lexicon.
     */
    Lexicon& operator +=(const std::string& word);

    /**
     * Removes any elements from this lexicon that are not present in
     * <code>lex2</code>.
     */
    Lexicon& operator *=(const Lexicon& lex2);

    /**
     * Removes any elements from this lexicon that are not present in
     * the given initializer list.
     */
    Lexicon& operator *=(std::initializer_list<std::string> list);

    /**
     * Removes all elements in the given lexicon from this lexicon.
     */
    Lexicon& operator -=(const Lexicon& lex2);

    /**
     * Removes all elements in the given list from this lexicon.
     */
    Lexicon& operator -=(std::initializer_list<std::string> list);

    /**
     * Removes the given word from this lexicon.
     */
    Lexicon& operator -=(const std::string& value);

    /**
     * Allows you to add multiple elements to a lexicon.
     * @example lex += "she", "sells", "sea", "shells";
     */
    Lexicon& operator ,(const std::string& word);

    /*
     * Additional Lexicon operations
     * -----------------------------
     * In addition to the methods listed in this interface, the Lexicon
     * class supports the following operations:
     *
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * All iteration is guaranteed to proceed in alphabetical order.  All
     * words in the lexicon are stored in lowercase.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    struct TrieNode {
    public:
        TrieNode() {
            _isWord = false;
            for (int i = 0; i < 26; i++) {
                _children[i] = nullptr;
            }
        }

        // pre: letter is between 'a' and 'z' in lowercase
        inline TrieNode*& child(char letter) {
            return _children[letter - 'a'];
        }

        inline int childCount() const {
            int count = 0;
            for (int i = 0; i < 26; i++) {
                if (_children[i] != nullptr) {
                    count++;
                }
            }
            return count;
        }

        inline bool isLeaf() const {
            return childCount() == 0;
        }

        inline bool isWord() const {
            return _isWord;
        }

        inline void setWord(bool value) {
            _isWord = value;
        }

    private:
        /* instance variables */
        bool _isWord;
        TrieNode* _children[26];   // 0=a, 1=b, 2=c, ..., 25=z
    };

    /*
     * private helper functions, including
     * recursive helpers to implement public add/contains/remove
     */
    bool addHelper(TrieNode*& node, const std::string& word, const std::string& originalWord);
    bool containsHelper(TrieNode* node, const std::string& word, bool isPrefix) const;
    void deepCopy(const Lexicon& src);
    void deleteTree(TrieNode* node);
    bool isDAWGFile(std::istream& input) const;
    bool isDAWGFile(const std::string& filename) const;
    void readBinaryFile(std::istream& input);
    void readBinaryFile(const std::string& filename);
    bool removeHelper(TrieNode*& node, const std::string& word, const std::string& originalWord, bool isPrefix);
    void removeSubtreeHelper(TrieNode*& node, const std::string& originalWord);
    
    friend std::ostream& operator <<(std::ostream& os, const Lexicon& lex);
    friend std::istream& operator >>(std::istream& is, Lexicon& lex);

    /* instance variables */
    TrieNode* _root;
    int _size;
    bool _removeFlag;             // flag to differentiate += and -= when used with ,
    Set<std::string> _allWords;   // secondary structure of all words for foreach;
                                  // basically a cop-out so I can loop over words

public:
    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return lexicons by value
     * and assign from one lexicon to another.  The entire contents of
     * the lexicon, including all words, are copied.  Making copies is
     * generally avoided because of the expense and thus, lexicons are
     * typically passed by reference.  When a copy is needed, these
     * operations are supported.
     */
    Lexicon(const Lexicon& src);
    Lexicon& operator =(const Lexicon& src);

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public Set<std::string>::iterator {
    public:
        iterator() : Set<std::string>::iterator() {}
        iterator(const iterator& it) : Set<std::string>::iterator(it) {}
        iterator(const Set<std::string>::iterator& it) : Set<std::string>::iterator(it) {}
    };

    /**
     * Returns an iterator positioned at the first word in the lexicon.
     */
    iterator begin() const {
        return iterator(_allWords.begin());
    }

    /**
     * Returns an iterator positioned at the last word in the lexicon.
     */
    iterator end() const {
        return iterator(_allWords.end());
    }
};

template <typename FunctorType>
void Lexicon::mapAll(FunctorType fn) const {
    for (std::string word : *this) {
        fn(word);
    }
}

/**
 * Hashing function for lexicons.
 */
int hashCode(const Lexicon& l);

/**
 * Prints the lexicon to the given output stream.
 */
std::ostream& operator <<(std::ostream& os, const Lexicon& lex);

/**
 * Reads the contents of a lexicon from the given input stream.
 */
std::istream& operator >>(std::istream& is, Lexicon& lex);

#endif // _lexicon_h

/////////////////////// END code extracted from StanfordCPPLib/collections/lexicon.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/linkedlist.h ///////////////////////
/*
 * File: linkedlist.h
 * ------------------
 * This file exports the <code>LinkedList</code> class, which provides an
 * implementation of a doubly-linked list of objects and provides a
 * public interface similar to that of the <code>Vector</code> class.
 *
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2019/02/04
 * - changed internal implementation to wrap std collections
 * @version 2018/01/07
 * - added removeFront, removeBack
 * @version 2017/11/15
 * - added contains, indexOf, lastIndexOf, removeValue, reverse, shuffle, sort
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/10
 * - added support for std initializer_list usage, such as {1, 2, 3}
 *   in constructor, addAll, +, +=
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 * @version 2014/10/19
 * - added subList method
 * @version 2014/10/10
 * - removed usage of __foreach macro
 * 2014/07/10
 *  - fixed compiler errors/bugs in initial implementation:
 *    back(), front() members, etc.
 *  - changed checkLinkedListIndex into a member function to avoid warnings
 * @since 2014/07/10
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _linkedlist_h
#define _linkedlist_h

#include <algorithm>
#include <initializer_list>
#include <iostream>
#include <iterator>
#include <list>
#include <sstream>
#include <string>
#include <functional>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: LinkedList<ValueType>
 * ----------------------------
 * This class stores an ordered list of values similar to an array.
 * It supports traditional array selection using square brackets, but
 * also supports inserting and deleting elements.  It is similar in
 * function to the STL <code>list</code> type.
 */
template <typename ValueType>
class LinkedList {
public:
    /*
     * Constructor: LinkedList
     * Usage: LinkedList<ValueType> list;
     * ----------------------------------
     * Initializes a new LinkedList.  The default constructor creates an
     * empty LinkedList.
     */
    LinkedList() = default;
    /* implicit */ LinkedList(const std::list<ValueType>& v);

    /*
     * This constructor uses an initializer list to set up the linked list.
     * Usage: LinkedList<int> list {1, 2, 3};
     */
    LinkedList(std::initializer_list<ValueType> list);

    /*
     * Destructor: ~LinkedList
     * -------------------
     * Frees any heap storage allocated by this LinkedList.
     */
    virtual ~LinkedList() = default;
    
    /*
     * Method: add
     * Usage: list.add(value);
     * ----------------------
     * Adds a new value to the end of this LinkedList.  To ensure compatibility
     * with the <code>LinkedList</code> class in the Standard Template Library,
     * this method is also called <code>push_back</code>.
     */
    void add(ValueType value);
    
    /*
     * Method: addAll
     * Usage: list.addAll(l2);
     * -----------------------
     * Adds all elements of the given other linked list to this list.
     * Returns a reference to this list.
     * Identical in behavior to the += operator.
     * You may also pass an initializer list such as {1, 2, 3}.
     */
    LinkedList<ValueType>& addAll(const LinkedList<ValueType>& list);
    LinkedList<ValueType>& addAll(std::initializer_list<ValueType> list);

    /*
     * Method: back
     * Usage: ValueType val = list.back();
     * -----------------------------------
     * Returns the element at the back (index size-1) of this LinkedList.
     * This method signals an error if the list is empty.
     */
    ValueType& back();
    const ValueType& back() const;

    /*
     * Method: clear
     * Usage: list.clear();
     * --------------------
     * Removes all elements from this LinkedList.
     */
    void clear();
    
    /*
     * Method: contains
     * Usage: if (list.contains(value)) ...
     * ------------------------------------
     * Returns true if the list contains the given value.
     * The ValueType must have an == operator to use this method.
     */
    bool contains(const ValueType& value) const;

    /*
     * Method: equals
     * Usage: if (list.equals(l2)) ...
     * -------------------------------
     * Returns <code>true</code> if this linked list contains exactly the same
     * values as the given other list.
     * Identical in behavior to the == operator.
     */
    bool equals(const LinkedList<ValueType>& l2) const;
    
    /*
     * Method: front
     * Usage: ValueType val = list.front();
     * ------------------------------------
     * Returns the element at the front (index 0) of this LinkedList.
     * This method signals an error if the list is empty.
     */
    ValueType& front();
    const ValueType& front() const;

    /*
     * Method: get
     * Usage: ValueType val = list.get(index);
     * ---------------------------------------
     * Returns the element at the specified index in this LinkedList.  This
     * method signals an error if the index is not in the list range.
     *
     * The client should be mindful that unlike with a vector, this operation
     * is O(N) for linked lists because it must traverse the list to reach
     * the given index.
     */
    const ValueType& get(int index) const;

    /*
     * Method: indexOf
     * Usage: int index = list.indexOf(value);
     * ---------------------------------------
     * Returns the index of the first occurrence of the given value.
     * If the value is not found in the vector, returns -1.
     * The ValueType must have an == operator to use this method.
     */
    int indexOf(const ValueType& value) const;

    /*
     * Method: insert
     * Usage: list.insert(0, value);
     * -----------------------------
     * Inserts the element into this LinkedList before the specified index.
     * This method signals an error if the index is outside the range from 0
     * up to and including the length of the LinkedList.
     */
    void insert(int index, ValueType value);

    /*
     * Method: isEmpty
     * Usage: if (list.isEmpty()) ...
     * ------------------------------
     * Returns <code>true</code> if this LinkedList contains no elements.
     */
    bool isEmpty() const;

    /*
     * Method: lastIndexOf
     * Usage: int index = list.lastIndexOf(value);
     * -------------------------------------------
     * Returns the index of the last occurrence of the given value.
     * If the value is not found in the vector, returns -1.
     * The ValueType must have an == operator to use this method.
     */
    int lastIndexOf(const ValueType& value) const;

    /*
     * Method: mapAll
     * Usage: list.mapAll(fn);
     * ----------------------
     * Calls the specified function on each element of the LinkedList in
     * ascending index order.
     */
    void mapAll(std::function<void (const ValueType &)> fn) const;
    
    /*
     * Method: pop_back
     * Usage: ValueType back = list.pop_back();
     * ------------------------------------------
     * Removes and returns the last value of this LinkedList.
     * Throws an error if the list is empty.
     */
    ValueType pop_back();

    /*
     * Method: pop_front
     * Usage: ValueType front = list.pop_front();
     * ------------------------------------------
     * Removes and returns the first value of this LinkedList.
     * Throws an error if the list is empty.
     */
    ValueType pop_front();
    
    /*
     * Method: push_back
     * Usage: list.push_back(value);
     * -----------------------------
     * Adds a new value to the end of this LinkedList.
     * Same behavior as the <code>add</code> method.
     */
    void push_back(const ValueType& value);

    /*
     * Method: push_front
     * Usage: list.push_front(value);
     * ------------------------------
     * Adds a new value to the front of this LinkedList.
     */
    void push_front(const ValueType& value);
    
    /*
     * Method: remove
     * Usage: list.remove(index);
     * -------------------------
     * Removes the element at the specified index from this LinkedList.
     * This method signals an error if the index is outside the list range.
     */
    void remove(int index);

    /*
     * Method: removeFirst
     * Usage: ValueType val = list.removeFirst();
     * ------------------------------------------
     * Removes and returns the element at index 0 in this list.
     * This method signals an error if list is empty.
     */
    ValueType removeFront();

    /*
     * Method: removeLast
     * Usage: ValueType val = list.removeLast();
     * -----------------------------------------
     * Removes and returns the element at index (size - 1) in this list.
     * This method signals an error if list is empty.
     */
    ValueType removeBack();

    /*
     * Method: removeValue
     * Usage: list.removeValue(value);
     * -------------------------------
     * Removes the first occurrence of the element value from this list.
     * All subsequent elements are shifted one position to the left.
     * If the vector does not contain the given value, has no effect.
     * The ValueType must have an == operator to use this method.
     */
    void removeValue(const ValueType& value);

    /*
     * Method: reverse
     * Usage: list.reverse();
     * ----------------------
     * Reverses the order of the elements in this list.
     * For example, if the list stores {1, 3, 4, 9}, changes it to store {9, 4, 3, 1}.
     */
    void reverse();

    /*
     * Method: set
     * Usage: list.set(index, value);
     * ------------------------------
     * Replaces the element at the specified index in this LinkedList with
     * a new value.  The previous value at that index is overwritten.
     * This method signals an error if the index is not in the list range.
     *
     * The client should be mindful that unlike with a vector, this operation
     * is O(N) for linked lists because it must traverse the list to reach
     * the given index.
     */
    void set(int index, const ValueType& value);

    /*
     * Method: shuffle
     * Usage: list.shuffle();
     * ----------------------
     * Rearranges the order of the elements in this list into a random order.
     */
    void shuffle();

    /*
     * Method: size
     * Usage: int nElems = list.size();
     * --------------------------------
     * Returns the number of elements in this LinkedList.
     */
    int size() const;

    /*
     * Method: sort
     * Usage: list.sort();
     * -------------------
     * Rearranges the order of the elements in this list into sorted order.
     * For example, if the list stores {9, 1, 4, 3}, changes it to store {1, 3, 4, 9}.
     * The ValueType must have an operator < to call this method.
     */
    void sort();

    /*
     * Method: subList
     * Usage: LinkedList<ValueType> sub = list.subList(start, length);
     * ---------------------------------------------------------------
     * Returns a new list containing the given subset range of elements
     * from this list. The new list is a deep copy, not linked to this one.
     * Throws an error if the range (start .. start + length) is not contained
     * within the bounds of this list, or if length is negative.
     */
    LinkedList<ValueType> subList(int start, int length) const;
    
    /*
     * Method: toString
     * Usage: string str = list.toString();
     * ------------------------------------
     * Converts the LinkedList to a printable string representation.
     */
    std::string toString() const;

    /*
     * Operator: []
     * Usage: list[index]
     * -----------------
     * Overloads <code>[]</code> to select elements from this LinkedList.
     * This extension enables the use of traditional array notation to
     * get or set individual elements.  This method signals an error if
     * the index is outside the list range.  The file supports two
     * versions of this operator, one for <code>const</code> LinkedLists and
     * one for mutable LinkedLists.
     *
     * The client should be mindful that this operation is O(N) for linked
     * lists because it must traverse the list to reach the given index.
     */
    ValueType& operator [](int index);
    const ValueType& operator [](int index) const;

    /*
     * Operator: +
     * Usage: v1 + l2
     * --------------
     * Concatenates two LinkedLists, or concatenates this linked list with an
     * initializer list such as {1, 2, 3}.
     */
    LinkedList operator +(const LinkedList& l2) const;
    LinkedList operator +(std::initializer_list<ValueType> list) const;

    /*
     * Operator: +=
     * Usage: l1 += l2;
     *        l1 += value;
     * -------------------
     * Adds all of the elements from <code>l2</code> (or the single
     * specified value) to <code>l1</code>.  As a convenience, the
     * <code>LinkedList</code> package also overloads the comma operator so
     * that it is possible to initialize a LinkedList like this:
     *
     *<pre>
     *    LinkedList&lt;int&gt; digits;
     *    digits += 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
     *</pre>
     * You can also pass an initializer list such as {1, 2, 3}.
     */
    LinkedList& operator +=(const LinkedList& l2);
    LinkedList& operator +=(std::initializer_list<ValueType> list);
    LinkedList& operator +=(const ValueType& value);

    /*
     * Comparing LinkedLists for equality.
     */
    bool operator ==(const LinkedList& list2) const;
    bool operator !=(const LinkedList& list2) const;


    /*
     * Operators: <, >, <=, >=
     * Usage: if (list1 == list2) ...
     * ...
     * -------------------------------
     * Relational operators to compare two lists.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const LinkedList& list2) const;
    bool operator <=(const LinkedList& list2) const;
    bool operator >(const LinkedList& list2) const;
    bool operator >=(const LinkedList& list2) const;

    /*
     * Additional LinkedList operations
     * --------------------------------
     * In addition to the methods listed in this interface, the LinkedList
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement or STL iterators
     *
     * The iteration forms process the LinkedList in index order.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
    /*
     * Implementation notes: LinkedList data structure
     * -------------------------------------------
     * The elements of the LinkedList are stored in a dynamic array of
     * the specified element type.  If the space in the array is ever
     * exhausted, the implementation doubles the array capacity.
     */

    /* Instance variables */
    std::list<ValueType> _elements;   // STL linked list as backing storage
    stanfordcpplib::collections::VersionTracker _version;

    /* Private methods */

    /*
     * Throws an ErrorException if the given index is not within the range of
     * [min..max] inclusive.
     * This is a consolidated error handler for all various LinkedList members that
     * accept index parameters.
     * The prefix parameter represents a text string to place at the start of
     * the error message, generally to help indicate which member threw the error.
     *
     * We make prefix a const char* rather than a std::string to avoid having to
     * construct and then destroy the prefix with each call.
     */
    void checkIndex(int index, int min, int max, const char* prefix) const;

    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

public:

    /*
     * Operator: ,
     * -----------
     * Adds an element to the LinkedList passed as the left-hand operatand.
     * This form makes it easier to initialize LinkedLists in old versions of C++.
     */
    LinkedList& operator ,(const ValueType& value);

    /*
     * Iterator support.
     */
    using iterator = stanfordcpplib::collections::CheckedIterator<typename std::list<ValueType>::iterator>;
    using const_iterator = stanfordcpplib::collections::CheckedIterator<typename std::list<ValueType>::const_iterator>;

    iterator begin() {
        return { &_version, _elements.begin(), _elements };
    }
    iterator end() {
        return { &_version, _elements.end(), _elements };
    }
    const_iterator begin() const {
        return { &_version, _elements.begin(), _elements };
    }
    const_iterator end() const {
        return { &_version, _elements.end(), _elements };
    }
};

/* Implementation section */

template <typename ValueType>
LinkedList<ValueType>::LinkedList(const std::list<ValueType>& v)
        : _elements(v) {
    // empty
}

template <typename ValueType>
LinkedList<ValueType>::LinkedList(std::initializer_list<ValueType> list) : _elements(list) {
    // empty
}

template <typename ValueType>
void LinkedList<ValueType>::add(ValueType value) {
    _elements.push_back(value);
    _version.update();
}

template <typename ValueType>
LinkedList<ValueType>&
LinkedList<ValueType>::addAll(const LinkedList<ValueType>& list) {
    for (const ValueType& value : list) {
        add(value);
    }
    _version.update();
    return *this;
}

template <typename ValueType>
LinkedList<ValueType>& LinkedList<ValueType>::addAll(std::initializer_list<ValueType> list) {
    for (const ValueType& value : list) {
        add(value);
    }
    _version.update();
    return *this;
}

template <typename ValueType>
ValueType& LinkedList<ValueType>::back() {
    return const_cast<ValueType&>(static_cast<const LinkedList &>(*this).back());
}

template <typename ValueType>
const ValueType& LinkedList<ValueType>::back() const {
    if (isEmpty()) {
        error("LinkedList::back: list is empty");
    }
    return _elements.back();
}

template <typename ValueType>
void LinkedList<ValueType>::clear() {
    _elements.clear();
    _version.update();
}

template <typename ValueType>
bool LinkedList<ValueType>::contains(const ValueType& value) const {
    return indexOf(value) >= 0;
}

template <typename ValueType>
bool LinkedList<ValueType>::equals(const LinkedList<ValueType>& list2) const {
    return _elements == list2._elements;
}

template <typename ValueType>
ValueType& LinkedList<ValueType>::front() {
    return const_cast<ValueType&>(static_cast<const LinkedList &>(*this).front());
}

template <typename ValueType>
const ValueType& LinkedList<ValueType>::front() const {
    if (isEmpty()) {
        error("LinkedList::front: list is empty");
    }
    return _elements.front();
}

template <typename ValueType>
const ValueType & LinkedList<ValueType>::get(int index) const {
    checkIndex(index, 0, size()-1, "get");
    return *std::next(_elements.begin(), index);
}

template <typename ValueType>
int LinkedList<ValueType>::indexOf(const ValueType& value) const {
    // loop using iterator to avoid O(N^2) runtime
    int i = 0;
    for (const ValueType& element : *this) {
        if (element == value) {
            return i;
        }
        i++;
    }
    return -1;
}

template <typename ValueType>
void LinkedList<ValueType>::insert(int index, ValueType value) {
    checkIndex(index, 0, size(), "insert");
    auto itr = _elements.begin();
    std::advance(itr, index);
    _elements.insert(itr, value);
    _version.update();
}

template <typename ValueType>
bool LinkedList<ValueType>::isEmpty() const {
    return _elements.empty();
}

template <typename ValueType>
int LinkedList<ValueType>::lastIndexOf(const ValueType& value) const {
    // loop using iterator to avoid O(N^2) runtime
    int i = size();
    auto begin = this->begin();
    auto itr = this->end();
    while (itr != begin) {
        itr--;
        i--;
        if (*itr == value) {
            return i;
        }
    }
    return -1;
}

/*
 * Implementation notes: mapAll
 * ----------------------------
 * The various versions of the mapAll function apply the function or
 * function object to each element in ascending index order.
 */
template <typename ValueType>
void LinkedList<ValueType>::mapAll(std::function<void (const ValueType &)> fn) const {
    for (ValueType element : *this) {
        fn(element);
    }
}

template <typename ValueType>
ValueType LinkedList<ValueType>::pop_back() {
    if (isEmpty()) {
        error("LinkedList::pop_back: list is empty");
    }
    ValueType back = _elements.back();
    _elements.pop_back();
    _version.update();
    return back;
}

template <typename ValueType>
ValueType LinkedList<ValueType>::pop_front() {
    if (isEmpty()) {
        error("LinkedList::pop_front: list is empty");
    }
    ValueType front = _elements.front();
    _elements.pop_front();
    _version.update();
    return front;
}

template <typename ValueType>
void LinkedList<ValueType>::push_back(const ValueType& value) {
    _elements.push_back(value);
    _version.update();
}

template <typename ValueType>
void LinkedList<ValueType>::push_front(const ValueType& value) {
    _elements.push_front(value);
    _version.update();
}

template <typename ValueType>
void LinkedList<ValueType>::remove(int index) {
    checkIndex(index, 0, size()-1, "remove");
    auto itr = _elements.begin();
    advance(itr, index);
    _elements.erase(itr);
    _version.update();
}

template <typename ValueType>
ValueType LinkedList<ValueType>::removeBack() {
    return pop_back();
}

template <typename ValueType>
ValueType LinkedList<ValueType>::removeFront() {
    return pop_front();
}

template <typename ValueType>
void LinkedList<ValueType>::removeValue(const ValueType& value) {
    auto itr = std::find(_elements.begin(), _elements.end(), value);
    if (itr != _elements.end()) {
        _elements.erase(itr);
        _version.update();
    }
}

template <typename ValueType>
void LinkedList<ValueType>::reverse() {
    _elements.reverse();
    _version.update();
}

template <typename ValueType>
void LinkedList<ValueType>::set(int index, const ValueType & value) {
    checkIndex(index, 0, size()-1, "set");
    (*this)[index] = value;
}

template <typename ValueType>
void LinkedList<ValueType>::shuffle() {
    // actually shuffle a vector to avoid O(N^2) runtime
    // at the cost of O(N) extra memory usage
    Vector<ValueType> vec;
    for (ValueType element : *this) {
        vec.add(element);
    }
    for (int i = 0, length = vec.size(); i < length; i++) {
        int j = randomInteger(i, length - 1);
        if (i != j) {
            std::swap(vec[i], vec[j]);
        }
    }

    clear();
    for (const ValueType& element : vec) {
        add(element);
    }
}

template <typename ValueType>
int LinkedList<ValueType>::size() const {
    return _elements.size();
}


template <typename ValueType>
void LinkedList<ValueType>::sort() {
    // actually sort a vector to avoid O(N^2) runtime
    // at the cost of O(N) extra memory usage
    Vector<ValueType> vec;
    for (ValueType element : *this) {
        vec.add(element);
    }
    std::sort(vec.begin(), vec.end());

    clear();
    for (const ValueType& element : vec) {
        add(element);
    }
}

template <typename ValueType>
LinkedList<ValueType> LinkedList<ValueType>::subList(int start, int length) const {
    checkIndex(start, 0, size(), "subList");
    checkIndex(start + length, 0, size(), "subList");
    if (length < 0) {
        error("LinkedList::subList: length cannot be negative");
    }
    LinkedList<ValueType> result;
    auto itr = begin();
    for (int i = 0; i < start; i++) {
        ++itr;
    }
    for (int i = 0; i < length; i++) {
        result.add(*itr);
        ++itr;
    }
    return result;
}

template <typename ValueType>
std::string LinkedList<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

/*
 * Implementation notes: LinkedList selection
 * ------------------------------------------
 * The following code implements traditional array selection using
 * square brackets for the index.
 */
template <typename ValueType>
ValueType& LinkedList<ValueType>::operator [](int index) {
    checkIndex(index, 0, size()-1, "operator []");
    auto itr = begin();
    advance(itr, index);
    return *itr;
}
template <typename ValueType>
const ValueType& LinkedList<ValueType>::operator [](int index) const {
    checkIndex(index, 0, size()-1, "operator []");
    auto itr = begin();
    advance(itr, index);
    return *itr;
}

template <typename ValueType>
LinkedList<ValueType>
LinkedList<ValueType>::operator +(const LinkedList& list2) const {
    LinkedList<ValueType> list = *this;
    return list.addAll(list2);
}

template <typename ValueType>
LinkedList<ValueType> LinkedList<ValueType>::operator +(std::initializer_list<ValueType> list) const {
    LinkedList<ValueType> result = *this;
    return result.addAll(list);
}

template <typename ValueType>
LinkedList<ValueType>&
LinkedList<ValueType>::operator +=(const LinkedList& list2) {
    return addAll(list2);
}

template <typename ValueType>
LinkedList<ValueType>& LinkedList<ValueType>::operator +=(std::initializer_list<ValueType> list) {
    return addAll(list);
}

template <typename ValueType>
LinkedList<ValueType>&
LinkedList<ValueType>::operator +=(const ValueType& value) {
    add(value);
    return *this;
}

/*
 * Implementation notes: relational operators
 * These operators just forward to the underlying STL list.
 */
template <typename ValueType>
bool LinkedList<ValueType>::operator ==(const LinkedList& list2) const {
    return _elements == list2._elements;
}

template <typename ValueType>
bool LinkedList<ValueType>::operator !=(const LinkedList& list2) const {
    return _elements != list2._elements;
}

template <typename ValueType>
bool LinkedList<ValueType>::operator <(const LinkedList& list2) const {
    return _elements < list2._elements;
}

template <typename ValueType>
bool LinkedList<ValueType>::operator <=(const LinkedList& list2) const {
    return _elements <= list2._elements;
}

template <typename ValueType>
bool LinkedList<ValueType>::operator >(const LinkedList& list2) const {
    return _elements > list2._elements;
}

template <typename ValueType>
bool LinkedList<ValueType>::operator >=(const LinkedList& list2) const {
    return this->_elements >= list2._elements;
}

template <typename ValueType>
void LinkedList<ValueType>::checkIndex(int index, int min, int max, const char* prefix) const {
    if (index < min || index > max) {
        std::ostringstream out;
        out << "LinkedList::" << prefix << ": index of " << index
            << " is outside of valid range [";
        if (min < max) {
            out << min << ".." << max;
        } else if (min == max) {
            out << min;
        } // else min > max, no range, empty LinkedList
        out << "]";
        error(out.str());
    }
}

/*
 * Implementation notes: The , operator
 * ------------------------------------
 * The comma operator works adding the right operand to the LinkedList and
 * then returning the LinkedList by reference so that it is set for the next
 * value in the chain.
 */
template <typename ValueType>
LinkedList<ValueType>&
LinkedList<ValueType>::operator ,(const ValueType& value) {
    add(value);
    return *this;
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const LinkedList<ValueType>& list) {
    return stanfordcpplib::collections::writeCollection(os, list);
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, LinkedList<ValueType>& list) {
    ValueType element;
    return stanfordcpplib::collections::readCollection(is, list, element, /* descriptor */ "LinkedList::operator >>");
}

/*
 * Template hash function for linked lists.
 * Requires the element type in the LinkedList to have a hashCode function.
 */
template <typename T>
int hashCode(const LinkedList<T>& list) {
    return stanfordcpplib::collections::hashCodeCollection(list);
}

/*
 * Function: randomElement
 * Usage: element = randomElement(list);
 * -------------------------------------
 * Returns a randomly chosen element of the given list.
 * Throws an error if the list is empty.
 */
template <typename T>
const T& randomElement(const LinkedList<T>& list) {
    return stanfordcpplib::collections::randomElementIndexed(list);
}

/*
 * Randomly rearranges the elements of the given list.
 * Because it is slow to arbitrarily access/modify indexes in a linked list,
 * this function uses an auxiliary Vector to assist in its implementation,
 * although doing so increases the memory consumption of the algorithm.
 */
template <typename T>
void shuffle(LinkedList<T>& list) {
    list.shuffle();
}

#endif // _linkedlist_h

/////////////////////// END code extracted from StanfordCPPLib/collections/linkedlist.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/priorityqueue.h ///////////////////////
/*
 * File: priorityqueue.h
 * ---------------------
 * This file exports the <code>PriorityQueue</code> class, a
 * collection in which values are processed in priority order.
 * 
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2016/11/07
 * - small const-correctness bug fix in front() / back() (courtesy Truman Cranor)
 * @version 2016/10/14
 * - modified floating-point equality tests to use floatingPointEqual function
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - renamed from pqueue.h to priorityqueue.h (old name left as an alias)
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as
 *   {{1.0, "a"}, {2.0, "b"}, {3.0, "c"}}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2015/06/22
 * - added optional compiler flag SPL_PQUEUE_PRINT_IN_HEAP_ORDER to indicate
 *   that PQ should be printed in heap-internal order rather than sorted order
 * - added optional compiler flag SPL_PQUEUE_ALLOW_HEAP_ACCESS and corresponding
 *   semi-private methods to access value/priority at a given index
 *   (wanted internally for some testing and for practice exam problems;
 *    not meant to be called explicitly by students or most clients)
 * @version 2014/12/04
 * - moved comparison operators <, >=, etc. behind a (default-disabled)
 *   compiler flag because implementation is inefficient
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added add() method as synonym for enqueue()
 * - added remove() method as synonym for dequeue()
 * - added template hashCode function
 * @version 2014/10/20
 * - added equals method, ==, != operators
 * @version 2014/10/10
 * - removed usage of __foreach macro
 * 2014/02/01
 * - added changePriority member to raise a given value's priority
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _priorityqueue_h
#define _priorityqueue_h

#include <cmath>
#include <initializer_list>
#include <utility>
#include <queue>
#include <algorithm>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: PriorityQueue<ValueType>
 * -------------------------------
 * This class models a structure called a <b><i>priority&nbsp;queue</i></b>
 * in which values are processed in order of priority.  As in conventional
 * English usage, lower priority numbers correspond to higher effective
 * priorities, so that a priority 1 item takes precedence over a
 * priority 2 item.
 */

template <typename ValueType>
class PriorityQueue {
public:
    /*
     * Constructor: PriorityQueue
     * Usage: PriorityQueue<ValueType> pq;
     * -----------------------------------
     * Initializes a new priority queue, which is initially empty.
     */
    PriorityQueue() = default;

    /*
     * Constructor: PriorityQueue
     * Usage: PriorityQueue<ValueType> pq {{1.0, "a"}, {2.0, "b"}, {3.0, "c"}};
     * -------------------------------------------------------------------------
     * Initializes a new priority that stores the given pairs.
     * Note that the pairs are stored in priority order and not
     * necessarily the order in which they are written in the initializer list.
     */
    PriorityQueue(std::initializer_list<std::pair<double, ValueType>> list);

    /*
     * Destructor: ~PriorityQueue
     * --------------------------
     * Frees any heap storage associated with this priority queue.
     */
    virtual ~PriorityQueue() = default;
    
    /*
     * Method: add
     * Usage: pq.add(value, priority);
     * -------------------------------
     * A synonym for the enqueue method.
     */
    void add(const ValueType& value, double priority);
    
    /*
     * Method: back
     * Usage: ValueType last = pq.back();
     * ----------------------------------
     * Returns the last value in the queue by reference.
     */
    ValueType& back();
    
    /*
     * Method: changePriority
     * Usage: pq.changePriority(value, newPriority);
     * ---------------------------------------------
     * Adjusts <code>value</code> in the queue to now have the specified new priority,
     * which must be at least as urgent (lower number) than that value's previous
     * priority in the queue.
     * Throws an error if the element value is not present in the queue, or if the
     * new priority passed is not at least as urgent as its current priority.
     */
    void changePriority(ValueType value, double newPriority);

    /*
     * Method: clear
     * Usage: pq.clear();
     * ------------------
     * Removes all elements from the priority queue.
     */
    void clear();
    
    /*
     * Method: dequeue
     * Usage: ValueType first = pq.dequeue();
     * --------------------------------------
     * Removes and returns the highest priority value.  If multiple
     * entries in the queue have the same priority, those values are
     * dequeued in the same order in which they were enqueued.
     */
    ValueType dequeue();

    /*
     * Method: enqueue
     * Usage: pq.enqueue(value, priority);
     * -----------------------------------
     * Adds <code>value</code> to the queue with the specified priority.
     * Lower priority numbers correspond to higher priorities, which
     * means that all priority 1 elements are dequeued before any
     * priority 2 elements.
     */
    void enqueue(const ValueType& value, double priority);
    
    /*
     * Method: equals
     * Usage: if (pq.equals(pq2)) ...
     * ------------------------------
     * Compares two priority queues for equality.
     * Returns <code>true</code> if this queue contains exactly the same
     * values and priorities as the given other queue.
     * Identical in behavior to the == operator.
     */
    bool equals(const PriorityQueue<ValueType>& pq2) const;
    
    /*
     * Method: front
     * Usage: ValueType first = pq.front();
     * ------------------------------------
     * Returns the first value in the queue by reference.
     */
    ValueType& front();

    /*
     * Method: isEmpty
     * Usage: if (pq.isEmpty()) ...
     * ----------------------------
     * Returns <code>true</code> if the priority queue contains no elements.
     */
    bool isEmpty() const;
    
    /*
     * Method: peek
     * Usage: ValueType first = pq.peek();
     * -----------------------------------
     * Returns the value of highest priority in the queue, without
     * removing it.
     */
    ValueType peek() const;

    /*
     * Method: peekPriority
     * Usage: double priority = pq.peekPriority();
     * -------------------------------------------
     * Returns the priority of the first element in the queue, without
     * removing it.
     */
    double peekPriority() const;

    /*
     * Method: remove
     * Usage: ValueType first = pq.remove();
     * --------------------------------------
     * A synonym for the dequeue method.
     */
    ValueType remove();

    /*
     * Method: size
     * Usage: int n = pq.size();
     * -------------------------
     * Returns the number of values in the priority queue.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = pq.toString();
     * ----------------------------------
     * Converts the queue to a printable string representation.
     */
    std::string toString() const;
    
    /*
     * Operator: <<
     * Prints the priority queue to the given output stream.
     */
    template <typename T>
    friend std::ostream& operator <<(std::ostream& os, const PriorityQueue<T>& pq);
    
    /*
     * Operators: ==, !=
     * Usage: if (pq1 == pq2) ...
     * --------------------------
     * Relational operators to compare two queues to see if they have the same elements.
     * The ==, != operators require that the ValueType has a == operator
     * so that the elements can be tested for equality.
     */
    bool operator ==(const PriorityQueue& pq2) const;
    bool operator !=(const PriorityQueue& pq2) const;

#ifdef SPL_PQUEUE_COMPARISON_OPERATORS_ENABLED
    /*
     * Operators: <, <=, >, >=
     * Usage: if (pq1 < pq2) ...
     * -------------------------
     * Relational operators to compare two queues.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const PriorityQueue& pq2) const;
    bool operator <=(const PriorityQueue& pq2) const;
    bool operator >(const PriorityQueue& pq2) const;
    bool operator >=(const PriorityQueue& pq2) const;
#endif // SPL_PQUEUE_COMPARISON_OPERATORS_ENABLED

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes: PriorityQueue data structure
     * --------------------------------------------------
     * The PriorityQueue class is implemented using a data structure called
     * a heap.
     */
private:
    /* Type used for each heap entry */
    struct HeapEntry {
        ValueType value;
        double priority;
        long sequence;

        bool operator < (const HeapEntry& rhs) const;
    };

    /* Instance variables */
    Vector<HeapEntry> _heap;
    long _enqueueCount = 0;

#ifdef SPL_PQUEUE_COMPARISON_OPERATORS_ENABLED
    int pqCompare(const PriorityQueue& other) const;
#endif // SPL_PQUEUE_COMPARISON_OPERATORS_ENABLED

public:
    /* private implentation section */

    template <typename Collection>
    friend int stanfordcpplib::collections::compare(const Collection& pq1, const Collection& pq2);

#ifdef SPL_PQUEUE_ALLOW_HEAP_ACCESS
    const ValueType& __getValueFromHeap(int index) const;
    double __getPriorityFromHeap(int index) const;
#endif // SPL_PQUEUE_ALLOW_HEAP_ACCESS
};

template <typename ValueType>
PriorityQueue<ValueType>::PriorityQueue(
        std::initializer_list<std::pair<double, ValueType>> list) {
    for (std::pair<double, ValueType> pair : list) {
        enqueue(pair.second, pair.first);
    }
}

template <typename ValueType>
void PriorityQueue<ValueType>::add(const ValueType& value, double priority) {
    enqueue(value, priority);
}

template <typename ValueType>
ValueType & PriorityQueue<ValueType>::back() {
    if (isEmpty()) {
        error("PriorityQueue::back: Attempting to read back of an empty queue");
    }
    return _heap.back().value;
}

/*
 * changePriority function added by Marty Stepp.
 * Parts of this implementation are adapted from TrailblazerPQueue.h,
 * which was written by Keith Schwarz.
 */
template <typename ValueType>
void PriorityQueue<ValueType>::changePriority(ValueType value, double newPriority) {
    if (std::isnan(newPriority)) {
        error("PriorityQueue::changePriority: Attempted to use NaN as a priority.");
    }
    if (floatingPointEqual(newPriority, -0.0)) {
        newPriority = 0.0;
    }

    /* Find the element to change. */
    auto itr = std::find_if(_heap.begin(), _heap.end(), [&](const HeapEntry& entry) {
        return entry.value == value;
    });
    if (itr == _heap.end()) {
        error("PriorityQueue::changePriority: Element not found in priority queue.");
    }

    if (itr->priority < newPriority) {
        error("PriorityQueue::changePriority: new priority cannot be less urgent than current priority.");
    }
    itr->priority = newPriority;
    std::push_heap(_heap.begin(), itr + 1);
}

template <typename ValueType>
void PriorityQueue<ValueType>::clear() {
    _heap.clear();
    _enqueueCount = 0;   // BUGFIX 2014/10/10: was previously using garbage unassigned value
}

/*
 * Implementation notes: dequeue, peek, peekPriority
 * -------------------------------------------------
 * These methods must check for an empty queue and report an error
 * if there is no first element.
 */
template <typename ValueType>
ValueType PriorityQueue<ValueType>::dequeue() {
    if (isEmpty()) {
        error("PriorityQueue::dequeue: Attempting to dequeue an empty queue");
    }

    ValueType result = _heap[0].value;
    std::pop_heap(_heap.begin(), _heap.end());
    _heap.pop_back();
    return result;
}

template <typename ValueType>
void PriorityQueue<ValueType>::enqueue(const ValueType& value, double priority) {
    if (std::isnan(priority)) {
        error("PriorityQueue::enqueue: Attempted to use NaN as a priority.");
    }
    if (floatingPointEqual(priority, -0.0)) {
        priority = 0.0;
    }

    _heap.add({ value, priority, _enqueueCount++ });
    std::push_heap(_heap.begin(), _heap.end());
}

template <typename ValueType>
bool PriorityQueue<ValueType>::equals(const PriorityQueue<ValueType>& pq2) const {
    // optimization: if literally same pq, stop
    if (this == &pq2) {
        return true;
    }
    if (size() != pq2.size()) {
        return false;
    }
    PriorityQueue<ValueType> backup1 = *this;
    PriorityQueue<ValueType> backup2 = pq2;
    while (!backup1.isEmpty() && !backup2.isEmpty()) {
        if (!floatingPointEqual(backup1.peekPriority(), backup2.peekPriority())) {
            return false;
        }
        if (backup1.dequeue() != backup2.dequeue()) {
            return false;
        }
    }
    return backup1.isEmpty() == backup2.isEmpty();
}

template <typename ValueType>
ValueType& PriorityQueue<ValueType>::front() {
    if (isEmpty()) {
        error("PriorityQueue::front: Attempting to read front of an empty queue");
    }
    return _heap[0].value;
}

template <typename ValueType>
bool PriorityQueue<ValueType>::isEmpty() const {
    return _heap.size() == 0;
}

template <typename ValueType>
ValueType PriorityQueue<ValueType>::peek() const {
    if (isEmpty()) {
        error("PriorityQueue::peek: Attempting to peek at an empty queue");
    }
    return _heap.front().value;
}

template <typename ValueType>
double PriorityQueue<ValueType>::peekPriority() const {
    if (isEmpty()) {
        error("PriorityQueue::peekPriority: Attempting to peek at an empty queue");
    }
    return _heap.get(0).priority;
}

template <typename ValueType>
ValueType PriorityQueue<ValueType>::remove() {
    return dequeue();
}

template <typename ValueType>
int PriorityQueue<ValueType>::size() const {
    return _heap.size();
}

template <typename ValueType>
std::string PriorityQueue<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

#ifdef SPL_PQUEUE_COMPARISON_OPERATORS_ENABLED
/*
 * Implementation note: Due to the complexity and unpredictable heap ordering of the elements,
 * this function sadly makes a deep copy of both PQs for comparing.
 * Therefore it is recommended not to use PQs in a context where <, <=, etc. are being
 * called on them frequently.
 */
template <typename ValueType>
int PriorityQueue<ValueType>::pqCompare(const PriorityQueue& pq2) const {
    if (this == &pq2) {
        return 0;
    }
    PriorityQueue<ValueType> backup1 = *this;
    PriorityQueue<ValueType> backup2 = pq2;
    while (!backup1.isEmpty() && !backup2.isEmpty()) {
        if (backup1.peek() < backup2.peek()) {
            return -1;
        } else if (backup2.peek() < backup1.peek()) {
            return 1;
        }
        
        double pri1 = backup1.peekPriority();
        double pri2 = backup2.peekPriority();
        if (pri1 < pri2) {
            return -1;
        } else if (pri2 < pri1) {
            return 1;
        }
        
        backup1.dequeue();
        backup2.dequeue();
    }
    if (backup1.size() < backup2.size()) {
        return -1;
    } else if (backup2.size() < backup1.size()) {
        return 1;
    } else {
        return 0;
    }
}
#endif // SPL_PQUEUE_COMPARISON_OPERATORS_ENABLED

/*
 * Comparison function for heap entries. The comparison is lexicographic, first by
 * priority, then by sequence number.
 *
 * Because std::push_heap and std::pop_heap try creating a max-heap whereas we want
 * a min-heap, the priority comparisons are reversed.
 */
template <typename ValueType>
bool PriorityQueue<ValueType>::HeapEntry::operator < (const HeapEntry& rhs) const {
    if (priority > rhs.priority) return true;
    if (rhs.priority > priority) return false;

    return sequence < rhs.sequence;
}

template <typename ValueType>
bool PriorityQueue<ValueType>::operator ==(const PriorityQueue& pq2) const {
    return equals(pq2);
}

template <typename ValueType>
bool PriorityQueue<ValueType>::operator !=(const PriorityQueue& pq2) const {
    return !equals(pq2);
}

#ifdef SPL_PQUEUE_COMPARISON_OPERATORS_ENABLED
template <typename ValueType>
bool PriorityQueue<ValueType>::operator <(const PriorityQueue& pq2) const {
    return pqCompare(pq2) < 0;
}

template <typename ValueType>
bool PriorityQueue<ValueType>::operator <=(const PriorityQueue& pq2) const {
    return pqCompare(pq2) <= 0;
}

template <typename ValueType>
bool PriorityQueue<ValueType>::operator >(const PriorityQueue& pq2) const {
    return pqCompare(pq2) > 0;
}

template <typename ValueType>
bool PriorityQueue<ValueType>::operator >=(const PriorityQueue& pq2) const {
    return pqCompare(pq2) >= 0;
}
#endif // SPL_PQUEUE_COMPARISON_OPERATORS_ENABLED

/*
 * Template hash function for priority queues.
 * Requires the element type in the priority queue to have a hashCode function.
 */
template <typename T>
int hashCode(const PriorityQueue<T>& pq) {
    // (slow, memory-inefficient) implementation: copy pq, dequeue all, and hash together
    PriorityQueue<T> backup = pq;
    int code = hashSeed();
    while (!backup.isEmpty()) {
        code = hashMultiplier() * code + hashCode(backup.peek());
        code = hashMultiplier() * code + hashCode(backup.peekPriority());
        backup.dequeue();
    }
    return int(code & hashMask());
}

#ifdef SPL_PQUEUE_ALLOW_HEAP_ACCESS
template <typename ValueType>
const ValueType& PriorityQueue<ValueType>::__getValueFromHeap(int index) const {
    return _heap[index].value;
}

template <typename ValueType>
double PriorityQueue<ValueType>::__getPriorityFromHeap(int index) const {
    return _heap[index].priority;
}
#endif // SPL_PQUEUE_ALLOW_HEAP_ACCESS

template <typename ValueType>
std::ostream& operator <<(std::ostream& os,
                          const PriorityQueue<ValueType>& pq) {
    os << "{";

#ifdef SPL_PQUEUE_PRINT_IN_HEAP_ORDER
    // faster implementation: print in heap order
    // (only downside: doesn't print in 'sorted' priority order,
    //  which might confuse student client)
    for (int i = 0, len = pq.size(); i < len; i++) {
        if (i > 0) {
            os << ", ";
        }
        os << pq._heap[i].priority << ":";
        writeGenericValue(os, pq._heap[i].value, /* forceQuotes */ true);
    }
#else // SPL_PQUEUE_PRINT_IN_HEAP_ORDER
    // (default) slow, memory-inefficient implementation: copy pq and print
    PriorityQueue<ValueType> copy = pq;
    for (int i = 0, len = pq.size(); i < len; i++) {
        if (i > 0) {
            os << ", ";
        }
        os << copy.peekPriority() << ":";
        writeGenericValue(os, copy.dequeue(), /* forceQuotes */ true);
    }
#endif // SPL_PQUEUE_PRINT_IN_HEAP_ORDER
    return os << "}";
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, PriorityQueue<ValueType>& pq) {
    char ch = '\0';
    is >> ch;
    if (ch != '{') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("PriorityQueue::operator >>: Missing {");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }
    pq.clear();
    is >> ch;
    if (ch != '}') {
        is.unget();
        while (true) {
            double priority = 0.0;
            is >> priority >> ch;
            if (ch != ':') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error("PriorityQueue::operator >>: Missing colon after priority");
#endif
                is.setstate(std::ios_base::failbit);
                return is;
            }
            ValueType value;
            if (!readGenericValue(is, value)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error("PriorityQueue::operator >>: parse error");
#endif
                return is;
            }
            pq.enqueue(value, priority);
            is >> ch;
            if (ch == '}') {
                break;
            }
            if (ch != ',') {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
                error(std::string("PriorityQueue::operator >>: Unexpected character ") + ch);
#endif
                is.setstate(std::ios_base::failbit);
                return is;
            }
        }
    }
    return is;
}

#endif // _priorityqueue_h

/////////////////////// END code extracted from StanfordCPPLib/collections/priorityqueue.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/pqueue.h ///////////////////////
/*
 * This is an alias for priorityqueue.h left in for backward compatibility.
 * See priorityqueue.h for the implementation of the PriorityQueue class.
 *
 * @author Marty Stepp
 * @version 2016/09/22
 * - initial version
 */

#ifndef _pqueue_h
#define _pqueue_h

#endif // _pqueue_h

/////////////////////// END code extracted from StanfordCPPLib/collections/pqueue.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/sparsegrid.h ///////////////////////
/*
 * File: sparsegrid.h
 * ------------------
 * This file exports the <code>SparseGrid</code> class, which offers a
 * convenient abstraction for representing a two-dimensional array.
 * Unlike Grid, SparseGrid is optimized for grids in which most of the cells
 * are empty.  It uses far less memory in such cases than a Grid does.
 * If the grid is expected to be mostly full of meaningful data,
 * Grid is recommended for use over SparseGrid.
 * 
 * @author Marty Stepp
 * @version 2018/03/12
 * - added overloads that accept GridLocation: get, inBounds, isSet, locations,
 *   set, unset, operator []
 * @version 2018/03/10
 * - added methods front, back, clear
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2016/10/22
 * - bug fix for size method
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * - added size() method
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as
 *   {{1, 2, 3}, {4, 5, 6}}
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/07/05
 * - using global hashing functions rather than global variables
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added template hashCode function
 * @version 2014/10/20
 * - added width(), height() methods to be consistent with Grid
 * @version 2014/10/10
 * - removed usage of __foreach macro
 * - made ==, != operators const as they should be
 * - added resize(true) function with ability to retain old contents
 * @since 2014/07/09
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _sparsegrid_h
#define _sparsegrid_h

#include <initializer_list>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: SparseGrid<ValueType>
 * ----------------------------
 * This class stores an indexed, two-dimensional array.
 */

template <typename ValueType>
class SparseGrid {
public:
    /* Forward reference */
    class SparseGridRow;
    class SparseGridRowConst;

    /*
     * Constructor: SparseGrid
     * Usage: SparseGrid<ValueType> grid;
     *        SparseGrid<ValueType> grid(nRows, nCols);
     * ------------------------------------------------
     * Initializes a new grid.  The second form of the constructor is
     * more common and creates a grid with the specified number of rows
     * and columns.  Each element of the grid is initialized to the
     * default value for the type.  The default constructor creates an
     * empty grid for which the client must call <code>resize</code> to
     * set the dimensions.
     * The three-argument constructor also accepts an initial value and
     * fills every cell of the grid with that value.
     */
    SparseGrid();
    SparseGrid(int _rowCount, int _columnCount);
    SparseGrid(int _rowCount, int _columnCount, const ValueType& value);

    /*
     * This constructor uses an initializer list to set up the grid.
     * Usage: SparseGrid<int> grid {{1, 2, 3}, {4, 5, 6}};
     */
    SparseGrid(std::initializer_list<std::initializer_list<ValueType>> list);

    /*
     * Destructor: ~SparseGrid
     * -----------------------
     * Frees any heap storage associated with this grid.
     */
    virtual ~SparseGrid();

    /*
     * Method: back
     * Usage: ValueType value = grid.back();
     * -------------------------------------
     * Returns the last value in the grid in the order established by the
     * <code>foreach</code> macro.  This is the highest row/col value that has
     * been explicitly set.
     * If the grid is empty, generates an error.
     */
    ValueType back() const;

    /*
     * Method: clear
     * Usage: grid.clear();
     * --------------------
     * Sets every value in the grid to its element type's default value.
     */
    void clear();

    /*
     * Method: equals
     * Usage: if (grid.equals(grid2)) ...
     * ----------------------------------
     * Returns <code>true</code> if this grid contains exactly the same
     * values as the given other grid.
     * Identical in behavior to the == operator.
     */
    bool equals(const SparseGrid<ValueType>& grid) const;

    /*
     * Method: fill
     * Usage: grid.fill(value);
     * ------------------------
     * Stores the given value in every cell of this grid.
     */
    void fill(const ValueType& value);

    /*
     * Method: front
     * Usage: ValueType value = grid.front();
     * --------------------------------------
     * Returns the first value in the grid in the order established by the
     * <code>foreach</code> macro.  Typically this is equivalent to grid[0][0].
     * If the grid is empty, generates an error.
     */
    ValueType front() const;

    /*
     * Method: get
     * Usage: ValueType value = grid.get(row, col);
     * --------------------------------------------
     * Returns the element at the specified <code>row</code>/<code>col</code>
     * position in this grid.
     *
     * If no data was set at the given row/column position, this method returns
     * a default value for the grid's value type.
     *
     * This method signals an error if the <code>row</code> and <code>col</code>
     * arguments are outside the grid boundaries.
     */
    ValueType get(int row, int col);
    const ValueType& get(int row, int col) const;
    ValueType get(const GridLocation& loc);
    const ValueType& get(const GridLocation& loc) const;

    /*
     * Method: height
     * Usage: int nRows = grid.height();
     * ---------------------------------
     * Returns the grid's height, that is, the number of rows in the grid.
     */
    int height() const;
    
    /*
     * Method: inBounds
     * Usage: if (grid.inBounds(row, col)) ...
     * ---------------------------------------
     * Returns <code>true</code> if the specified row and column position
     * is inside the bounds of the grid.
     */
    bool inBounds(int row, int col) const;
    bool inBounds(const GridLocation& loc) const;

    /*
     * Method: isEmpty
     * Usage: if (grid.isEmpty()) ...
     * ---------------------------------------
     * Returns <code>true</code> if the specified grid has 0 rows and/or columns,
     * or if none of the individual cell values has been set yet.
     */
    bool isEmpty() const;

    /*
     * Method: isSet
     * Usage: if (grid.isSet(row, col)) ...
     * ---------------------------------------
     * Returns <code>true</code> if the specified row and column position
     * stores meaningful data; in other words, if it has had a value set
     * there by a previous call to fill, set, [], etc.
     */
    bool isSet(int row, int col) const;
    bool isSet(const GridLocation& loc) const;

    /*
     * Method: locations
     * Usage: for (GridLocation loc : grid.locations()) ...
     * ----------------------------------------------------
     * Returns a range of (row,col) locations found in this grid.
     * This allows a nice abstraction for looping over the 2D grid range
     * of indexes using a single for loop.
     * By default the locations are arranged in row-major order,
     * but if you pass the rowMajor parameter of false, the locations will be
     * returned in column-major order instead.
     */
    GridLocationRange locations(bool rowMajor = true) const;

    /*
     * Method: mapAll
     * Usage: grid.mapAll(fn);
     * -----------------------
     * Calls the specified function on each element of the grid.  The
     * elements are processed in <b><i>row-major order,</i></b> in which
     * all the elements of row 0 are processed, followed by the elements
     * in row 1, and so on.
     */
    void mapAll(void (*fn)(ValueType value)) const;
    void mapAll(void (*fn)(const ValueType& value)) const;

    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    /*
     * Method: numCols
     * Usage: int nCols = grid.numCols();
     * ----------------------------------
     * Returns the number of columns in the grid.
     */
    int numCols() const;

    /*
     * Method: numRows
     * Usage: int nRows = grid.numRows();
     * ----------------------------------
     * Returns the number of rows in the grid.
     */
    int numRows() const;

    /*
     * Method: resize
     * Usage: grid.resize(nRows, nCols);
     * ---------------------------------
     * Reinitializes the grid to have the specified number of rows
     * and columns.  If the 'retain' parameter is true,
     * the previous grid contents are retained as much as possible.
     * If 'retain' is not passed or is false, any previous grid contents
     * are discarded.
     */
    void resize(int _rowCount, int _columnCount, bool retain = false);

    /*
     * Method: set
     * Usage: grid.set(row, col, value);
     * ---------------------------------
     * Replaces the element at the specified <code>row</code>/<code>col</code>
     * location in this grid with a new value.  This method signals an error
     * if the <code>row</code> and <code>col</code> arguments are outside
     * the grid boundaries.
     */
    void set(int row, int col, const ValueType& value);
    void set(const GridLocation& loc, const ValueType& value);

    /*
     * Method: size
     * Usage: int size = grid.size();
     * ------------------------------
     * Returns the total number of elements that have been set in the grid.
     * Note that this may not be equal to the number of rows times the number of
     * columns, because not every index may have been set.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = grid.toString();
     * ------------------------------------
     * Converts the grid to a printable string representation.
     * Unlike the representation of a Grid, this one displays only the
     * cells in which data has been explicitly set, such as:
     * "{0:{2:88}, 1:{3:42}}, 3 x 4"
     */
    std::string toString() const;

    /*
     * Method: toString2D
     * Usage: string str = grid.toString2D();
     * --------------------------------------
     * Converts the grid to a printable string representation.
     * The string returned is a 2-dimensional representation such as:
     * "{{1, 2, 3},\n
     *   {4, 5, 6},\n
     *   {7, 8, 9}}"
     */
    std::string toString2D(
            std::string rowStart = "{",
            std::string rowEnd = "}",
            std::string colSeparator = ", ",
            std::string rowSeparator = ",\n ") const;

    /*
     * Method: unset
     * Usage: grid.unset(row, col, value);
     * -----------------------------------
     * Replaces the element at the specified <code>row</code>/<code>col</code>
     * location in this grid with an empty default value.
     * If the element at the specified row and column was not set, has no effect.
     * This method signals an error if the <code>row</code> and <code>col</code>
     * arguments are outside the grid boundaries.
     */
    void unset(int row, int col);
    void unset(const GridLocation& loc);

    /*
     * Method: width
     * Usage: int nCols = grid.width();
     * --------------------------------
     * Returns the grid's width, that is, the number of columns in the grid.
     */
    int width() const;

    /*
     * Operator: []
     * Usage:  grid[row][col]
     * ----------------------
     * Overloads <code>[]</code> to select elements from this grid.
     * This extension enables the use of traditional array notation to
     * get or set individual elements.
     *
     * If no data was set at the given row/column position, this method returns
     * a default value for the grid's value type.
     *
     * This method signals an error if the <code>row</code> and <code>col</code>
     * arguments are outside the grid boundaries.
     */
    SparseGridRow operator [](int row);
    const SparseGridRowConst operator [](int row) const;
    ValueType& operator [](const GridLocation& loc);
    const ValueType& operator [](const GridLocation& loc) const;

    /*
     * Additional SparseGrid operations
     * --------------------------
     * In addition to the methods listed in this interface, the SparseGrid
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * The iteration forms process the grid in row-major order.
     */

    /*
     * Operator: ==
     * Usage: if (grid1 == grid2) ...
     * ------------------------------
     * Compares two grids for equality.
     */
    bool operator ==(const SparseGrid& grid2) const;

    /*
     * Operator: !=
     * Usage: if (grid1 != grid2) ...
     * ------------------------------
     * Compares two grids for inequality.
     */
    bool operator !=(const SparseGrid& grid2) const;

    /*
     * Operators: <, >, <=, >=
     * Usage: if (grid1 < grid2) ...
     * -----------------------------
     * Relational operators to compare two grids.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const SparseGrid& grid2) const;
    bool operator <=(const SparseGrid& grid2) const;
    bool operator >(const SparseGrid& grid2) const;
    bool operator >=(const SparseGrid& grid2) const;

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes: SparseGrid data structure
     * -----------------------------------------------
     * The SparseGrid is internally managed as a dynamic array of elements.
     * The array itself is one-dimensional, the logical separation into
     * rows and columns is done by arithmetic computation.  The layout
     * is in row-major order, which is to say that the entire first row
     * is laid out contiguously, followed by the entire second row,
     * and so on.
     */

private:
    /* Instance variables */
    Map<int, Map<int, ValueType>> _elements;   // 2D map of the elements
    int _rowCount;                             // the number of rows in the grid
    int _columnCount;                          // the number of columns in the grid
    unsigned int _version = 0;                 // structure version for detecting invalid iterators

    /* Private method prototypes */

    /*
     * Throws an ErrorException if the given row/col are not within the range of
     * (0,0) through (rowMax-1,colMax-1) inclusive.
     * This is a consolidated error handler for all various SparseGrid members that
     * accept index parameters.
     * The prefix parameter represents a text string to place at the start of
     * the error message, generally to help indicate which member threw the error.
     */
    void checkIndexes(int row, int col,
                      int rowMax, int colMax,
                      std::string prefix) const;
    int gridCompare(const SparseGrid& grid2) const;

    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return grids by value
     * and assign from one grid to another.  The entire contents of
     * the grid, including all elements, are copied.  Each grid
     * element is copied from the original grid to the copy using
     * assignment (operator=).  Making copies is generally avoided
     * because of the expense and thus, grids are typically passed
     * by reference, however, when a copy is needed, these operations
     * are supported.
     */
    void deepCopy(const SparseGrid& grid) {
        _elements = grid._elements;
        _rowCount = grid._rowCount;
        _columnCount = grid._columnCount;
    }

    template <typename T>
    friend const T& randomElement(const SparseGrid<T>& grid);

    template <typename T>
    friend std::ostream& operator <<(std::ostream& os, const SparseGrid<T>& grid);

    template <typename T>
    friend std::istream& operator >>(std::istream& is, SparseGrid<T>& grid);

public:
    SparseGrid& operator =(const SparseGrid& src) {
        if (this != &src) {
            deepCopy(src);
        }
        return *this;
    }

    SparseGrid(const SparseGrid& src) {
        deepCopy(src);
    }

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag, ValueType> {
    public:
        iterator(const SparseGrid* gp, int index)
                : gp(gp),
                  index(index),
                  itr_version(gp->version()) {
            // empty
        }

        iterator(const iterator& it)
                : gp(it.gp),
                  index(it.index),
                  itr_version(it.itr_version) {
            // empty
        }

        iterator& operator ++() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            index++;
            return *this;
        }

        iterator operator ++(int) {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return gp == rhs.gp && index == rhs.index;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        ValueType operator *() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            int row = index / gp->_columnCount;
            int col = index % gp->_columnCount;
            return gp->_elements[row][col];
        }

        ValueType* operator ->() {
            stanfordcpplib::collections::checkVersion(*gp, *this);
            int row = index / gp->_columnCount;
            int col = index % gp->_columnCount;
            return &gp->_elements[row][col];
        }

        unsigned int version() const {
            return itr_version;
        }

    private:
        const SparseGrid* gp;
        int index;
        unsigned int itr_version;
    };

    iterator begin() const {
        return iterator(this, 0);
    }

    iterator end() const {
        return iterator(this, _rowCount * _columnCount);
    }

    /*
     * Returns the internal version of this collection.
     * This is used to check for invalid iterators and issue error messages.
     */
    unsigned int version() const;

    /*
     * Private class: SparseGrid<ValType>::SparseGridRow
     * -------------------------------------
     * This section of the code defines a nested class within the SparseGrid template
     * that makes it possible to use traditional subscripting on SparseGrid values.
     */
    class SparseGridRow {
    public:
        SparseGridRow() {
            /* Empty */
        }

        ValueType& operator [](int col) {
            _gp->checkIndexes(_row, col, _gp->_rowCount-1, _gp->_columnCount-1, "operator [][]");
            return _gp->_elements[_row][col];
        }

        const ValueType& operator [](int col) const {
            _gp->checkIndexes(_row, col, _gp->_rowCount-1, _gp->_columnCount-1, "operator [][]");
            return _gp->_elements[_row][col];
        }

    private:
        SparseGridRow(SparseGrid* gridRef, int index) {
            _gp = gridRef;
            _row = index;
        }

        SparseGrid* _gp;
        int _row;
        friend class SparseGrid;
    };
    friend class SparseGridRow;

    class SparseGridRowConst {
    public:
        const ValueType operator [](int col) const {
            _gp->checkIndexes(_row, col, _gp->_rowCount-1, _gp->_columnCount-1, "operator [][]");
            return _gp->_elements[_row][col];
        }

    private:
        SparseGridRowConst(SparseGrid* const gridRef, int index) : _gp(gridRef), _row(index) {
            // empty
        }

        const SparseGrid* const _gp;
        const int _row;
        friend class SparseGrid;
    };
    friend class SparseGridRowConst;
};

template <typename ValueType>
SparseGrid<ValueType>::SparseGrid()
        : _rowCount(0),
          _columnCount(0) {
    // empty
}

template <typename ValueType>
SparseGrid<ValueType>::SparseGrid(int nRows, int nCols) {
    resize(nRows, nCols);
}

template <typename ValueType>
SparseGrid<ValueType>::SparseGrid(int nRows, int nCols, const ValueType& value) {
    resize(nRows, nCols);
    fill(value);
}

template <typename ValueType>
SparseGrid<ValueType>::SparseGrid(std::initializer_list<std::initializer_list<ValueType>> list)
        : _rowCount(0),
          _columnCount(0) {
    // create the grid at the proper size
    _rowCount = list.size();
    if (list.begin() != list.end()) {
        _columnCount = list.begin()->size();
    }
    resize(_rowCount, _columnCount);

    // copy the data from the initializer list into the Grid
    auto rowItr = list.begin();
    for (int row = 0; row < _rowCount; row++) {
        if ((int) rowItr->size() != _columnCount) {
            error("SparseGrid::constructor: initializer list is not rectangular (must have same # cols in each row)");
        }
        auto colItr = rowItr->begin();
        for (int col = 0; col < _columnCount; col++) {
            set(row, col, *colItr);
            colItr++;
        }
        rowItr++;
    }
}


template <typename ValueType>
SparseGrid<ValueType>::~SparseGrid() {
    // empty
}

template <typename ValueType>
ValueType SparseGrid<ValueType>::back() const {
    if (isEmpty()) {
        error("SparseGrid::back: grid is empty");
    }
    int lastRow = _elements.back();
    int lastCol = _elements[lastRow].back();
    return _elements[lastRow][lastCol];
}

template <typename ValueType>
void SparseGrid<ValueType>::clear() {
    _elements.clear();
}

template <typename ValueType>
bool SparseGrid<ValueType>::equals(const SparseGrid<ValueType>& grid2) const {
    // optimization: if literally same grid, stop
    if (this == &grid2) {
        return true;
    }
    if (_rowCount != grid2._rowCount || _columnCount != grid2._columnCount) {
        return false;
    }
    for (int row = 0; row < _rowCount; row++) {
        for (int col = 0; col < _columnCount; col++) {
            if (isSet(row, col)) {
                // I have data there; he must, too, and it must be the same data
                if (!grid2.isSet(row, col) || get(row, col) != grid2.get(row, col)) {
                    return false;
                }
            } else {
                // I don't have data there; he must also not have it there
                if (grid2.isSet(row, col)) {
                    return false;
                }
            }
        }
    }
    return true;
}

template <typename ValueType>
void SparseGrid<ValueType>::fill(const ValueType& value) {
    for (int row = 0; row < _rowCount; row++) {
        for (int col = 0; col < _columnCount; col++) {
            set(row, col, value);
        }
    }
}

template <typename ValueType>
ValueType SparseGrid<ValueType>::front() const {
    if (isEmpty()) {
        error("SparseGrid::front: grid is empty");
    }
    return *begin();
}

template <typename ValueType>
ValueType SparseGrid<ValueType>::get(int row, int col) {
    checkIndexes(row, col, _rowCount-1, _columnCount-1, "get");
    return _elements[row][col];
}

template <typename ValueType>
const ValueType& SparseGrid<ValueType>::get(int row, int col) const {
    checkIndexes(row, col, _rowCount-1, _columnCount-1, "get");
    return _elements[row][col];
}

template <typename ValueType>
ValueType SparseGrid<ValueType>::get(const GridLocation& loc) {
    return get(loc.row, loc.col);
}

template <typename ValueType>
const ValueType& SparseGrid<ValueType>::get(const GridLocation& loc) const {
    return get(loc.row, loc.col);
}

template <typename ValueType>
int SparseGrid<ValueType>::height() const {
    return _rowCount;
}

template <typename ValueType>
bool SparseGrid<ValueType>::inBounds(int row, int col) const {
    return row >= 0 && col >= 0 && row < _rowCount && col < _columnCount;
}

template <typename ValueType>
bool SparseGrid<ValueType>::inBounds(const GridLocation& loc) const {
    return inBounds(loc.row, loc.col);
}

template <typename ValueType>
bool SparseGrid<ValueType>::isEmpty() const {
    return _elements.isEmpty();
}

template <typename ValueType>
bool SparseGrid<ValueType>::isSet(int row, int col) const {
    return inBounds(row, col) && _elements.containsKey(row) &&
            _elements[row].containsKey(col);
}

template <typename ValueType>
bool SparseGrid<ValueType>::isSet(const GridLocation& loc) const {
    return isSet(loc.row, loc.col);
}

template <typename ValueType>
GridLocationRange SparseGrid<ValueType>::locations(bool rowMajor) const {
    return GridLocationRange(0, 0, numRows() - 1, numCols() - 1, rowMajor);
}

template <typename ValueType>
void SparseGrid<ValueType>::mapAll(void (*fn)(ValueType value)) const {
    for (int row = 0; row < _rowCount; row++) {
        for (int col = 0; col < _columnCount; col++) {
            if (isSet(row, col)) {
                fn(get(row, col));
            }
        }
    }
}

template <typename ValueType>
void SparseGrid<ValueType>::mapAll(void (*fn)(const ValueType& value)) const {
    for (int row = 0; row < _rowCount; row++) {
        for (int col = 0; col < _columnCount; col++) {
            if (isSet(row, col)) {
                fn(get(row, col));
            }
        }
    }
}

template <typename ValueType>
template <typename FunctorType>
void SparseGrid<ValueType>::mapAll(FunctorType fn) const {
    for (int row = 0; row < _rowCount; row++) {
        for (int col = 0; col < _columnCount; col++) {
            if (isSet(row, col)) {
                fn(get(row, col));
            }
        }
    }
}

template <typename ValueType>
int SparseGrid<ValueType>::numCols() const {
    return _columnCount;
}

template <typename ValueType>
int SparseGrid<ValueType>::numRows() const {
    return _rowCount;
}

template <typename ValueType>
void SparseGrid<ValueType>::resize(int nRows, int nCols, bool retain) {
    if (nRows < 0 || nCols < 0) {
        std::ostringstream out;
        out << "SparseGrid::resize: Attempt to resize grid to invalid size ("
               << nRows << ", " << nCols << ")";
        error(out.str());
    }
    int oldnRows = this->_rowCount;
    int oldnCols = this->_columnCount;
    this->_rowCount = nRows;
    this->_columnCount = nCols;
    
    if (retain) {
        // if resizing to a smaller size, must evict any row/col entries
        // that exceed the new grid's bounds
        if (nRows < oldnRows || nCols < oldnCols) {
            Map<int, Map<int, ValueType>> newElements;
            for (int row : _elements) {
                if (row >= nRows) {
                    break;   // don't add any entries beyond this row
                }
                for (int col : _elements[row]) {
                    if (col >= nCols) {
                        break;   // don't add any entries beyond this row
                    }
                    newElements[row][col] = _elements[row][col];
                }
            }
            _elements = newElements;
        }
    } else {
        _elements.clear();
    }
    _version++;
}

template <typename ValueType>
void SparseGrid<ValueType>::set(int row, int col, const ValueType& value) {
    checkIndexes(row, col, _rowCount-1, _columnCount-1, "set");
    _elements[row][col] = value;
    _version++;
}

template <typename ValueType>
void SparseGrid<ValueType>::set(const GridLocation& loc, const ValueType& value) {
    set(loc.row, loc.col, value);
}

template <typename ValueType>
int SparseGrid<ValueType>::size() const {
    int count = 0;
    for (int row : _elements) {
        count += _elements[row].size();
    }
    return count;
}

template <typename ValueType>
std::string SparseGrid<ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename ValueType>
std::string SparseGrid<ValueType>::toString2D(
        std::string rowStart, std::string rowEnd,
        std::string colSeparator, std::string rowSeparator) const {
    std::ostringstream os;
    os << rowStart;
    int nRows = numRows();
    int nCols = numCols();
    for (int i = 0; i < nRows; i++) {
        if (!_elements.containsKey(i) || _elements[i].isEmpty()) {
            continue;
        }
        if (i > 0) {
            os << rowSeparator;
        }
        os << rowStart;
        for (int j = 0; j < nCols; j++) {
            if (j > 0) {
                os << colSeparator;
            }
            if (isSet(i, j)) {
                writeGenericValue(os, get(i, j), true);
            }
        }
        os << rowEnd;
    }
    os << rowEnd;
    return os.str();
}

template <typename ValueType>
void SparseGrid<ValueType>::unset(int row, int col) {
    checkIndexes(row, col, _rowCount-1, _columnCount-1, "unset");
    if (_elements.containsKey(row)) {
        _elements[row].remove(col);
        if (_elements[row].isEmpty()) {
            _elements.remove(row);
        }
    }
    _version++;
}

template <typename ValueType>
void SparseGrid<ValueType>::unset(const GridLocation& loc) {
    unset(loc.row, loc.col);
}

template <typename ValueType>
unsigned int SparseGrid<ValueType>::version() const {
    return _version;
}

template <typename ValueType>
int SparseGrid<ValueType>::width() const {
    return _columnCount;
}

template <typename ValueType>
void SparseGrid<ValueType>::checkIndexes(int row, int col,
                                         int rowMax, int colMax,
                                         std::string prefix) const {
    const int rowMin = 0;
    const int colMin = 0;
    if (row < rowMin || row > rowMax || col < colMin || col > colMax) {
        std::ostringstream out;
        out << "SparseGrid::" << prefix << ": (" << row << ", " << col << ")"
            << " is outside of valid range [";
        if (rowMin < rowMax && colMin < colMax) {
            out << "(" << rowMin << ", " << colMin <<  ")..("
                << rowMax << ", " << colMax << ")";
        } else if (rowMin == rowMax && colMin == colMax) {
            out << "(" << rowMin << ", " << colMin <<  ")";
        } // else min > max, no range, empty grid
        out << "]";
        error(out.str());
    }
}

template <typename ValueType>
int SparseGrid<ValueType>::gridCompare(const SparseGrid& grid2) const {
    int h1 = height();
    int w1 = width();
    int h2 = grid2.height();
    int w2 = grid2.width();
    int rows = h1 > h2 ? h1 : h2;
    int cols = w1 > w2 ? w1 : w2;
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (r >= h1) {
                return -1;
            } else if (r >= h2) {
                return 1;
            }
            
            if (c >= w1) {
                return -1;
            } else if (c >= w2) {
                return 1;
            }
            
            if (!isSet(r, c) && grid2.isSet(r, c)) {
                return -1;
            } else if (isSet(r, c) && !grid2.isSet(r, c)) {
                return 1;
            }
            
            if (get(r, c) < grid2.get(r, c)) {
                return -1;
            } else if (grid2.get(r, c) < get(r, c)) {
                return 1;
            }
        }
    }
    return 0;
}

template <typename ValueType>
typename SparseGrid<ValueType>::SparseGridRow SparseGrid<ValueType>::operator [](int row) {
    return SparseGridRow(this, row);
}

template <typename ValueType>
const typename SparseGrid<ValueType>::SparseGridRowConst
SparseGrid<ValueType>::operator [](int row) const {
    return SparseGridRowConst(const_cast<SparseGrid*>(this), row);
}

template <typename ValueType>
ValueType& SparseGrid<ValueType>::operator [](const GridLocation& loc) {
    checkIndexes(loc.row, loc.col, _rowCount-1, _columnCount-1, "operator []");
    return _elements[loc.row][loc.col];
}

template <typename ValueType>
const ValueType& SparseGrid<ValueType>::operator [](const GridLocation& loc) const {
    checkIndexes(loc.row, loc.col, _rowCount-1, _columnCount-1, "operator []");
    return _elements[loc.row][loc.col];
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator ==(const SparseGrid& grid2) const {
    return equals(grid2);
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator !=(const SparseGrid& grid2) const {
    return !equals(grid2);
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator <(const SparseGrid& grid2) const {
    return gridCompare(grid2) < 0;
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator <=(const SparseGrid& grid2) const {
    return gridCompare(grid2) <= 0;
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator >(const SparseGrid& grid2) const {
    return gridCompare(grid2) > 0;
}

template <typename ValueType>
bool SparseGrid<ValueType>::operator >=(const SparseGrid& grid2) const {
    return gridCompare(grid2) >= 0;
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename ValueType>
std::ostream& operator <<(std::ostream& os, const SparseGrid<ValueType>& grid) {
    os << grid._elements << ", " << grid._rowCount << " x " << grid._columnCount;
    return os;
}

template <typename ValueType>
std::istream& operator >>(std::istream& is, SparseGrid<ValueType>& grid) {
    // "{...}, 4 x 3"

    // read "{...}" (map of elements)
    if (!(is >> grid._elements)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("SparseGrid::operator >>: Invalid elements");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }

    // throw away ', ' token
    std::string comma;
    if (!(is >> comma)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("SparseGrid::operator >>: Invalid format");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }

    if (!(is >> grid._rowCount)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("SparseGrid::operator >>: Invalid number of rows");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }

    std::string x;
    is >> x;       // throw away 'x' token

    if (!(is >> grid._columnCount)) {
#ifdef SPL_ERROR_ON_COLLECTION_PARSE
        error("SparseGrid::operator >>: Invalid number of rows");
#endif
        is.setstate(std::ios_base::failbit);
        return is;
    }
    return is;
}

/*
 * Template hash function for sparse grids.
 * Requires the element type in the SparseGrid to have a hashCode function.
 */
template <typename T>
int hashCode(const SparseGrid<T>& grid) {
    return stanfordcpplib::collections::hashCodeCollection(grid);
}

/*
 * Function: randomElement
 * Usage: element = randomElement(grid);
 * -------------------------------------
 * Returns a randomly chosen element of the given grid.
 * Throws an error if the grid is empty.
 */
template <typename T>
const T& randomElement(const SparseGrid<T>& grid) {
    if (grid.isEmpty()) {
        error("randomElement: empty sparse grid was passed");
    }
    
    // pick a non-empty row, then pick a random element from it
    // TODO: fix, this is NOT evenly distributed when rows/cols are unequal in size
    int row = randomKey(grid._elements);
    int col = randomKey(grid._elements[row]);
    return grid.get(row, col);
}

#endif // _sparsegrid_h

/////////////////////// END code extracted from StanfordCPPLib/collections/sparsegrid.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/dawglexicon.h ///////////////////////
/*
 * File: dawglexicon.h
 * -------------------
 * This file exports the <code>DawgLexicon</code> class, which is a
 * compact structure for storing a list of words.
 * 
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2018/03/10
 * - added method front
 * @version 2017/11/14
 * - added iterator version checking support
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/08/11
 * - added methods addAll, containsAll,
 *   operators +, +=, *, *= to better match Set/HashSet
 * @version 2016/08/10
 * - added constructor support for std initializer_list usage, such as {"a", "b", "c"}
 * @version 2016/08/04
 * - added operator >>
 * @version 2014/11/13
 * - added comparison operators <, >=, etc.
 * - added hashCode function
 * @version 2014/10/10
 * - added equals method
 * - added comparison operators ==, !=
 * - added toStlSet method
 * - fixed inclusion of foreach macro to avoid errors
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _dawglexicon_h
#define _dawglexicon_h

#include <initializer_list>
#include <set>
#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE
#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * This class is used to represent a <b><i>lexicon,</i></b> or word list.
 * The main difference between a lexicon and a dictionary is that
 * a lexicon does not provide any mechanism for storing definitions;
 * the lexicon contains only words, with no associated information.
 * It is therefore similar to a set of strings, but with a more
 * space-efficient internal representation.  The <code>DawgLexicon</code>
 * class supports efficient lookup operations for words and prefixes.
 *
 * Currently the recommended implementation of a lexicon is the
 * <code>Lexicon</code> class, which supports more operations than this one.
 */

#include <cctype>

class DawgLexicon {
public:
    /**
     * Initializes a new empty lexicon.
     */
    DawgLexicon();

    /**
     * Initializes a new lexicon, reading in the contents of the lexicon from
     * the specified data file.
     *
     * The data file must be in one of two formats:
     * (1) a space-efficient precompiled binary format or
     * (2) a text file containing one word per line.
     *
     * The Stanford library distribution includes a binary lexicon file named
     * <code>English.dat</code> containing a list of words in English.  The
     * standard code pattern to initialize that lexicon looks like this:
     *
     *<pre>
     * DawgLexicon english("English.dat");
     *</pre>
     */
    DawgLexicon(std::istream& input);

    /**
     * Initializes a new lexicon, reading in the contents of the lexicon from
     * the specified data file.
     *
     * The data file must be in one of two formats:
     * (1) a space-efficient precompiled binary format (e.g. English.dat) or
     * (2) a text file containing one word per line.
     *
     * @example DawgLexicon english("English.dat");
     */
    DawgLexicon(const std::string& filename);

    /**
     * This constructor uses an initializer list to set up the lexicon.
     * @example DawgLexicon lex {1, 2, 3};
     */
    DawgLexicon(std::initializer_list<std::string> list);

    /**
     * The destructor deallocates any storage associated with the lexicon.
     */
    virtual ~DawgLexicon();
    
    /**
     * Adds the specified word to the lexicon.
     */
    void add(const std::string& word);

    /**
     * Adds all elements of the given other lexicon to this lexicon.
     * Identical in behavior to the += operator.
     */
    DawgLexicon& addAll(const DawgLexicon& lex);

    /**
     * Adds all elements of the given list to this lexicon.
     * Identical in behavior to the += operator.
     */
    DawgLexicon& addAll(std::initializer_list<std::string> list);

    /**
     * Reads the input stream and adds all of its words to the lexicon.
     */
    void addWordsFromFile(std::istream& input);
    
    /**
     * Reads the file and adds all of its words to the lexicon.
     */
    void addWordsFromFile(const std::string& filename);
    
    /**
     * Removes all words from the lexicon.
     */
    void clear();
    
    /**
     * Returns <code>true</code> if <code>word</code> is contained in the
     * lexicon.  In the <code>DawgLexicon</code> class, the case of letters is
     * ignored, so "Zoo" is the same as "ZOO" or "zoo".
     */
    bool contains(const std::string& word) const;

    /**
     * Returns <code>true</code> if every value from the given other lexicon
     * is also found in this lexicon.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(const DawgLexicon& set2) const;

    /**
     * Returns <code>true</code> if every value from the given list
     * is also found in this lexicon.
     * Equivalent in behavior to isSupersetOf.
     */
    bool containsAll(std::initializer_list<std::string> list) const;

    /**
     * Returns true if any words in the lexicon begin with <code>prefix</code>.
     * Like <code>containsWord</code>, this method ignores the case of letters
     * so that "MO" is a prefix of "monkey" or "Monday".
     */
    bool containsPrefix(const std::string& prefix) const;
    
    /**
     * Compares two lexicons for equality.
     * Returns <code>true</code> if this lexicon contains exactly the same
     * values as the given other lexicon.
     * Identical in behavior to the == operator.
     */
    bool equals(const DawgLexicon& lex2) const;

    /**
     * Returns the first element in alphabetical order from this lexicon (without removing it).
     * This method signals an error if lexicon is empty.
     */
    std::string front() const;

    /**
     * Adds an element to this lexicon, if it was not already there.  This
     * method is exported for compatibility with the STL <code>set</code> class.
     */
    void insert(const std::string& word);

    /**
     * Returns <code>true</code> if the lexicon contains no words.
     */
    bool isEmpty() const;

    /**
     * Returns <code>true</code> if every word of this lexicon is contained in
     * the given other lexicon.
     */
    bool isSubsetOf(const DawgLexicon& lex2) const;

    /**
     * Returns <code>true</code> if every word of this lexicon is contained in
     * the given list.
     */
    bool isSubsetOf(std::initializer_list<std::string> list) const;

    /**
     * Returns <code>true</code> if every word of this lexicon is contained in
     * the given other lexicon.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(const DawgLexicon& lex2) const;

    /**
     * Returns <code>true</code> if every word of this lexicon is contained in
     * the given list.
     * Equivalent in behavior to containsAll.
     */
    bool isSupersetOf(std::initializer_list<std::string> list) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    void mapAll(void (*fn)(std::string)) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    void mapAll(void (*fn)(const std::string&)) const;

    /**
     * Calls the specified function on each word in the lexicon.
     */
    template <typename FunctorType>
    void mapAll(FunctorType fn) const;

    // implementation note: DawgLexicon does not support removal,
    // so there are no methods remove(), removeAll, retainAll, etc.
    // nor operators -, -=, *=

    /**
     * Returns the number of words contained in the lexicon.
     */
    int size() const;

    /**
     * Converts the lexicon to a printable string representation such as
     * {"a", "b", "c"}.
     * Note that this can be an expensive operation if the lexicon contains
     * a large number of words.
     */
    std::string toString() const;
    
    /**
     * Returns true if the two lexicons have the same elements.
     */
    bool operator ==(const DawgLexicon& lex2) const;

    /**
     * Returns true if the two lexicons do not have the same elements.
     */
    bool operator !=(const DawgLexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons for ordering.
     */
    bool operator <(const DawgLexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons for ordering.
     */
    bool operator <=(const DawgLexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons for ordering.
     */
    bool operator >(const DawgLexicon& lex2) const;

    /**
     * Relational operators to compare two lexicons for ordering.
     */
    bool operator >=(const DawgLexicon& lex2) const;

    /**
     * Returns the union of this lexicon and the given other lexicon,
     * which is the set of words that appear in at least one of the two.
     */
    DawgLexicon operator +(const DawgLexicon& lex2) const;

    /**
     * Returns the union of this lexicon and the given list,
     * which is the set of words that appear in at least one of the two.
     */
    DawgLexicon operator +(std::initializer_list<std::string> list) const;

    /**
     * Returns the union of this lexicon and the given word.
     */
    DawgLexicon operator +(const std::string& word) const;

    /**
     * Adds all of the words from the given lexicon to this one.
     */
    DawgLexicon& operator +=(const DawgLexicon& lex2);

    /**
     * Adds all of the words from the given list to this lexicon.
     */
    DawgLexicon& operator +=(std::initializer_list<std::string> list);

    /**
     * Adds the given word to this lexicon.
     */
    DawgLexicon& operator +=(const std::string& word);

    /**
     * Allows you to add multiple elements to a lexicon.
     * @example lex += "she", "sells", "sea", "shells";
     */
    DawgLexicon& operator ,(const std::string& word);

    // Implementation note: DawgLexicon does not support -, -=, *, and *=
    // operators like the standard Lexicon.  Because of its binary internal
    // format, it is non-trivial to support removal from a DawgLexicon.

    /*
     * Additional DawgLexicon operations
     * ---------------------------------
     * In addition to the methods listed in this interface, the DawgLexicon
     * class supports the following operations:
     *
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * All iteration is guaranteed to proceed in alphabetical order.  All
     * words in the lexicon are stored in lowercase.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

private:
#ifdef _WIN32
#define LITTLE_ENDIAN 1
#define BYTE_ORDER LITTLE_ENDIAN
#endif

#pragma pack(1)
    struct Edge {
#if defined(BYTE_ORDER) && BYTE_ORDER == LITTLE_ENDIAN
        unsigned long letter:5;
        unsigned long lastEdge:1;
        unsigned long accept:1;
        unsigned long unused:1;
        unsigned long children:24;
#else
        unsigned long children:24;
        unsigned long unused:1;
        unsigned long accept:1;
        unsigned long lastEdge:1;
        unsigned long letter:5;
#endif
    };
#pragma pack()
    Edge* _edges;
    Edge* _start;
    int _edgeCount;
    int _dawgWordsCount;
    Set<std::string> _otherWords;

public:
    /*
     * Deep copying support
     * --------------------
     * This copy constructor and operator= are defined to make a
     * deep copy, making it possible to pass/return lexicons by value
     * and assign from one lexicon to another.  The entire contents of
     * the lexicon, including all words, are copied.  Making copies is
     * generally avoided because of the expense and thus, lexicons are
     * typically passed by reference.  When a copy is needed, these
     * operations are supported.
     */
    DawgLexicon(const DawgLexicon& src);
    DawgLexicon& operator =(const DawgLexicon& src);

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    class iterator : public std::iterator<std::input_iterator_tag, std::string> {
    private:
        const DawgLexicon* lp;
        int index;
        std::string currentDawgPrefix;
        std::string currentSetWord;
        std::string tmpWord;
        Edge* edgePtr;
        Stack<Edge*> stack;
        Set<std::string>::iterator setIterator;
        Set<std::string>::iterator setEnd;

        void advanceToNextWordInDawg();
        void advanceToNextWordInSet();
        void advanceToNextEdge();

    public:
        iterator() : lp(nullptr), index(0), edgePtr(nullptr) {
            /* empty */
        }

        iterator(const DawgLexicon* theLP, bool endFlag) {
            this->lp = theLP;
            if (endFlag) {
                index = lp->size();
            } else {
                index = 0;
                edgePtr = nullptr;
                setIterator = lp->_otherWords.begin();
                setEnd = lp->_otherWords.end();
                currentDawgPrefix = "";
                currentSetWord = "";
                advanceToNextWordInDawg();
                advanceToNextWordInSet();
            }
        }

        iterator(const iterator& it) {
            lp = it.lp;
            index = it.index;
            currentDawgPrefix = it.currentDawgPrefix;
            currentSetWord = it.currentSetWord;
            edgePtr = it.edgePtr;
            stack = it.stack;
            setIterator = it.setIterator;
        }

        iterator& operator ++() {
            if (!edgePtr) {
                advanceToNextWordInSet();
            } else {
                if (currentSetWord == "" || currentDawgPrefix < currentSetWord) {
                    advanceToNextWordInDawg();
                } else {
                    advanceToNextWordInSet();
                }
            }
            index++;
            return *this;
        }

        iterator operator ++(int) {
            iterator copy(*this);
            operator++();
            return copy;
        }

        bool operator ==(const iterator& rhs) {
            return lp == rhs.lp && index == rhs.index;
        }

        bool operator !=(const iterator& rhs) {
            return !(*this == rhs);
        }

        std::string operator *() {
            if (!edgePtr) {
                return currentSetWord;
            }
            if (currentSetWord == "" || currentDawgPrefix < currentSetWord) {
                return currentDawgPrefix + lp->ordToChar(edgePtr->letter);
            } else {
                return currentSetWord;
            }
        }

        std::string* operator ->() {
            if (!edgePtr) {
                return &currentSetWord;
            }
            if (currentSetWord == "" || currentDawgPrefix < currentSetWord) {
                tmpWord = currentDawgPrefix + lp->ordToChar(edgePtr->letter);
                return &tmpWord;
            } else {
                return &currentSetWord;
            }
        }
    };

    /**
     * Returns an iterator positioned at the first word in the lexicon.
     */
    iterator begin() const {
        return iterator(this, /* end */ false);
    }

    /**
     * Returns an iterator positioned at the last word in the lexicon.
     */
    iterator end() const {
        return iterator(this, /* end */ true);
    }

private:
    Edge* findEdgeForChar(Edge* children, char ch) const;
    Edge* traceToLastEdge(const std::string& s) const;
    void readBinaryFile(std::istream& input);
    void readBinaryFile(const std::string& filename);
    void deepCopy(const DawgLexicon& src);
    int countDawgWords(Edge* _start) const;

    unsigned int charToOrd(char ch) const {
        return ((unsigned int)(tolower(ch) - 'a' + 1));
    }

    char ordToChar(unsigned int ord) const {
        return ((char)(ord - 1 + 'a'));
    }
};

template <typename FunctorType>
void DawgLexicon::mapAll(FunctorType fn) const {
    for (std::string word : *this) {
        fn(word);
    }
}

/**
 * Hashing function for lexicons.
 */
int hashCode(const DawgLexicon& lex);

/**
 * Prints the lexicon to the given output stream.
 */
std::ostream& operator <<(std::ostream& os, const DawgLexicon& lex);

/**
 * Reads the contents of a lexicon from the given input stream.
 */
std::istream& operator >>(std::istream& is, DawgLexicon& lex);

#endif // _dawglexicon_h

/////////////////////// END code extracted from StanfordCPPLib/collections/dawglexicon.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/linkedhashmap.h ///////////////////////
/*
 * File: linkedhashmap.h
 * ---------------------
 * This file exports the <code>LinkedHashMap</code> class, which stores
 * a set of <i>key</i>-<i>value</i> pairs.
 * Identical to a HashMap except that upon iteration using a for-each loop
 * or << / toString call, it will emit its key/value pairs in the order they
 * were originally inserted.  This is provided at a runtime and memory
 * cost due to needing to store an extra copy of the keys.
 * 
 * @author Marty Stepp
 * @version 2019/04/09
 * - renamed private members with underscore naming scheme for consistency
 * @version 2018/03/10
 * - added methods front, back
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - added support for std initializer_list usage, such as
 *   {{"a", 1}, {"b", 2}, {"c", 3}} in constructor, putAll, removeAll, retainAll,
 *   operators +, +=, -, -=, *, *=
 * - added addAll method
 * - added operators <, <=, >, >=
 * @version 2016/08/12
 * - bug fix in operator >>
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/10/26
 * - initial version
 * @since 2015/10/26
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _linkedhashmap_h
#define _linkedhashmap_h

#include <initializer_list>
#include <iterator>
#include <string>
#include <functional>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/*
 * Class: LinkedHashMap<KeyType,ValueType>
 * ---------------------------------------
 * 
 */
template <typename KeyType, typename ValueType>
class LinkedHashMap {
public:
    /*
     * Constructor: LinkedHashMap
     * Usage: LinkedHashMap<KeyType, ValueType> map;
     * ---------------------------------------------
     * Initializes a new empty map that associates keys and values of
     * the specified types.  The type used for the key must define
     * the <code>==</code> operator, and there must be a free function
     * with the following signature:
     *
     *<pre>
     *    int hashCode(KeyType key);
     *</pre>
     *
     * that returns a positive integer determined by the key.  This interface
     * exports <code>hashCode</code> functions for <code>string</code> and
     * the C++ primitive types.
     */
    LinkedHashMap() = default;

    /*
     * Constructor: LinkedHashMap
     * Usage: LinkedHashMap<ValueType> map {{"a", 1}, {"b", 2}, {"c", 3}};
     * -------------------------------------------------------------------
     * Initializes a new map that stores the given pairs.
     * Note that the pairs are stored in unpredictable order internally and not
     * necessarily the order in which they are written in the initializer list.
     */
    LinkedHashMap(std::initializer_list<std::pair<const KeyType, ValueType>> list);

    /*
     * Destructor: ~LinkedHashMap
     * --------------------
     * Frees any heap storage associated with this map.
     */
    virtual ~LinkedHashMap() = default;

    /*
     * Method: add
     * Usage: map.add(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * A synonym for the put method.
     */
    void add(const KeyType& key, const ValueType& value);

    /*
     * Method: addAll
     * Usage: map.addAll(map2);
     * ------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * You can also pass an initializer list of pairs such as {{"a", 1}, {"b", 2}, {"c", 3}}.
     * Returns a reference to this map.
     * Identical in behavior to putAll.
     */
    LinkedHashMap& addAll(const LinkedHashMap& map2);

    /*
     * Method: back
     * Usage: KeyType value = map.back();
     * ------------------------------------
     * Returns the last key in the map in the order established by the
     * <code>foreach</code> macro.  If the map is empty, generates an error.
     */
    KeyType back() const;

    /*
     * Method: clear
     * Usage: map.clear();
     * -------------------
     * Removes all entries from this map.
     */
    void clear();

    /*
     * Method: containsKey
     * Usage: if (map.containsKey(key)) ...
     * ------------------------------------
     * Returns <code>true</code> if there is an entry for <code>key</code>
     * in this map.
     */
    bool containsKey(const KeyType& key) const;

    /*
     * Method: equals
     * Usage: if (map.equals(map2)) ...
     * --------------------------------
     * Returns <code>true</code> if the two maps contain exactly the same
     * key/value pairs, and <code>false</code> otherwise.
     */
    bool equals(const LinkedHashMap& map2) const;

    /*
     * Method: front
     * Usage: KeyType value = map.front();
     * -------------------------------------
     * Returns the first key in the map in the order established by the
     * <code>foreach</code> macro.  If the map is empty, generates an error.
     */
    KeyType front() const;

    /*
     * Method: get
     * Usage: ValueType value = map.get(key);
     * --------------------------------------
     * Returns the value associated with <code>key</code> in this map.
     * If <code>key</code> is not found, <code>get</code> returns the
     * default value for <code>ValueType</code>.
     */
    ValueType get(const KeyType& key) const;

    /*
     * Method: isEmpty
     * Usage: if (map.isEmpty()) ...
     * -----------------------------
     * Returns <code>true</code> if this map contains no entries.
     */
    bool isEmpty() const;
    
    /*
     * Method: keys
     * Usage: Vector<KeyType> keys = map.keys();
     * -----------------------------------------
     * Returns a collection containing all keys in this map.
     * This implementation already retains an internal copy of the keys,
     * so it is efficient to call this function even on large maps.
     */
    const Vector<KeyType>& keys() const;

    /*
     * Method: mapAll
     * Usage: map.mapAll(fn);
     * ----------------------
     * Iterates through the map entries and calls <code>fn(key, value)</code>
     * for each one.  The keys are processed in an undetermined order.
     */
    void mapAll(std::function<void (const KeyType&, const ValueType &)> fn) const;

    /*
     * Method: put
     * Usage: map.put(key, value);
     * ---------------------------
     * Associates <code>key</code> with <code>value</code> in this map.
     * Any previous value associated with <code>key</code> is replaced
     * by the new value.
     */
    void put(const KeyType& key, const ValueType& value);

    /*
     * Method: putAll
     * Usage: map.putAll(map2);
     * ---------------------------
     * Adds all key/value pairs from the given map to this map.
     * If both maps contain a pair for the same key, the one from map2 will
     * replace the one from this map.
     * Returns a reference to this map.
     */
    LinkedHashMap& putAll(const LinkedHashMap& map2);

    /*
     * Method: remove
     * Usage: map.remove(key);
     * -----------------------
     * Removes any entry for <code>key</code> from this map.
     * If the given key is not found, has no effect.
     */
    void remove(const KeyType& key);

    /*
     * Method: removeAll
     * Usage: map.removeAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will not be removed.
     * Returns a reference to this map.
     */
    LinkedHashMap& removeAll(const LinkedHashMap& map2);

    /*
     * Method: retainAll
     * Usage: map.retainAll(map2);
     * ---------------------------
     * Removes all key/value pairs from this map that are not contained in the given map.
     * If both maps contain the same key but it maps to different values, that
     * mapping will be removed.
     * Returns a reference to this map.
     */
    LinkedHashMap& retainAll(const LinkedHashMap& map2);

    /*
     * Method: size
     * Usage: int nEntries = map.size();
     * ---------------------------------
     * Returns the number of entries in this map.
     */
    int size() const;

    /*
     * Method: toString
     * Usage: string str = map.toString();
     * -----------------------------------
     * Converts the map to a printable string representation.
     */
    std::string toString() const;

    /*
     * Method: values
     * Usage: Vector<ValueType> values = map.values();
     * -----------------------------------------------
     * Returns a collection containing all values in this map.
     * Note that this implementation makes a deep copy of the values,
     * so it is inefficient to call on large maps.
     */
    Vector<ValueType> values() const;

    /*
     * Operator: []
     * Usage: map[key]
     * ---------------
     * Selects the value associated with <code>key</code>.  This syntax
     * makes it easy to think of a map as an "associative array"
     * indexed by the key type.  If <code>key</code> is already present
     * in the map, this function returns a reference to its associated
     * value.  If key is not present in the map, a new entry is created
     * whose value is set to the default for the value type.
     */
    // ValueType& operator [](const KeyType& key);
    ValueType operator [](const KeyType& key) const;

    /*
     * Operator: ==
     * Usage: if (map1 == map2) ...
     * ----------------------------
     * Compares two maps for equality.
     */
    bool operator ==(const LinkedHashMap& map2) const;

    /*
     * Operator: !=
     * Usage: if (map1 != map2) ...
     * ----------------------------
     * Compares two maps for inequality.
     */
    bool operator !=(const LinkedHashMap& map2) const;

    /*
     * Operators: <, <=, >, >=
     * Usage: if (map1 < map2) ...
     * ---------------------------
     * Relational operators to compare two maps.
     * The <, >, <=, >= operators require that the ValueType has a < operator
     * so that the elements can be compared pairwise.
     */
    bool operator <(const LinkedHashMap& map2) const;
    bool operator <=(const LinkedHashMap& map2) const;
    bool operator >(const LinkedHashMap& map2) const;
    bool operator >=(const LinkedHashMap& map2) const;

    /*
     * Operator: +
     * Usage: map1 + map2
     * ------------------
     * Returns the union of the two maps, equivalent to a copy of the first map
     * with addAll called on it passing the second map as a parameter.
     * If the two maps both contain a mapping for the same key, the mapping
     * from the second map is favored.
     */
    LinkedHashMap operator +(const LinkedHashMap& map2) const;

    /*
     * Operator: +=
     * Usage: map1 += map2;
     * --------------------
     * Adds all key/value pairs from the given map to this map.
     * Equivalent to calling addAll(map2).
     */
    LinkedHashMap& operator +=(const LinkedHashMap& map2);


    /*
     * Operator: -
     * Usage: map1 - map2
     * ------------------
     * Returns the difference of the two maps, equivalent to a copy of the first map
     * with removeAll called on it passing the second map as a parameter.
     */
    LinkedHashMap operator -(const LinkedHashMap& map2) const;


    /*
     * Operator: -=
     * Usage: map1 -= map2;
     * --------------------
     * Removes all key/value pairs from the given map to this map.
     * Equivalent to calling removeAll(map2).
     */
    LinkedHashMap& operator -=(const LinkedHashMap& map2);


    /*
     * Operator: *
     * Usage: map1 * map2
     * ------------------
     * Returns the intersection of the two maps, equivalent to a copy of the first map
     * with retainAll called on it passing the second map as a parameter.
     */
    LinkedHashMap operator *(const LinkedHashMap& map2) const;


    /*
     * Operator: *=
     * Usage: map1 *= map2;
     * ---------------------
     * Removes all key/value pairs that are not found in the given map from this map.
     * Equivalent to calling retainAll(map2).
     */
    LinkedHashMap& operator *=(const LinkedHashMap& map2);

    template <typename K, typename V>
    friend std::ostream& operator <<(std::ostream& os, const LinkedHashMap<K, V>& map);
    
    /*
     * Additional LinkedHashMap operations
     * -----------------------------------
     * In addition to the methods listed in this interface, the HashMap
     * class supports the following operations:
     *
     *   - Stream I/O using the << and >> operators
     *   - Deep copying for the copy constructor and assignment operator
     *   - Iteration using the range-based for statement and STL iterators
     *
     * During iteration, the LinkedHashMap class returns its keys in the
     * order they were added.
     */

    /* Private section */

    /**********************************************************************/
    /* Note: Everything below this point in the file is logically part    */
    /* of the implementation and should not be of interest to clients.    */
    /**********************************************************************/

    /*
     * Implementation notes:
     * ---------------------
     * The LinkedHashMap class is represented using a hash map along with a
     * Vector to remember the order of insertion.
    */
private:
    HashMap<KeyType, ValueType> _map;
    Vector<KeyType> _keys;

public:
    /*
     * Hidden features
     * ---------------
     * The remainder of this file consists of the code required to
     * support deep copying and iteration.  Including these methods
     * in the public interface would make that interface more
     * difficult to understand for the average client.
     */

    /*
     * Iterator support
     * ----------------
     * The classes in the StanfordCPPLib collection implement input
     * iterators so that they work symmetrically with respect to the
     * corresponding STL classes.
     */
    using const_iterator = typename Vector<KeyType>::const_iterator;
    using iterator = const_iterator;

    /*
     * Returns an iterator positioned at the first key of the map.
     */
    const_iterator begin() const {
        return _keys.begin();
    }

    /*
     * Returns an iterator positioned at the last key of the map.
     */
    const_iterator end() const {
        return _keys.end();
    }
};

/*
 * Implementation notes: LinkedHashMap class
 * -----------------------------------------
 * ...
 */
template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>::LinkedHashMap(std::initializer_list<std::pair<const KeyType, ValueType>> list) {
    for (const auto& entry: list) {
        put(entry.first, entry.second);
    }
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::add(const KeyType& key, const ValueType& value) {
    put(key, value);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::addAll(const LinkedHashMap& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
KeyType LinkedHashMap<KeyType, ValueType>::back() const {
    if (isEmpty()) {
        error("LinkedHashMap::back: map is empty");
    }
    return _keys.back();
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::clear() {
    _map.clear();
    _keys.clear();
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::containsKey(const KeyType& key) const {
    return _map.containsKey(key);
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::equals(const LinkedHashMap<KeyType, ValueType>& map2) const {
    return stanfordcpplib::collections::equalsMap(*this, map2);
}

template <typename KeyType, typename ValueType>
KeyType LinkedHashMap<KeyType, ValueType>::front() const {
    if (isEmpty()) {
        error("LinkedHashMap::front: map is empty");
    }
    return _keys.front();
}

template <typename KeyType, typename ValueType>
ValueType LinkedHashMap<KeyType, ValueType>::get(const KeyType& key) const {
    return _map.get(key);
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::isEmpty() const {
    return _map.isEmpty();
}

template <typename KeyType, typename ValueType>
const Vector<KeyType>& LinkedHashMap<KeyType, ValueType>::keys() const {
    return _keys;
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::mapAll(std::function<void (const KeyType&, const ValueType &)> fn) const {
    _map.mapAll(fn);
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::put(const KeyType& key, const ValueType& value) {
    _map.put(key, value);
    _keys.add(key);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::putAll(const LinkedHashMap& map2) {
    for (const KeyType& key : map2) {
        put(key, map2.get(key));
    }
    return *this;
}

template <typename KeyType, typename ValueType>
void LinkedHashMap<KeyType, ValueType>::remove(const KeyType& key) {
    _map.remove(key);
    for (int i = 0, sz = _keys.size(); i < sz; i++) {
        if (_keys[i] == key) {
            _keys.remove(i);
            break;
        }
    }
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::removeAll(const LinkedHashMap& map2) {
    for (const KeyType& key : map2) {
        if (containsKey(key) && get(key) == map2.get(key)) {
            remove(key);
        }
    }
    return *this;
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::retainAll(const LinkedHashMap& map2) {
    Vector<KeyType> toRemove;
    for (const KeyType& key : *this) {
        if (!map2.containsKey(key) || get(key) != map2.get(key)) {
            toRemove.add(key);
        }
    }
    for (const KeyType& key : toRemove) {
        remove(key);
    }
    return *this;
}

template <typename KeyType, typename ValueType>
int LinkedHashMap<KeyType, ValueType>::size() const {
    return _map.size();
}

template <typename KeyType, typename ValueType>
std::string LinkedHashMap<KeyType, ValueType>::toString() const {
    std::ostringstream os;
    os << *this;
    return os.str();
}

template <typename KeyType, typename ValueType>
Vector<ValueType> LinkedHashMap<KeyType, ValueType>::values() const {
    Vector<ValueType> values;
    for (const KeyType& key : *this) {
        values.add(get(key));
    }
    return values;
}

template <typename KeyType, typename ValueType>
ValueType LinkedHashMap<KeyType, ValueType>::operator [](const KeyType& key) const {
    return _map[key];
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType> LinkedHashMap<KeyType, ValueType>::operator +(const LinkedHashMap& map2) const {
    LinkedHashMap<KeyType, ValueType> result = *this;
    return result.putAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::operator +=(const LinkedHashMap& map2) {
    return putAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType> LinkedHashMap<KeyType, ValueType>::operator -(const LinkedHashMap& map2) const {
    LinkedHashMap<KeyType, ValueType> result = *this;
    return result.removeAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::operator -=(const LinkedHashMap& map2) {
    return removeAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType> LinkedHashMap<KeyType, ValueType>::operator *(const LinkedHashMap& map2) const {
    LinkedHashMap<KeyType, ValueType> result = *this;
    return result.retainAll(map2);
}

template <typename KeyType, typename ValueType>
LinkedHashMap<KeyType, ValueType>& LinkedHashMap<KeyType, ValueType>::operator *=(const LinkedHashMap& map2) {
    return retainAll(map2);
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator ==(const LinkedHashMap& map2) const {
    return equals(map2);
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator !=(const LinkedHashMap& map2) const {
    return !equals(map2);
}

// Implementation note:
// The definitions of <, <=, >, and >= are a bit unintuitive here.
// Because Maps are considered to be "equal" if they have the same key/value pairs,
// regardless of order, the equals() method and == / != operators ignore order.
//
// Similarly, if you ask whether a map is <= or >= to another, this includes
// the notion of equality, so it should return true if the maps contain the same
// pairs, regardless of order.
//
// If you ask whether a map is < or > to another, it is assumed that you don't
// want this to return true if they are "equal", so we must check for non-equality
// before checking the K/V pairs pairwise.
//
// This issue is unique to LinkedHashMap because Map sorts into a predictable sorted order
// and HashMap opts not to implement <, <=, >, or >= due to its unpredictable hash order.

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator <(const LinkedHashMap& map2) const {
    return !equals(map2) && stanfordcpplib::collections::compareMaps(*this, map2) < 0;
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator <=(const LinkedHashMap& map2) const {
    return equals(map2) || stanfordcpplib::collections::compareMaps(*this, map2) <= 0;
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator >(const LinkedHashMap& map2) const {
    return !equals(map2) && stanfordcpplib::collections::compareMaps(*this, map2) > 0;
}

template <typename KeyType, typename ValueType>
bool LinkedHashMap<KeyType, ValueType>::operator >=(const LinkedHashMap& map2) const {
    return equals(map2) || stanfordcpplib::collections::compareMaps(*this, map2) >= 0;
}

/*
 * Implementation notes: << and >>
 * -------------------------------
 * The insertion and extraction operators use the template facilities in
 * strlib.h to read and write generic values in a way that treats strings
 * specially.
 */
template <typename KeyType, typename ValueType>
std::ostream& operator <<(std::ostream& os,
                          const LinkedHashMap<KeyType, ValueType>& map) {
    return stanfordcpplib::collections::writeMap(os, map);
}

template <typename KeyType, typename ValueType>
std::istream& operator >>(std::istream& is,
                          LinkedHashMap<KeyType, ValueType>& map) {
    KeyType key;
    ValueType value;
    return stanfordcpplib::collections::readMap(is, map, key, value, /* descriptor */ std::string("LinkedHashMap::operator >>"));
}

/*
 * Template hash function for hash maps.
 * Requires the key and value types in the LinkedHashMap to have a hashCode function.
 */
template <typename K, typename V>
int hashCode(const LinkedHashMap<K, V>& map) {
    return stanfordcpplib::collections::hashCodeMap(map, /* orderMatters */ false);
}

/*
 * Function: randomKey
 * Usage: element = randomKey(map);
 * --------------------------------
 * Returns a randomly chosen key of the given map.
 * Throws an error if the map is empty.
 */
template <typename K, typename V>
const K& randomKey(const LinkedHashMap<K, V>& map) {
    return stanfordcpplib::collections::randomElement(map);
}

#endif // _linkedhashmap_h

/////////////////////// END code extracted from StanfordCPPLib/collections/linkedhashmap.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/linkedhashset.h ///////////////////////
/*
 * File: linkedhashset.h
 * ---------------------
 * This file exports the <code>LinkedHashSet</code> class, which
 * implements an efficient abstraction for storing sets of values.
 * 
 * @author Marty Stepp
 * @version 2019/02/04
 * - changed internal implementation to wrap std collections
 * @version 2018/03/10
 * - added methods front, back
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - added containsAll, isSupersetOf methods
 * - added support for std initializer_list usage, such as {1, 2, 3}
 *   in constructor, addAll, containsAll, isSubsetOf, isSupersetOf, removeAll,
 *   retainAll, and operators +, +=, -, -=, *, *=
 * - bug fix in hashCode function
 * - added operators <, <=, >, >=
 * @version 2016/08/04
 * - fixed operator >> to not throw errors
 * @version 2015/10/26
 * - initial version
 * @since 2015/10/26
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _linkedhashset_h
#define _linkedhashset_h

#include <initializer_list>
#include <iostream>
#include <functional>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/* Traits type for the LinkedHashSet, which wraps an underlying LinkedHashMap. */
namespace stanfordcpplib {
    namespace collections {
        template <typename T> struct LinkedHashSetTraits {
            using ValueType = T;
            using MapType   = LinkedHashMap<T, bool>;
            static std::string name() {
                return "LinkedHashSet";
            }

            /* You can default-construct a LinkedHashSet. */
            static MapType construct() {
                return {};
            }

            /* However, you can't pass in any other arguments. */
            template <typename... Args>
            static void construct(Args&&...) {
                static_assert(Fail<Args...>::value, "Oops! Seems like you tried to initialize a LinkedHashSet incorrectly. Click here for details.");

                /*
                 * Hello student! If you are reading this message, it means that you tried to
                 * initialize a LinkedHashSet improperly. For example, you might have tried to
                 * write something like this:
                 *
                 *     LinkedHashSet<int> mySet = 137; // Oops!
                 *
                 * Here, for example, you're trying to assign an int to a LinkedHashSet<int>.
                 *
                 * or perhaps you had a function like this one:
                 *
                 *     void myFunction(LinkedHashSet<int>& mySet);
                 *
                 * and you called it by writing
                 *
                 *     myFunction(someSet + someOtherSet); // Oops!
                 *     myFunction({ });                    // Oops!
                 *
                 * In these cases, you're trying to pass a value into a function that takes
                 * its argument by (non-const) reference. C++ doesn't allow you to do this.
                 *
                 * To see where the actual error comes from, look in the list of error messages
                 * in Qt Creator. You should see a line that says "required from here" that
                 * points somewhere in your code. That's the actual line you wrote that caused
                 * the problem, so double-click on that error message and see where it takes
                 * you. Now you know where to look!
                 *
                 * Hope this helps!
                 */
                error("static_assert succeeded?");
            }
        };
    }
}

/*
 * A set of elements that remembers their insertion order during iteration. To use
 * this type, the underlying elements must support a function
 *
 *     int hashCode(ValueType);
 *
 * that returns a nonnegative integer, along with equality comparison using ==.
 */
template <typename ValueType>
    using LinkedHashSet = stanfordcpplib::collections::GenericSet<stanfordcpplib::collections::LinkedHashSetTraits<ValueType>>;

#endif // _linkedhashset_h

/////////////////////// END code extracted from StanfordCPPLib/collections/linkedhashset.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/basicgraph.h ///////////////////////
/*
 * File: basicgraph.h
 * ------------------
 * This file contains the declaration of some useful graph types,
 * specifically the Vertex and Edge structures used in the typical graph.
 * together in lecture.  We also declare BasicGraph, an instantiation of
 * Stanford's Graph class using Vertex and Edge as its type parameters.
 *
 * Most members are implemented in this file, since the class is a template.
 * See BasicGraph.cpp for implementation of some non-template members.
 *
 * @author Marty Stepp
 * @version 2018/09/07
 * - reformatted doc-style comments
 * @version 2018/03/10
 * - added methods front, back, toMap
 * - added operator << for various collections of Vertex* and Edge*
 * @version 2018/02/28
 * - compiler flag to enable/disable Vertex fields like visited, previous
 * @version 2017/11/14
 * - fix missing "this->" on some methods
 * - added getVertexNames, vertexCount, edgeCount
 * @version 2017/10/24
 * - print nullptr instead of null in uppercase
 * @version 2017/10/18
 * - fix compiler warnings
 * @version 2016/12/09
 * - added iterator version checking support (implicitly via Graph)
 * @version 2016/12/04
 * - bug fix in resetData method (was referring to Vertex* and Edge*)
 * @version 2016/12/01
 * - bug fix in addEdge method (now correctly adds vertexes if not present)
 * - fixed bugs in some node/arc methods (should not crash on empty/null args)
 * @version 2016/11/26
 * - added BasicGraphV, VertexV, EdgeV macros
 * - added getInverseEdgeSet
 * @version 2016/11/19
 * - changed addVertex to not throw when adding duplicates
 * - added operator []
 * @version 2016/11/07
 * - small bug fix for printing cost in operator << (courtesy GitHub @hsivnightbeam)
 * @version 2016/10/14
 * - modified floating-point equality tests to use floatingPointEqual function
 * @version 2016/09/24
 * - refactored to use collections.h utility functions
 * @version 2016/09/22
 * - bug fix for hashCode function
 * @version 2016/08/12
 * - added initializer_list functionality
 * @version 2014/12/04
 * - bug fix: Edge end reference was not properly pointing at finish field
 * @version 2014/11/21
 * - bug fix: Edge weight reference was not properly pointing at cost field
 * @version 2014/11/13
 * - added iterator begin(), end() support so that students can directly
 *   for-each over the vertices of a graph.
 * - added comparison operators ==, !=, <, etc.
 * - bug fix to Edge to add move/copy = operators
 * @version 2014/10/31
 * - bug fix: extraData was being nulled accidentally in Vertex::resetData()
 * @version 2014/10/23
 * - bug fixes based on cppcheck lint output
 * @version 2014/10/20
 * - converted functions to accept const string& rather than string for speed
 * @version 2014/08/16
 * - added Vertex 'weight' alias for 'cost'
 * - added Edge 'weight' alias for 'cost, and 'end' alias for 'finish'
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _basicgraph_h
#define _basicgraph_h

#include <initializer_list>
#include <sstream>
#include <string>
#include <utility>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * Forward declarations of Vertex/Edge structures so that they can refer
 * to each other mutually.
 * @private
 */
template <typename V = void*, typename E = void*>
class EdgeGen;

/**
 * Canonical Vertex (Node) structure implementation needed by Graph class template.
 * Each Vertex structure represents a single vertex in the graph.
 */
template <typename V = void*, typename E = void*>
class VertexGen : public Observable<int> {
public:
    /**
     * The vertex's name as a string.
     */
    std::string name;

    /**
     * The edges outbound from this vertex to its neighbors.
     */
    Set<EdgeGen<V, E>*> arcs;     // required by Stanford Graph;

    /**
     * The edges outbound from this vertex to its neighbors;
     * an alias of the 'arcs' member.
     */
    Set<EdgeGen<V, E>*>& edges;

#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    /**
     * The cost to reach this vertex; initially 0.
     */
    double cost;

    /**
     * An alias for the 'cost' member.
     */
    double& weight;

    /**
     * Whether this vertex has been visited before; initally false.
     */
    bool visited;

    /**
     * The vertex that comes before this one; initially null.
     */
    VertexGen* previous;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS

    /**
     * The following pointer can point to any extra data needed by the vertex.
     * This field is generally not necessary and can be ignored.
     */
    V data;

    /**
     * @private
     */
    V& extraData;       // alias of data; they are the same field

    /**
     * Constructs a vertex with the given name.
     */
    VertexGen(const std::string& name = "");

    /**
     * Copy constructor.
     */
    VertexGen(const VertexGen& other);

    /**
     * Frees up any memory dynamically allocated by this vertex.
     */
    ~VertexGen();

    /**
     * Returns the color of this vertex, if any.  Initially WHITE.
     */
    /* Color */ int getColor() const;

    /**
     * Wipes the supplementary data of this vertex back to its initial state.
     * Specifically, sets cost to 0, visited to false, and previous to nullptr.
     */
    void resetData();

    /**
     * Sets the color of this vertex to be the given color.
     * The color must be one of WHITE, GRAY, YELLOW, or GREEN.
     * Future calls to getColor will return the color you pass here.
     */
    void setColor(/* Color */ int c);

    /**
     * Returns a string representation of this vertex for debugging, such as
     * "Vertex{name=r13c42, cost=11, visited=true, previous=r12c41, neighbors={r12c41, r12c43}}".
     */
    std::string toString() const;

    /**
     * Copy assignment operator.
     */
    VertexGen& operator =(const VertexGen& other);

    /**
     * Move assignment operator.
     */
    VertexGen& operator =(VertexGen&& other);

private:
    /* Color */ int _color;   // vertex's color as passed to setColor
};

/**
 * Makes a vertex printable to an output stream.
 * See toString for an example of the output format.
 * Note that printing a vertex is not the same as printing a vertex pointer.
 * If you try to print a pointer, you will just see its address in hex.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const VertexGen<V, E>& v);

/**
 * Canonical Edge (Arc) structure implementation needed by Graph class template.
 * Each Edge structure represents a single edge in the graph.
 */
template <typename V, typename E>
class EdgeGen {
public:
    /**
     * The edge's starting vertex.
     */
    VertexGen<V, E>* start;

    /**
     * The edge's ending vertex.
     */
    VertexGen<V, E>* finish;   // required by Stanford Graph;

    /**
     * An alias of finish; they are the same field.
     */
    VertexGen<V, E>*& end;

    /**
     * The edge's weight; default 0.
     */
    double cost;

    /**
     * An alias for the 'cost' member.
     */
    double& weight;

#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    /**
     * Whether this edge has been visited before; initally false.
     */
    bool visited;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS

    /**
     * A pointer that can point to any extra data needed by the vertex.
     * This field is generally not necessary and can be ignored.
     */
    void* data;

    /**
     * An alias for the 'data' member.
     */
    void*& extraData;

    /**
     * Constructs a new edge between the given start/end vertices with
     * the given cost.
     */
    EdgeGen(VertexGen<V, E>* start = nullptr, VertexGen<V, E>* finish = nullptr, double cost = 0.0);

    /**
     * Frees up any memory dynamically allocated by this edge.
     */
    ~EdgeGen();

    /**
     * Wipes the supplementary data of this edge back to its initial state.
     */
    void resetData();

    /**
     * Returns a string representation of this edge for debugging, such as
     * "Arc{start=r12c42, finish=r12c41, cost=0.75}".
     */
    std::string toString() const;

    /**
     * Copy assignment operator.
     */
    EdgeGen& operator =(const EdgeGen& other);

    /**
     * Move assignment operator.
     */
    EdgeGen& operator =(EdgeGen&& other);
};

/**
 * Makes an edge printable to an output stream.
 * See toString for an example of the output format.
 * Note that printing an edge is not the same as printing an edge pointer.
 * If you try to print a pointer, you will just see its address in hex.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const EdgeGen<V, E>& edge);


/**
 * BasicGraph is just basically an instantiation of Graph using Vertex and Edge
 * as its template parameters.  It also adds a few convenience functions such
 * as mirroring members like "addArc" with an equivalent more familiar name
 * like "addEdge".
 *
 * There are a few convenience functions related to neighbors, like isNeighbor.
 * BasicGraph contains a DFS implementation called isReachable, not found
 * in the normal Stanford Graph class.
 *
 * There are also a few functions added to make edges more convenient to work with:
 * getEdge(v1, v2) to get the edge between a given pair of vertices,
 * and getInverseEdge(edge) to get the edge v2 -> v1 for a given edge v1 -> v2.
 */
template <typename V = void*, typename E = void*>
class BasicGraphGen : public Graph<VertexGen<V, E>, EdgeGen<V, E>> {
public:
    /**
     * Constructs a new empty graph.
     * @bigoh O(1)
     */
    BasicGraphGen();

    /**
     * Constructs a new graph containing the given vertexes.
     * @bigoh O(V)
     */
    BasicGraphGen(std::initializer_list<std::string> vertexList);

    /**
     * Adds a directed edge to the graph from vertex v1 to vertex v2.
     * Note that it is allowed to have multiple edges between the same pair of vertexes.
     *
     * Returns a pointer to the edge, though clients need not store that pointer;
     * you can get the pointer again later by calling getEdge and passing the two vertexes.
     *
     * Equivalent to addNode.
     *
     * @return a pointer to the edge created
     * @bigoh O(log V + log E)
     */
    EdgeGen<V, E>* addEdge(const std::string& v1, const std::string& v2, double cost = 0.0, bool directed = true);

    /**
     * Adds a directed edge to the graph from vertex v1 to vertex v2.
     * If either vertex is not found in the graph, said vertex will be added to the graph.
     * Note that it is allowed to have multiple edges between the same pair of vertexes.
     *
     * Returns a pointer to the edge, though clients need not store that pointer;
     * you can get the pointer again later by calling getEdge and passing the two vertexes.
     *
     * Equivalent to addNode.
     *
     * @return a pointer to the edge created
     * @throw ErrorException if either vertex is null
     * @bigoh O(log V + log E)
     */
    EdgeGen<V, E>* addEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2, double cost = 0.0, bool directed = true);

    /**
     * Adds the given directed edge to the graph from vertex v1 to vertex v2.
     * If either vertex is not found in the graph, said vertex will be added to the graph.
     * Note that it is allowed to have multiple edges between the same pair of vertexes.
     *
     * Returns a pointer to the edge, though clients need not store that pointer;
     * you can get the pointer again later by calling getEdge and passing the two vertexes.
     *
     * Equivalent to addNode.
     *
     * @return a pointer to the edge created
     * @throw ErrorException if either vertex is null
     * @bigoh O(log V + log E)
     */
    EdgeGen<V, E>* addEdge(EdgeGen<V, E>* e, bool directed = true);

    /**
     * Adds a vertex to the graph, if no vertex with that name already exists in the graph.
     * This version of this method accepts a string for the vertex's name,
     * creates a new vertex of the appropriate type and initializes its fields.
     * Returns a pointer to the vertex, though clients need not store that pointer;
     * you can get the pointer again later by calling getVertex and passing the same name.
     *
     * The vertexes in a graph must have unique names.
     * If this graph already contains a vertex with the given name,
     * the vertex will not be added and the graph's state will not change.
     *
     * Equivalent to addNode.
     *
     * @return a pointer to the vertex created
     * @bigoh O(log V)
     */
    VertexGen<V, E>* addVertex(const std::string& name);

    /**
     * Adds a vertex to the graph, if no vertex with that name already exists in the graph.
     * This version of this method accepts a string for the vertex's name,
     * creates a new vertex of the appropriate type and initializes its fields.
     * The other accepts a structure representing the vertex and its data.
     * Returns a pointer to the vertex, though clients need not store that pointer;
     * you can get the pointer again later by calling getVertex and passing the same name.
     *
     * The vertexes in a graph must have unique names.
     * If this graph already contains a vertex with the given name,
     * the vertex will not be added and the graph's state will not change.
     *
     * When calling this function, you are relinquishing ownership of the Vertex
     * structure's lifecycle to the graph; our graph will free it when done with it.
     *
     * Equivalent to addNode.
     *
     * @return a pointer to the vertex created
     * @throws ErrorException if vertex is null
     * @bigoh O(log V)
     */
    VertexGen<V, E>* addVertex(VertexGen<V, E>* v);

    /**
     * Removes all edges from the graph.
     * Frees any edge objects that were internally allocated as heap storage.
     *
     * Equivalent to clearArcs.
     * @bigoh O(E log E)
     */
    void clearEdges();

    /**
     * Removes all outbound edges of the given vertex from the graph.
     * The vertex itself is not removed.
     * If the vertex is null or is not found in the graph, has no effect.
     *
     * Equivalent to clearArcs.
     * @bigoh O(E log E)
     * @bigoh O(log V + E)
     */
    void clearEdges(VertexGen<V, E>* v);

    /**
     * Removes all outbound edges of the given vertex from the graph.
     * The vertex itself is not removed.
     * If the vertex is not found in the graph, has no effect.
     *
     * Equivalent to clearArcs.
     * @bigoh O(E log E)
     */
    void clearEdges(const std::string& v);

    /**
     * Returns true if the graph has an edge from v1 to v2 in the graph.
     * If either of the vertexes supplied is null or is not found in the graph, returns false.
     *
     * Equivalent to containsArc.
     * @bigoh O(log E)
     */
    bool containsEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2) const;

    /**
     * Returns true if the graph has an edge from v1 to v2 in the graph.
     * If either of the vertexes supplied is not found in the graph, returns false.
     *
     * Equivalent to containsArc.
     * @bigoh O(log E)
     */
    bool containsEdge(const std::string& v1, const std::string& v2) const;

    /**
     * Returns true if the graph contains the given edge.
     * If the edge structure is null, returns false.
     *
     * Equivalent to containsArc.
     * @bigoh O(log E)
     */
    bool containsEdge(EdgeGen<V, E>* edge) const;

    /**
     * Returns whether the graph contains a vertex with the given name.
     *
     * Equivalent to containsNode.
     * @bigoh O(log V)
     */
    bool containsVertex(const std::string& name) const;

    /**
     * Returns whether the graph contains the given vertex.
     * If a null pointer is passed, returns false.
     *
     * Equivalent to containsNode.
     * @bigoh O(log V)
     */
    bool containsVertex(VertexGen<V, E>* v) const;

    /**
     * Returns the number of edges in the graph.
     *
     * Equivalent to arcCount.
     * @bigoh O(log V)
     */
    int edgeCount() const;

    /**
     * Returns the structure representing the edge from v1 to v2 in the graph.
     * If either of the vertexes supplied is null or is not found in the graph, the function will return nullptr.
     * If there are multiple edges between the given pair of vertexes, which of the edges will be returned is unspecified.
     *
     * Equivalent to getArc.
     *
     * @param v1 start vertex
     * @param v2 end vertex
     * @return edge from v1 to v2, or nullptr if there is no such edge
     * @bigoh O(log V + log E)
     */
    EdgeGen<V, E>* getEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2) const;

    /**
     * Returns the structure representing the edge from v1 to v2 in the graph.
     * If either of the vertexes supplied is not found in the graph, the function will return nullptr.
     * If there are multiple edges between the given pair of vertexes, which of the edges will be returned is unspecified.
     *
     * Equivalent to getArc.
     *
     * @param v1 start vertex
     * @param v2 end vertex
     * @return edge from v1 to v2, or nullptr if there is no such edge
     * @bigoh O(log V + log E)
     */
    EdgeGen<V, E>* getEdge(const std::string& v1, const std::string& v2) const;

    /**
     * Returns the set of all edges in the graph.
     *
     * Equivalent to getArcSet.
     * @bigoh O(1)
     */
    const Set<EdgeGen<V, E>*>& getEdgeSet() const;

    /**
     * Returns the set of all edges that start at the specified vertex.
     * If the vertex supplied is null or is not found in the graph,
     * the function will return an empty set.
     *
     * Equivalent to getArcSet.
     * @bigoh O(1)
     */
    const Set<EdgeGen<V, E>*>& getEdgeSet(VertexGen<V, E>* v) const;

    /**
     * Returns the set of all edges that start at the specified vertex.
     * If the vertex supplied is not found in the graph,
     * the function will return an empty set.
     *
     * Equivalent to getArcSet.
     * @bigoh O(1)
     */
    const Set<EdgeGen<V, E>*>& getEdgeSet(const std::string& v) const;

    /**
     * Returns the edge that is the opposite of the given edge;
     * that is, if the specified edge e starts at v1 and ends at v2,
     * will return the edge that starts at v2 and ends at v1,
     * if such an edge exists in the graph.
     *
     * If the edge supplied is nullptr, is not found in the graph,
     * or has no inverse, the function will return nullptr.
     *
     * If there are multiple edges between the given pair of vertexes,
     * which of the edges will be returned is unspecified.
     *
     * Equivalent to getInverseEdge.
     * @bigoh O(E)
     */
    EdgeGen<V, E>* getInverseArc(EdgeGen<V, E>* edge) const;

    /**
     * Returns the edge that is the opposite of the given edge;
     * that is, if the specified edge e starts at v1 and ends at v2,
     * will return the edge that starts at v2 and ends at v1,
     * if such an edge exists in the graph.
     *
     * If the edge supplied is nullptr, is not found in the graph,
     * or has no inverse, the function will return nullptr.
     *
     * If there are multiple edges between the given pair of vertexes,
     * which of the edges will be returned is unspecified.
     *
     * Equivalent to getInverseArc.
     * @bigoh O(E)
     */
    EdgeGen<V, E>* getInverseEdge(EdgeGen<V, E>* edge) const;

    /**
     * Returns the set of all edges in the graph that end at the specified vertex.
     * If the vertex supplied is null or is not found in the graph,
     * the function will return an empty set.
     *
     * Equivalent to getInverseArcSet.
     * @bigoh O(E)
     */
    const Set<EdgeGen<V, E>*> getInverseEdgeSet(VertexGen<V, E>* v) const;

    /**
     * Returns the set of all edges in the graph that end at the specified vertex.
     * If the vertex supplied is null or is not found in the graph,
     * the function will return an empty set.
     *
     * Equivalent to getInverseArcSet.
     * @bigoh O(E)
     */
    const Set<EdgeGen<V, E>*> getInverseEdgeSet(const std::string& v) const;

    /**
     * Looks up a vertex in the graph by name and returns a pointer to
     * its internal data structure.
     * If no vertex with the specified name exists, returns nullptr.
     * @bigoh O(log V)
     */
    VertexGen<V, E>* getVertex(const std::string& name) const;

    /**
     * Returns a set of the names of all vertexes in the graph.
     * The vertexes will be sorted by name in case-sensitive alphabetical order.
     * @bigoh O(V log V)
     */
    Set<std::string> getVertexNames() const;

    /**
     * Returns the set of all vertexes in the graph.
     * The vertexes will be sorted by name in case-sensitive alphabetical order.
     * @bigoh O(V log V)
     */
    const Set<VertexGen<V, E>*>& getVertexSet() const;

    /**
     * Removes the edge from v1 to v2 from the graph.
     * If more than one edge connects the specified endpoints, all of them are removed.
     * If either of the vertexes supplied is not found in the graph,
     * calling this function will have no effect on the graph.
     * @bigoh O(E + log V)
     */
    void removeEdge(const std::string& v1, const std::string& v2, bool directed = true);

    /**
     * Removes the edge from v1 to v2 from the graph.
     * If more than one edge connects the specified endpoints, all of them are removed.
     * If either of the vertexes supplied is null or not found in the graph,
     * calling this function will have no effect on the graph.
     * @bigoh O(E + log V)
     */
    void removeEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2, bool directed = true);

    /**
     * Removes the given edge from the graph.
     * If the edge supplied is not found in the graph,
     * calling this function will have no effect on the graph.
     * @bigoh O(log E + log V)
     */
    void removeEdge(EdgeGen<V, E>* e, bool directed = true);

    /**
     * Removes the given vertex from the graph.
     * If the vertex is not found in the graph, the call has no effect.
     * @bigoh O(E + log V)
     */
    void removeVertex(const std::string& name);

    /**
     * Removes the given vertex from the graph.
     * If the vertex is null or is not found in the graph, the call has no effect.
     * @bigoh O(E + log V)
     */
    void removeVertex(VertexGen<V, E>* v);

    /**
     * Sets the data stored in each vertex and edge back to its original value
     * by calling resetData on every vertex and edge.
     * @private
     * @bigoh O(V + E)
     */
    void resetData();

    /**
     * Sets whether the resetData method is enabled (default true).
     * @private
     * @bigoh O(1)
     */
    void setResetEnabled(bool enabled);

    /* @inherit */
    virtual void scanArcData(TokenScanner& scanner, EdgeGen<V, E>* edge, EdgeGen<V, E>* inverse);

    /* @inherit */
    virtual void writeArcData(std::ostream& out, EdgeGen<V, E>* edge) const;

    /**
     * Returns a Map representing an adjacency list equivalent to this graph.
     * Each vertex's name is a key in the map, and its neighboring vertexes' names
     * are stored in a Set as the value associated with that key.
     * It should be noted that this member does not preserve the weights of the edges
     * between the neighboring vertexes, so it is not ideal for use with weighted graphs.
     * @bigoh O(V + E)
     */
    Map<std::string, Set<std::string>> toMap() const;

    /**
     * Returns the number of vertexes in the graph.
     * Equivalent to size.
     * @bigoh O(1)
     */
    int vertexCount() const;

    /**
     * Overloads <code>[]</code> to return vertex pointers by vertex name.
     * @bigoh O(log V)
     */
    VertexGen<V, E>* operator [](const std::string& name);

    /**
     * Overloads <code>[]</code> to return vertex pointers by vertex name.
     * @bigoh O(log V)
     */
    const VertexGen<V, E>* operator [](const std::string& name) const;

private:
    bool m_resetEnabled;
};

/**
 * Hash function for BasicGraphGen.
 */
template <typename V, typename E>
int hashCode(const BasicGraphGen<V, E>& graph);

/*
 * Defines a Vertex to be a VertexGen with its data bound to be a void*.
 * Retained for backward compatibility.
 */
typedef VertexGen<void*, void*> Vertex;
#define VertexV VertexGen

/*
 * You can refer to a Vertex as a Node if you prefer.
 */
#define Node Vertex

/*
 * Defines an Edge to be an EdgeGen with its data bound to be a void*.
 * Retained for backward compatibility.
 */
typedef EdgeGen<void*, void*> Edge;
#define EdgeV EdgeGen

/*
 * You can refer to an Edge as an Arc if you prefer.
 */
#define Arc Edge

/*
 * Defines a BasicGraph to be a BasicGraphGen with its data bound to be a void*.
 * Retained for backward compatibility.
 */
typedef BasicGraphGen<void*, void*> BasicGraph;
#define BasicGraphV BasicGraphGen

/**
 * Hash function for BasicGraph.
 */
int hashCode(const BasicGraph& graph);


/*
 * Vertex member implementations
 */
template <typename V, typename E>
VertexGen<V, E>::VertexGen(const std::string& theName)
        : name(theName),
          edges(arcs),
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
          weight(cost),
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
          data(V()),
          extraData(data) {
    resetData();
}

template <typename V, typename E>
VertexGen<V, E>::VertexGen(const VertexGen& other)
    : name(other.name),
      arcs(other.arcs),
      edges(arcs),
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
      cost(other.cost),
      weight(cost),
      visited(other.visited),
      previous(other.previous),
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
      data(other.data),
      extraData(data),
      _color(other._color) {
    // empty
}

template <typename V, typename E>
VertexGen<V, E>::~VertexGen() {
    // empty
}

template <typename V, typename E>
int VertexGen<V, E>::getColor() const {
    return _color;
}

template <typename V, typename E>
void VertexGen<V, E>::resetData() {
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    cost = 0.0;
    previous = nullptr;
    visited = false;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    _color = /* UNCOLORED */ 0;
}

template <typename V, typename E>
void VertexGen<V, E>::setColor(int c) {
    _color = c;
    notifyObservers();
}

template <typename V, typename E>
std::string VertexGen<V, E>::toString() const {
    std::ostringstream out;
    out << *this;
    return out.str();
}

template <typename V, typename E>
VertexGen<V, E>& VertexGen<V, E>::operator =(const VertexGen& other) {
    if (this != &other) {
        name = other.name;
        arcs = other.arcs;
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
        cost = other.cost;
        visited = other.visited;
        previous = other.previous;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
        data = other.data;
        _color = other._color;
    }
    return *this;
}

template <typename V, typename E>
VertexGen<V, E>& VertexGen<V, E>::operator =(VertexGen&& other) {
    if (this != &other) {
        name = other.name;
        arcs = other.arcs;
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
        cost = other.cost;
        visited = other.visited;
        previous = other.previous;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
        data = other.data;
        _color = other._color;
    }
    return *this;
}

template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const VertexGen<V, E>& v) {
    out << "Vertex{name=" << v.name;

#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    if (!floatingPointEqual(v.cost, 0.0)) {
        out << ", cost=" << v.cost;
    }
    out << ", visited=" << (v.visited ? "true" : "false");
    out << ", previous=" << (v.previous == nullptr ? std::string("nullptr") : v.previous->name);
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS

    // print neighbors
    out << ", neighbors={";
    int i = 0;
    for (EdgeGen<V, E>* edge : v.edges) {
        if (i > 0) {
            out << ", ";
        }
        i++;
        if (edge->finish) {
            out << edge->finish->name;
        } else {
            out << "nullptr";
        }
    }
    out << "}";   // end of neighbors

    out << "}";   // end of Vertex
    return out;
}


/*
 * Edge member implementations
 */
template <typename V, typename E>
EdgeGen<V, E>::EdgeGen(VertexGen<V, E>* theStart, VertexGen<V, E>* theFinish, double theCost)
        : start(theStart),
          finish(theFinish),
          end(this->finish),
          cost(theCost),
          weight(this->cost),
          data(nullptr),
          extraData(data) {
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    this->extraData = nullptr;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    this->resetData();
}

template <typename V, typename E>
EdgeGen<V, E>::~EdgeGen() {
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    if (this->extraData != nullptr) {
        this->extraData = nullptr;
        // delete this->extraData;
    }
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
}

template <typename V, typename E>
void EdgeGen<V, E>::resetData() {
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    this->visited = false;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
}

template <typename V, typename E>
std::string EdgeGen<V, E>::toString() const {
    std::ostringstream out;
    out << *this;
    return out.str();
}

template <typename V, typename E>
EdgeGen<V, E>& EdgeGen<V, E>::operator =(const EdgeGen& other) {
    if (this != &other) {
        start = other.start;
        finish = other.finish;
        cost = other.cost;
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
        visited = other.visited;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    }
    return *this;
}

template <typename V, typename E>
EdgeGen<V, E>& EdgeGen<V, E>::operator =(EdgeGen&& other) {
    start = other.start;
    finish = other.finish;
    cost = other.cost;
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    visited = other.visited;
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    return *this;
}

/**
 * Writes the given edge structure to the given output stream.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const EdgeGen<V, E>& edge) {
    out << "Edge{start=";
    if (!edge.start) {
        out << "nullptr";
    } else {
        out << edge.start->name;
    }
    out << ", finish=";
    if (!edge.finish) {
        out << "nullptr";
    } else {
        out << edge.finish->name;
    }
    if (!floatingPointEqual(edge.cost, 0.0)) {
        out << ", cost=" << edge.cost;
    }
#ifdef SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    if (edge.visited) {
        out << ", visited=" << (edge.visited ? "true" : "false");
    }
#endif // SPL_BASICGRAPH_VERTEX_EDGE_RICH_MEMBERS
    out << "}";
    return out;
}


/*
 * BasicGraph member implementations
 */
template <typename V, typename E>
BasicGraphGen<V, E>::BasicGraphGen() : Graph<VertexGen<V, E>, EdgeGen<V, E>>() {
    m_resetEnabled = true;
}

template <typename V, typename E>
BasicGraphGen<V, E>::BasicGraphGen(std::initializer_list<std::string> vertexList)
        : Graph<VertexGen<V, E>, EdgeGen<V, E>>() {
    m_resetEnabled = true;
    for (const std::string& vertexName : vertexList) {
        this->addVertex(vertexName);
    }
}

template <typename V, typename E>
void BasicGraphGen<V, E>::clearEdges() {
    this->clearArcs();
}

template <typename V, typename E>
void BasicGraphGen<V, E>::clearEdges(VertexGen<V, E>* v) {
    this->clearArcs(v);
}

template <typename V, typename E>
void BasicGraphGen<V, E>::clearEdges(const std::string& v) {
    this->clearArcs(v);
}

template <typename V, typename E>
bool BasicGraphGen<V, E>::containsEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2) const {
    return this->containsArc(v1, v2);
}

template <typename V, typename E>
bool BasicGraphGen<V, E>::containsEdge(const std::string& v1, const std::string& v2) const {
    return this->containsArc(v1, v2);
}

template <typename V, typename E>
bool BasicGraphGen<V, E>::containsEdge(EdgeGen<V, E>* edge) const {
    return this->containsArc(edge);
}

template <typename V, typename E>
bool BasicGraphGen<V, E>::containsVertex(const std::string& name) const {
    return this->containsNode(name);
}

template <typename V, typename E>
bool BasicGraphGen<V, E>::containsVertex(VertexGen<V, E>* v) const {
    return this->containsNode(v);
}

template <typename V, typename E>
int BasicGraphGen<V, E>::edgeCount() const {
    return this->arcCount();
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::getEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2) const {
    return this->getArc(v1, v2);
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::getEdge(const std::string& v1, const std::string& v2) const {
    return this->getArc(v1, v2);
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::getInverseArc(EdgeGen<V, E>* edge) const {
    return this->getArc(edge->finish, edge->start);
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::getInverseEdge(EdgeGen<V, E>* edge) const {
    return this->getInverseArc(edge);
}

template <typename V, typename E>
void BasicGraphGen<V, E>::resetData() {
    if (m_resetEnabled) {
        for (VertexGen<V, E>* v : this->getVertexSet()) {
            v->resetData();
        }
        for (EdgeGen<V, E>* e : this->getEdgeSet()) {
            e->resetData();
        }
    }
}

template <typename V, typename E>
void BasicGraphGen<V, E>::setResetEnabled(bool enabled) {
    m_resetEnabled = enabled;
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::addEdge(const std::string& v1, const std::string& v2, double cost, bool directed) {
    if (!this->containsVertex(v1)) {
        this->addVertex(v1);
    }
    if (!this->containsVertex(v2)) {
        this->addVertex(v2);
    }
    return this->addEdge(this->getVertex(v1), this->getVertex(v2), cost, directed);
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::addEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2, double cost, bool directed) {
    EdgeGen<V, E>* e = new EdgeGen<V, E>(v1, v2, cost);
    return this->addEdge(e, directed);
}

template <typename V, typename E>
EdgeGen<V, E>* BasicGraphGen<V, E>::addEdge(EdgeGen<V, E>* e, bool directed) {
    EdgeGen<V, E>* result = this->addArc(e);
    if (!directed) {
        EdgeGen<V, E>* result2 = this->addArc(e->finish, e->start);
        result2->cost = e->cost;
    }
    return result;
}

template <typename V, typename E>
VertexGen<V, E>* BasicGraphGen<V, E>::addVertex(const std::string& name) {
    return this->addNode(name);
}

template <typename V, typename E>
VertexGen<V, E>* BasicGraphGen<V, E>::addVertex(VertexGen<V, E>* v) {
    return this->addNode(v);
}

template <typename V, typename E>
const Set<EdgeGen<V, E>*>& BasicGraphGen<V, E>::getEdgeSet() const {
    return this->getArcSet();
}

template <typename V, typename E>
const Set<EdgeGen<V, E>*>& BasicGraphGen<V, E>::getEdgeSet(VertexGen<V, E>* v) const {
    return this->getArcSet(v);
}

template <typename V, typename E>
const Set<EdgeGen<V, E>*>& BasicGraphGen<V, E>::getEdgeSet(const std::string& v) const {
    return this->getArcSet(v);
}

template <typename V, typename E>
const Set<EdgeGen<V, E>*> BasicGraphGen<V, E>::getInverseEdgeSet(VertexGen<V, E>* v) const {
    return this->getInverseArcSet(v);
}

template <typename V, typename E>
const Set<EdgeGen<V, E>*> BasicGraphGen<V, E>::getInverseEdgeSet(const std::string& v) const {
    return this->getInverseArcSet(v);
}


template <typename V, typename E>
VertexGen<V, E>* BasicGraphGen<V, E>::getVertex(const std::string& name) const {
    return this->getNode(name);
}

template <typename V, typename E>
Set<std::string> BasicGraphGen<V, E>::getVertexNames() const {
    return this->getNodeNames();
}


template <typename V, typename E>
const Set<VertexGen<V, E>*>& BasicGraphGen<V, E>::getVertexSet() const {
    return this->getNodeSet();
}

template <typename V, typename E>
void BasicGraphGen<V, E>::removeEdge(const std::string& v1, const std::string& v2, bool directed) {
    this->removeEdge(this->getVertex(v1), this->getVertex(v2), directed);
}

template <typename V, typename E>
void BasicGraphGen<V, E>::removeEdge(VertexGen<V, E>* v1, VertexGen<V, E>* v2, bool directed) {
    this->removeArc(v1, v2);
    if (!directed) {
        this->removeArc(v2, v1);
    }
}

template <typename V, typename E>
void BasicGraphGen<V, E>::removeEdge(EdgeGen<V, E>* e, bool directed) {
    this->removeArc(e);
    if (!directed) {
        this->removeArc(e->finish, e->start);
    }
}

template <typename V, typename E>
void BasicGraphGen<V, E>::removeVertex(const std::string& name) {
    this->removeNode(name);
}

template <typename V, typename E>
void BasicGraphGen<V, E>::removeVertex(VertexGen<V, E>* v) {
    this->removeNode(v);
}

template <typename V, typename E>
Map<std::string, Set<std::string>> BasicGraphGen<V, E>::toMap() const {
    Map<std::string, Set<std::string>> result;
    for (Vertex* v : this->getVertexSet()) {
        Set<std::string> neighborSet;
        for (Vertex* neighbor : this->getNeighbors(v)) {
            neighborSet += neighbor->name;
        }
        result[v->name] = neighborSet;
    }
    return result;
}

template <typename V, typename E>
int BasicGraphGen<V, E>::vertexCount() const {
    return this->nodeCount();
}

template <typename V, typename E>
VertexGen<V, E>* BasicGraphGen<V, E>::operator [](const std::string& name) {
    return this->getVertex(name);
}

template <typename V, typename E>
const VertexGen<V, E>* BasicGraphGen<V, E>::operator [](const std::string& name) const {
    return this->getVertex(name);
}

template <typename V, typename E>
void BasicGraphGen<V, E>::scanArcData(TokenScanner& scanner, EdgeGen<V, E>* edge, EdgeGen<V, E>* inverse) {
    std::string colon = scanner.nextToken();   // ":", skip over
    if (colon == ":") {
        std::string costStr = scanner.nextToken();
        edge->cost = stringToReal(costStr);
        if (inverse) {
            inverse->cost = edge->cost;
        }
    } else {
        // no cost for this edge (cost 0); un-read the colon token because
        // it probably wasn't actually a colon
        scanner.saveToken(colon);
    }
}

template <typename V, typename E>
void BasicGraphGen<V, E>::writeArcData(std::ostream& out, EdgeGen<V, E>* edge) const {
    if (!floatingPointEqual(edge->cost, 0.0)) {
        out << " : ";
        out << edge->cost;
    }
}

/**
 * Template hash function for graphs.
 */
template <typename V, typename E>
int hashCode(const BasicGraphGen<V, E>& graph) {
    int code = hashSeed();
    for (VertexGen<V, E>* v : graph) {
        code = hashMultiplier() * code + hashCode(v->name);
    }
    for (EdgeGen<V, E>* e : graph.getEdgeSet()) {
        code = hashMultiplier() * code + hashCode(e->start->name);
        code = hashMultiplier() * code + hashCode(e->finish->name);
    }
    return (code & hashMask());
}

/**
 * Overloaded operator to print a set of edge pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const HashSet<EdgeGen<V, E>*>& sete) {
    out << "{";
    if (!sete.isEmpty()) {
        bool first = true;
        for (EdgeGen<V, E>* e : sete) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (e) {
                if (e->start) {
                    out << e->start->name;
                } else {
                    out << "null";
                }
                out << " -> ";
                if (e->finish) {
                    out << e->finish->name;
                } else {
                    out << "null";
                }
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a set of vertex pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const HashSet<VertexGen<V, E>*>& setv) {
    out << "{";
    if (!setv.isEmpty()) {
        bool first = true;
        for (VertexGen<V, E>* v : setv) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (v) {
                out << v->name;
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a list of edge pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const LinkedList<EdgeGen<V, E>*>& liste) {
    out << "{";
    if (!liste.isEmpty()) {
        bool first = true;
        for (EdgeGen<V, E>* e : liste) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (e) {
                if (e->start) {
                    out << e->start->name;
                } else {
                    out << "null";
                }
                out << " -> ";
                if (e->finish) {
                    out << e->finish->name;
                } else {
                    out << "null";
                }
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a list of vertex pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const LinkedList<VertexGen<V, E>*>& lst) {
    out << "{";
    if (!lst.isEmpty()) {
        bool first = true;
        for (VertexGen<V, E>* v : lst) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (v) {
                out << v->name;
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a set of edge pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const Set<EdgeGen<V, E>*>& sete) {
    out << "{";
    if (!sete.isEmpty()) {
        bool first = true;
        for (EdgeGen<V, E>* e : sete) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (e) {
                if (e->start) {
                    out << e->start->name;
                } else {
                    out << "null";
                }
                out << " -> ";
                if (e->finish) {
                    out << e->finish->name;
                } else {
                    out << "null";
                }
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a set of vertex pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const Set<VertexGen<V, E>*>& setv) {
    out << "{";
    if (!setv.isEmpty()) {
        bool first = true;
        for (VertexGen<V, E>* v : setv) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (v) {
                out << v->name;
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a vector of edge pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const Vector<EdgeGen<V, E>*>& vece) {
    out << "{";
    if (!vece.isEmpty()) {
        bool first = true;
        for (EdgeGen<V, E>* e : vece) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (e) {
                if (e->start) {
                    out << e->start->name;
                } else {
                    out << "null";
                }
                out << " -> ";
                if (e->finish) {
                    out << e->finish->name;
                } else {
                    out << "null";
                }
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

/**
 * Overloaded operator to print a vector of vertex pointers.
 * Normally it is unwise to override operators for printing pointers,
 * because the pointer could be null or garbage.
 * But in this case we have decided that it is better for students if their
 * attempts to print collections of vertexes and edges are easy to read.
 */
template <typename V, typename E>
std::ostream& operator <<(std::ostream& out, const Vector<VertexGen<V, E>*>& vec) {
    out << "{";
    if (!vec.isEmpty()) {
        bool first = true;
        for (VertexGen<V, E>* v : vec) {
            if (!first) {
                out << ", ";
            }
            first = false;
            if (v) {
                out << v->name;
            } else {
                out << "null";
            }
        }
    }
    out << "}";
    return out;
}

#endif // _basicgraph_h

/////////////////////// END code extracted from StanfordCPPLib/collections/basicgraph.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/collections/stl.h ///////////////////////
/*
 * File: stl.h
 * -----------
 * Contains utility functions related to the STL collections.
 *
 * @author Marty Stepp
 * @version 2018/10/19
 * - added toStl* methods (moved here from being members of our collections)
 *   This is to avoid a default include of STL containers in student code.
 * @version 2016/10/22
 * - added toString
 * @version 2016/09/22
 * - initial version
 * @since 2016/09/22
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _stl_h
#define _stl_h

#include <initializer_list>
#include <iostream>
#include <iterator>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <vector>

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

// STL containers:
// array, vector, deque, forward_list, ist, stack, queue, priority_queue,
// set, multiset, map, multimap, unordered_*, bitset, valarray

/**
 * Writes the given list of values to the given output stream
 * in a "{10, 20, 30}" format.
 */
template <typename T>
std::ostream& operator <<(std::ostream& out, const std::initializer_list<T>& list) {
    return stanfordcpplib::collections::writeCollection(out, list);
}

/**
 * Writes the given vector of values to the given output stream
 * in a "{10, 20, 30}" format.
 */
template <typename T>
std::ostream& operator <<(std::ostream& out, const std::vector<T>& vec) {
    return stanfordcpplib::collections::writeCollection(out, vec);
}

/**
 * Returns an STL queue object with the same elements as this Queue.
 */
template <typename ValueType>
std::deque<ValueType> toStlDeque(const Queue<ValueType>& q) {
    Queue<ValueType> copy = q;
    std::deque<ValueType> result;
    while (!copy.isEmpty()) {
        result.push_back(copy.dequeue());
    }
    return result;
}

/**
 * Returns an STL list object with the same elements as this LinkedList.
 */
template <typename ValueType>
std::list<ValueType> toStlList(const LinkedList<ValueType>& l) {
    std::list<ValueType> result;
    for (const ValueType& value : l) {
        result.push_back(value);
    }
    return result;
}

/**
 * Returns an STL map object with the same elements as this map.
 */
template <typename KeyType, typename ValueType>
std::map<KeyType, ValueType> toStlMap(const Map<KeyType, ValueType>& m) {
    std::map<KeyType, ValueType> result;
    for (const KeyType& key : m) {
        result[key] = m[key];
    }
    return result;
}

/**
 * Returns an STL queue object with the same elements as this Queue.
 */
template <typename ValueType>
std::queue<ValueType> toStlQueue(const Queue<ValueType>& q) {
    Queue<ValueType> copy = q;
    std::queue<ValueType> result;
    while (!copy.isEmpty()) {
        result.push_back(copy.dequeue());
    }
    return result;
}

/**
 * Returns an STL set object with the same elements as this DawgLexicon.
 */
std::set<std::string> toStlSet(const DawgLexicon& lex);

/**
 * Returns an STL set object with the same elements as this Lexicon.
 */
std::set<std::string> toStlSet(const Lexicon& lex);

/**
 * Returns an STL set object with the same elements as this Set.
 */
template <typename ValueType>
std::set<ValueType> toStlSet(const Set<ValueType>& s) {
    std::set<ValueType> result;
    for (ValueType& value : s) {
        result.insert(value);
    }
    return result;
}

/**
 * Returns an STL stack object with the same elements as this Stack.
 */
template <typename ValueType>
std::stack<ValueType> toStlStack(const Stack<ValueType>& s) {
    Stack<ValueType> copy = s;
    std::stack<ValueType> result;
    while (!copy.isEmpty()) {
        result.push(copy.pop());
    }
    return result;
}

/**
 * Returns an STL vector object with the same elements as this Vector.
 */
template <typename ValueType>
std::vector<ValueType> toStlVector(const Vector<ValueType>& v) {
    std::vector<ValueType> result;
    for (int i = 0; i < v.size(); i++) {
        result.push_back(v[i]);
    }
    return result;
}

/**
 * Converts the given list of values to a string such as "{1, 2, 3}".
 */
template <typename T>
std::string toString(const std::initializer_list<T>& list) {
    std::ostringstream out;
    out << list;
    return out.str();
}

/**
 * Converts the given vector of values to a string such as "{1, 2, 3}".
 */
template <typename T>
std::string toString(const std::vector<T>& vec) {
    std::ostringstream out;
    out << vec;
    return out.str();
}

#endif // _stl_h

/////////////////////// END code extracted from StanfordCPPLib/collections/stl.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/graphics/consoletext.h ///////////////////////
/*
 * File: consoletext.h
 * -------------------
 * This file provides a way to use the functions from console.h
 * without mandating the use of the Stanford C++ library's
 * graphical console window.
 * 
 * @author Marty Stepp
 * @version 2018/08/31
 * - initial version
 */

#define __DONT_ENABLE_QT_GRAPHICAL_CONSOLE

#undef __DONT_ENABLE_QT_GRAPHICAL_CONSOLE

/////////////////////// END code extracted from StanfordCPPLib/graphics/consoletext.h ///////////////////////

#define __DONT_ENABLE_GRAPHICAL_CONSOLE
/////////////////////// BEGIN code extracted from StanfordCPPLib/graphics/console.h ///////////////////////
/*
 * File: console.h
 * ---------------
 * This file contains functions related to the library's graphical console window,
 * implemented using the Qt graphics library in native C++ instead of Java.
 * In general if you #include this file, it will implicitly enable the graphical
 * console.  If you don't want to do that, you should #define a flag named
 * __DONT_ENABLE_QT_GRAPHICAL_CONSOLE right before #include'ing this header.
 * Once the graphical console has been enabled, it cannot easily be turned off
 * again for that program.
 * 
 * @author Marty Stepp
 * @version 2018/11/22
 * - added headless mode support
 * @version 2018/10/18
 * - fixed includes to avoid accidentally enabling GUI unintentionally
 * @version 2018/09/08
 * - added doc comments for new documentation generation
 * @version 2018/08/27
 * - cleaned up comments
 * @version 2018/08/23
 * - renamed to console.h to replace Java version
 * - separated out gconsolewindow.h/cpp
 * @version 2018/07/29
 * - menu, icons, hotkeys
 * @version 2018/07/26
 * - refactored GConsoleWindow class
 * @version 2018/07/15
 * - initial version, based on io/console.h
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _console_h
#define _console_h

#include <iostream>
#include <sstream>
#include <string>

#ifndef SPL_HEADLESS_MODE
class GConsoleWindow;
class GDimension;
class GPoint;
#endif // SPL_HEADLESS_MODE

/**
 * Erases the contents of the console window.
 */
void clearConsole();

/**
 * Returns whether the console's "clear" function should be enabled.
 * Default true.  If false, clear() will just print a message
 * rather than actually clearing the console.
 * @private
 */
bool getConsoleClearEnabled();

/**
 * Returns what the console will do when the user hits its "close" button.
 * By default, this is CONSOLE_HIDE_ON_CLOSE unless set otherwise.
 */
/* GWindow::CloseOperation */ int getConsoleCloseOperation();

/**
 * Returns whether or not the input/output from the Stanford graphical
 * console window is being echoed onto the standard operating system terminal
 * window. Initially this is false unless set to true by a previous call to
 * setConsoleEcho(true).
 */
bool getConsoleEcho();

/**
 * Returns whether the graphical console window is enabled.
 * This is true if you have included "qconsole.h" in your program.
 */
bool getConsoleEnabled();

/**
 * Returns whether an event should be generated if the console
 * window is closed.  By default this is false initially.
 * @private
 * @deprecated
 */
bool getConsoleEventOnClose();

/**
 * Returns whether the overall C++ program will terminate if the console
 * window is closed.  By default this is false initially.
 */
bool getConsoleExitProgramOnClose();

/**
 * Returns the font currently being used by the console.  The font
 * is typically a string in the form <code>family-style-size</code>.
 * In this string, <code>family</code> is the name of the font family;
 * <code>style</code> is either missing (indicating a plain font) or one
 * of the strings <code>Bold</code>, <code>Italic</code>, or
 * <code>BoldItalic</code>; and <code>size</code> is an integer
 * indicating the point size.
 * See gfont.h for more information about font strings.
 */
std::string getConsoleFont();

/**
 * Returns the height of the console window in pixels.
 */
double getConsoleHeight();

/**
 * Returns the x/y position of the top-left corner of the console window.
 */
#ifndef SPL_HEADLESS_MODE
GPoint getConsoleLocation();
#endif // SPL_HEADLESS_MODE

/**
 * Returns whether the location of the console window should be remembered and
 * restored between runs of the program.  Initially false.
 */
bool getConsoleLocationSaved();

/**
 * Returns whether or not a feature is enabled that causes exceptions to be
 * echoed to the Stanford graphical console window when they are thrown.
 * Disabled (false) by default.
 */
bool getConsolePrintExceptions();

/**
 * Returns whether functions like setConsoleFont or setConsoleSize
 * are currently ignored.  See setConsoleSettingsLocked.
 * Clients should generally not call this method.
 * @private
 */
bool getConsoleSettingsLocked();

/**
 * Returns the size of the console window in pixels.
 */
#ifndef SPL_HEADLESS_MODE
GDimension getConsoleSize();
#endif // SPL_HEADLESS_MODE

/**
 * Returns the width of the console window in pixels.
 */
double getConsoleWidth();

/**
 * Returns a pointer to the graphical console window,
 * which is a subclass of GWindow, so you can manipulate it as you would
 * any other window.
 *
 * @private
 */
#ifndef SPL_HEADLESS_MODE
GConsoleWindow* getConsoleWindow();
#endif // SPL_HEADLESS_MODE

/**
 * Returns the title bar text of the console window.
 */
std::string getConsoleWindowTitle();

/**
 * Initializes the state of the Qt graphical console, if it has not already
 * been initialized.
 * Clients should generally not call this method.
 * @private
 */
void initializeQtGraphicalConsole();

// defined in gwindow.h/cpp
extern void pause(double milliseconds);

/**
 * Returns whether the console's "clear" function should be enabled.
 * Default true.  If false, clear() will just print a message
 * rather than actually clearing the console.
 * This is sometimes used to facilitate creation of auto-grading scripts.
 * @private
 */
void setConsoleClearEnabled(bool value);

/**
 * Sets what the console should do when the user hits its "close" button.
 */
void setConsoleCloseOperation(/*GWindow::CloseOperation*/ int op);

/**
 * Enables or disables echoing the input/output from the Stanford graphical
 * console window onto the standard operating system terminal window.
 * Normally you don't need this echoing, but if you want to be able to copy
 * and paste your console interaction into another window, it is useful.
 */
void setConsoleEcho(bool echo);

/**
 * Sets the color used to display text in the console window.
 * The color string passed should be in a hex format such as "#ffa32f";
 * See gcolor.h for more detail about colors and color strings.
 */
void setConsoleErrorColor(const std::string& color);

/**
 * Sets whether an event should be generated if the console
 * window is closed.  By default this is false initially.
 * @private
 * @deprecated
 */
void setConsoleEventOnClose(bool eventOnClose);

/**
 * Sets whether the overall C++ program should terminate if the console
 * window is closed.  By default this is false initially.
 */
void setConsoleExitProgramOnClose(bool exitOnClose);

/**
 * Changes the font used for the console.  The <code>font</code> parameter
 * is typically a string in the form <code>family-style-size</code>.
 * In this string, <code>family</code> is the name of the font family;
 * <code>style</code> is either missing (indicating a plain font) or one
 * of the strings <code>Bold</code>, <code>Italic</code>, or
 * <code>BoldItalic</code>; and <code>size</code> is an integer
 * indicating the point size.  If any of these components is
 * specified as an asterisk, the existing value is retained.
 * The <code>font</code> parameter can also be a sequence of
 * such specifications separated by semicolons, in which case the
 * first available font on the system is used.
 * See gfont.h for more detail about font strings.
 */
void setConsoleFont(const std::string& font);

/**
 * Changes the (x, y) pixel position of the top-left corner of the console to
 * the specified coordinates, relative to the top/left of the screen.
 */
void setConsoleLocation(double x, double y);

/**
 * Sets whether the location of the console window should be remembered and
 * restored between runs of the program.  Default false.
 */
void setConsoleLocationSaved(bool value);

/**
 * Sets the color used to display text in the console window.
 * The color string passed should be in a hex format such as "#ffa32f";
 * See gcolor.h for more detail about color strings.
 */
void setConsoleOutputColor(const std::string& color);

/**
 * Enables or disables a feature that causes exceptions to be echoed to the
 * Stanford graphical console window when they are thrown.
 * Disabled (false) by default.
 * Note that using this feature may make it harder to get a stack trace in the
 * debugger if you are debugging the cause of an exception.
 */
void setConsolePrintExceptions(bool printExceptions, bool force = false);

/**
 * If set to true, disables functions like setConsoleFont or setConsoleSize,
 * to facilitate autograder construction by negating any such calls in the
 * student's main program.  Initially false.
 * Clients should generally not call this method.
 * @private
 */
void setConsoleSettingsLocked(bool value);

/**
 * Changes the size of the console to the specified dimensions in pixels.
 */
void setConsoleSize(double width, double height);

/**
 * Changes the title bar text of the console window to the specified text.
 */
void setConsoleWindowTitle(const std::string& title);

/**
 * Closes the graphical console window and turns it off.
 */
void shutdownConsole();

#endif // _console_h


/*
 * console.h is weird in that a student's program must be able to #include it
 * and then magically receive the graphical console instead of the standard one;
 * but we want other lib files to be able to include console.h to get the
 * function prototypes without actually turning the graphical console on.
 * To achieve this, we have the __DONT_ENABLE_QT_GRAPHICAL_CONSOLE flag that lib
 * files can set right before #include'ing console.h.  If they do so, it will
 * declare the prototypes but not initialize the graphical console.
 */
#ifndef __DONT_ENABLE_QT_GRAPHICAL_CONSOLE

// signal that graphical console is in use (so it will be initialized)
#define SPL_GRAPHICAL_CONSOLE_IN_USE 1

extern void setConsoleEnabled(bool);

namespace stanfordcpplib {
namespace qtgui {

#ifndef QtConsoleInitializer_created
#define QtConsoleInitializer_created
/**
 * @private
 */
class QtConsoleInitializer_private {
public:
    /*
     * Code to initialize the library.
     * Implemented as a class constructor so that it will run during
     * static initialization phase, which happens before the student's
     * main function.
     */
    QtConsoleInitializer_private() {
        setConsoleEnabled(true);
    }
};

/**
 * @private
 */
static QtConsoleInitializer_private __qt_console_init;
#endif // QtConsoleInitializer_created

} // namespace qtgui
} // namespace stanfordcpplib

#endif // __DONT_ENABLE_QT_GRAPHICAL_CONSOLE

#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

/////////////////////// END code extracted from StanfordCPPLib/graphics/console.h ///////////////////////

#undef __DONT_ENABLE_GRAPHICAL_CONSOLE
/////////////////////// BEGIN code extracted from StanfordCPPLib/io/bitstream.h ///////////////////////
/*
 * File: bitstream.h
 * -----------------
 * This file defines the ibitstream and obitstream classes which are basically
 * same as the ordinary istream and ostream classes, but add the
 * functionality to read and write one bit at a time.
 *
 * The idea is that you can substitute an ibitstream in place of an
 * istream and use the same operations (get, fail, >>, etc.)
 * along with added member functions of readBit, rewind, and size.
 *
 * Similarly, the obitstream can be used in place of ofstream, and has
 * same operations (put, fail, <<, etc.) along with additional
 * member functions writeBit and size.
 *
 * There are two subclasses of ibitstream: ifbitstream and istringbitstream,
 * which are similar to the ifstream and istringstream classes.  The
 * obitstream class similarly has ofbitstream and ostringbitstream as
 * subclasses.
 *
 * @author Keith Schwarz, Eric Roberts, Marty Stepp
 * @version 2019/04/20
 * - added toPrintable(string)
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2016/11/12
 * - made toPrintable non-static and visible
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _bitstream_h
#define _bitstream_h

#include <istream>
#include <ostream>
#include <fstream>
#include <sstream>

/**
 * Constant: PSEUDO_EOF
 * A constant representing the PSEUDO_EOF marker that you will
 * write at the end of your Huffman-encoded file.
 */
const int PSEUDO_EOF = 256;

/**
 * Constant: NOT_A_CHAR
 * A constant representing an extended character that does not
 * actually hold a value.  When you are constructing your Huffman
 * encoding tree, you should set the characters in each internal
 * node (non-leaf) to this value to explicitly mark that they are not
 * being used.
 */
const int NOT_A_CHAR = 257;

/**
 * Defines a class for reading files with all the functionality of istream
 * along with an added member function for reading a single bit and convenience
 * functions for rewinding the stream back to the beginning and getting the stream
 * size.
 *
 * You will probably not create instances of this class directly.  Instead, you
 * will create ifbitstreams or istringbitstreams to read from files or string buffers.
 */
class ibitstream: public std::istream {
public:
    /**
     * Initializes a new ibitstream that is not attached to any source.  You are
     * unlikely to use this function directly.
     */
    ibitstream();

    /**
     * Reads a single bit from the ibitstream and returns 0 or 1 depending on
     * the bit value.  If the stream is exhausted, EOF (-1) is returned.
     * Raises an error if this ibitstream has not been properly opened.
     */
    int readBit();

    /**
     * Rewinds the ibitstream back to the beginning so that subsequent reads
     * start again from the beginning.  Raises an error if this ibitstream
     * has not been properly opened.
     */
    void rewind();
    
    /**
     * Sets 'fake' mode, where it actually reads bytes when you say readBit.
     */
    void setFake(bool fake);

    /**
     * Returns the size in bytes of the data attached to this stream.
     * Raises an error if this ibitstream has not been properly opened.
     */
    long size();

    /**
     * Returns whether or not this ibitstream is opened.  This only has
     * meaning if the ibitstream is a file stream; otherwise it always
     * returns true.
     */
    virtual bool is_open();

private:
    std::streampos lastTell;
    int curByte;
    int pos;
    bool fake;
};


/**
 * Defines a class for writing files with all the functionality of ostream
 * along with an added member function for writing a single bit and a convenience
 * function for getting the stream size.
 *
 * You are unlikely to instantiate this class directly; instead, instantiate one
 * of the subclasses.
 */
class obitstream: public std::ostream {
public:
    /**
     * Initializes a new obitstream that is not attached to any file.  Use the
     * open member function from ofstream to attach the stream to a file.
     */
    obitstream();

    /**
     * Writes a single bit to the obitstream.
     * Raises an error if this obitstream has not been properly opened.
     */
    void writeBit(int bit);

    /**
     * Returns the size in bytes of the file attached to this stream.
     * Raises an error if this obitstream has not been properly opened.
     */
    long size();

    /**
     * Sets 'fake' mode, where it actually writes bytes when you say writeBit.
     */
    void setFake(bool fake);
    
    /**
     * Returns whether or not this obitstream is opened.  This only has
     * meaning if the obitstream is a file stream; otherwise it always
     * returns true.
     */
    virtual bool is_open();

private:
    std::streampos lastTell;
    int curByte;
    int pos;
    bool fake;
};

/**
 * A class for reading files in all of the usual ways, plus bit-by-bit.
 * You can treat this class like a normal ifstream, except that there is
 * extra support for bit-level operations.
 */
class ifbitstream: public ibitstream {
public:
    /**
     * Constructs a new ifbitstream not attached to any file.  You can
     * open a file for reading using the .open() member functions.
     */
    ifbitstream();

    /**
     * Constructs a new ifbitstream that reads the file with the given name,
     * if it exists.  If not, the stream enters an error state.
     */
    ifbitstream(const char* filename);

    /**
     * Constructs a new ifbitstream that reads the specified file, if
     * it exists.  If not, the stream enters an error state.
     */
    ifbitstream(const std::string& filename);

    /**
     * Opens the specified file for reading.  If an error occurs, the
     * stream enters a failure state, which can be detected by calling
     * ifb.fail().
     */
    void open(const char* filename);

    /**
     * Opens the specified file for reading.  If an error occurs, the
     * stream enters a failure state, which can be detected by calling
     * ifb.fail().
     */
    void open(const std::string& filename);

    /**
     * Returns whether or not this ifbitstream is connected to a file for
     * reading.
     */
    bool is_open();

    /**
     * Closes the currently-opened file, if the stream is open.  If the
     * stream is not open, puts the stream into a fail state.
     */
    void close();

private:
    // the actual file buffer which does reading and writing.
    std::filebuf fb;
};

/**
 * A class for writing files in all of the usual ways, plus bit-by-bit.
 * You can treat this class like a normal ofstream, except that there is
 * extra support for bit-level operations.
 *
 * As a safety feature, you cannot use ofbitstream to open files that end
 * in .h, .hh, .cpp, or .cc for writing, as this could very easily cause
 * you to destroy your source files.
 */
class ofbitstream: public obitstream {
public:
    /**
     * Constructs a new ofbitstream not attached to any file.  You can
     * open a file for writing using the .open() member functions.
     */
    ofbitstream();

    /**
     * Constructs a new ofbitstream that writes the specified file, if
     * it exists.  If not, the stream enters an error state.  Read
     * the documentation on "open" for more details.
     */
    ofbitstream(const char* filename);

    /**
     * Constructs a new ofbitstream that writes the specified file, if
     * it exists.  If not, the stream enters an error state.  Read
     * the documentation on "open" for more details.
     */
    ofbitstream(const std::string& filename);

    /**
     * Opens the specified file for writing.  If an error occurs, the
     * stream enters a failure state, which can be detected by calling
     * ifb.fail().  If an invalid filename is specified (for example,
     * a source file), reports an error.
     */
    void open(const char* filename);

    /**
     * Opens the specified file for writing.  If an error occurs, the
     * stream enters a failure state, which can be detected by calling
     * ifb.fail().  If an invalid filename is specified (for example,
     * a source file), reports an error.
     */
    void open(const std::string& filename);

    /**
     * Returns whether or not this ofbitstream is connected to a file for
     * reading.
     */
    bool is_open();

    /**
     * Closes the currently-opened file, if the stream is open.  If the
     * stream is not open, puts the stream into a fail state.
     */
    void close();

private:
    // the actual file buffer which does reading and writing.
    std::filebuf fb;
};

/**
 * A variant on C++'s istringstream class, which acts as a stream that
 * reads its data from a string.  This is mostly used by the testing
 * code to test your Huffman encoding without having to read or write
 * files on disk, but you can use it in your own testing if you would
 * like.
 */
class istringbitstream: public ibitstream {
public:
    /**
     * Constructs an istringbitstream reading the specified string.
     */
    istringbitstream(const std::string& s = "");

    /**
     * Sets the underlying string of the istringbitstream.
     */
    void str(const std::string& s);
private:
    // the actual string buffer that does character storage
    std::stringbuf sb;
};

/**
 * A variant on C++'s ostringstream class, which acts as a stream that
 * writes its data to a string.  This is mostly used by the testing
 * code to test your Huffman encoding without having to read or write
 * files on disk, but you can use it in your own testing if you would
 * like.
 */
class ostringbitstream: public obitstream {
public:
    /**
     * Constructs an ostringbitstream.
     */
    ostringbitstream();

    /**
     * Retrieves the underlying string of the istringbitstream.
     */
    std::string str();

private:
    // the actual string buffer that does character storage
    std::stringbuf sb;
};

/**
 * Returns a printable string for the given character.
 * @example toPrintable('c') returns "c"
 * @example toPrintable('\n') returns "\\n"
 */
std::string toPrintable(int ch);

/**
 * Returns a string with each non-printable character in the given string
 * replaced by one that is printable.
 * Certain common escape characters are replaced by a backslash representation,
 * and non-printable ASCII characters are replaced by a backslash and their
 * ASCII numeric representation, such as \255.
 * @example toPrintable("hi \0 there\n') returns "hi \\0 there\\n"
 */
std::string toPrintable(const std::string& s);

#endif // _bitstream_h

/////////////////////// END code extracted from StanfordCPPLib/io/bitstream.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/io/plainconsole.h ///////////////////////
/*
 * File: plainconsole.h
 * --------------------
 * This file declares functions to add utility to the
 * C++ plain text console streams, cin/cout/cerr.
 * See plainconsole.cpp for implementation of each function.
 *
 * @author Marty Stepp
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2015/10/21
 * @since 2015/10/21
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _plainconsole_h
#define _plainconsole_h

namespace plainconsole {
/**
 * Sets the cout console to throw an error if more than the given number of
 * total characters are ever printed to it.
 * This can be used to stop student programs that try to print infinite output.
 */
void setOutputLimit(int limit);

/**
 * Sets whether user input values read from cin are echoed back to cout.
 * This is useful when capturing output dialogues for comparison/diffing.
 */
void setEcho(bool value);
} // namespace plainconsole

#endif // _plainconsole_h

/////////////////////// END code extracted from StanfordCPPLib/io/plainconsole.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/complex.h ///////////////////////
/*
 * File: complex.h
 * ---------------
 * This file exports a type representing complex numbers.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/10/18
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _complex_h
#define _complex_h

#include <iostream>
#include <string>

/**
 * A Complex object represents a complex number of the form a + bi.
 */
class Complex {
public:
    /**
     * Constructs a new imaginary number: (a + b * i).
     */
    Complex(double a = 0.0, double b = 0.0);

    /**
     * Returns the absolute value of the complex number.
     */
    double abs() const;

    /**
     * Returns the imaginary value of the complex number.
     */
    double imag() const;

    /**
     * Returns the real value of the complex number.
     */
    double real() const;

    /**
     * Returns a string representation of this complex number,
     * such as "4+3i" or "-2-4i" or "0".
     */
    std::string toString() const;

    /**
     * Adds two complex numbers and returns
     * the result as a new complex number.
     */
    friend Complex operator +(const Complex& m, const Complex& n);

    /**
     * Subtracts two complex numbers and returns
     * the result as a new complex number.
     */
    friend Complex operator -(const Complex& m, const Complex& n);

    /**
     * Multiplies two complex numbers and returns
     * the result as a new complex number.
     */
    friend Complex operator *(const Complex& m, const Complex& n);

    friend std::istream& operator >>(std::istream& out, Complex& c);

private:
    double a;   // real value
    double b;   // imag value
};

/**
 * Returns an integer hash code for complex numbers so that they
 * can be stored in HashSet and HashMap collections.
 */
int hashCode(const Complex& c);

/**
 * These relational operators define a total ordering for complex numbers.
 * Mathematically this is not well-defined, but we provide this simply so
 * that Complex objects can be stored in a Set or Map collection.
 */
bool operator <(const Complex& c1, const Complex& c2);
bool operator <=(const Complex& c1, const Complex& c2);
bool operator >(const Complex& c1, const Complex& c2);
bool operator >=(const Complex& c1, const Complex& c2);
bool operator ==(const Complex& c1, const Complex& c2);
bool operator !=(const Complex& c1, const Complex& c2);

/**
 * Writes the complex number to an output stream.
 */
std::ostream& operator <<(std::ostream& out, const Complex& c);

/**
 * Reads a complex number from an output stream.
 */
std::istream& operator >>(std::istream& input, Complex& c);

#endif // _complex_h

/////////////////////// END code extracted from StanfordCPPLib/util/complex.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/biginteger.h ///////////////////////
/*
 * File: biginteger.h
 * ------------------
 * This file exports a class for arbitrary-size integer arithmetic.
 * It is meant to help get around the max/min value limit for types
 * such as int and long.
 *
 * In general, a BigInteger supports the standard operators and operations
 * that you would expect to be able to use on an int or long value.
 *
 * Example usage:
 *
 * BigInteger bi("1234567890123456789");
 * for (int i = 0; i < 10; i++) {
 *     bi *= 12345678;
 * }
 * cout << "really big number is: " << bi << endl;
 *
 * Implementation notes:
 * This code is heavily based on a BigInteger library taken from:
 * https://github.com/panks/BigInteger
 *
 * The implementation stores the big integer as a string of base-10 digits
 * along with a sign bit represented as a bool.
 * In general the operations are not heavily optimized; this class should not
 * be used in situations where performance is critical.
 * Note that better Big Integer libraries exist in other places for more
 * serious work and can be found using your favorite search engine.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2017/10/28
 * - initial version
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _biginteger_h
#define _biginteger_h

#include <iostream>
#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

class BigInteger {
public:
    /**
     * Constants to represent very commonly used big integer values
     */
    static const BigInteger NEGATIVE_ONE;
    static const BigInteger ZERO;
    static const BigInteger ONE;
    static const BigInteger TWO;
    static const BigInteger TEN;
    static const BigInteger MAX_INT;
    static const BigInteger MIN_INT;
    static const BigInteger MAX_UINT;
    static const BigInteger MAX_LONG;
    static const BigInteger MIN_LONG;
    static const BigInteger MAX_ULONG;
    static const BigInteger MAX_SHORT;
    static const BigInteger MIN_SHORT;
    static const BigInteger MAX_USHORT;

    /**
     * Constructs a new big integer set to zero.
     *
     * @example BigInteger bi;
     */
    BigInteger();

    /**
     * Constructs a new big integer whose value is a copy of another big integer.
     *
     * @example BigInteger bi1(bi2);
     */
    BigInteger(const BigInteger& other);

    /**
     * Constructs a new big integer set to the given value.
     *
     * @example BigInteger bi("1234567890123456789");
     */
    BigInteger(const std::string& s, int radix = 10);

    /**
     * Constructs a new big integer set to the given value.
     *
     * @example BigInteger bi(12345);
     * @example BigInteger bi2(-42);
     */
    BigInteger(long n);

    /**
     * Returns a new BigInteger whose value is the absolute value of this one.
     */
    BigInteger abs() const;

    /**
     * Returns the greatest common divisor of this and the given other big integer.
     * For example, gcd(24, 16) is 8.
     */
    BigInteger gcd(const BigInteger& other) const;

    /**
     * Returns true if this BigInteger's value is within the range of values
     * that can be stored as an int.
     */
    bool isInt() const;

    /**
     * Returns true if this BigInteger's value is within the range of values
     * that can be stored as a long.
     */
    bool isLong() const;

    /**
     * Returns true if this BigInteger represents a negative number < 0.
     * You could just perform the check yourself by testing whether number > 0,
     * but this member is faster because it doesn't need to create a temporary
     * BigInteger instance for doing the comparison.
     */
    bool isNegative() const;

    /**
     * Returns true if this BigInteger represents a non-negative number >= 0.
     * You could just perform the check yourself by testing whether number > 0,
     * but this member is faster because it doesn't need to create a temporary
     * BigInteger instance for doing the comparison.
     */
    bool isNonNegative() const;

    /**
     * Returns true if this BigInteger represents a positive number > 0.
     * You could just perform the check yourself by testing whether number > 0,
     * but this member is faster because it doesn't need to create a temporary
     * BigInteger instance for doing the comparison.
     */
    bool isPositive() const;

    /**
     * Returns whichever is larger between this big integer and the given
     * other big integer.
     */
    const BigInteger& max(const BigInteger& other) const;

    /**
     * Returns whichever is smaller between this big integer and the given
     * other big integer.
     */
    const BigInteger& min(const BigInteger& other) const;

    /**
     * Returns a new BigInteger whose value is (this ^^ exp) % m.
     * @throw ErrorException if exp is negative or if m is 0.
     */
    BigInteger modPow(const BigInteger& exp, const BigInteger& m) const;

    /**
     * Returns a new BigInteger whose value is the value of this BigInteger
     * raised to the given exponent.
     * @throw ErrorException if the exponent is negative.
     */
    BigInteger pow(long exp) const;

    /**
     * Returns a new BigInteger whose value is the value of this BigInteger
     * raised to the given exponent.
     * @throw ErrorException if the exponent is negative.
     */
    BigInteger pow(const BigInteger& exp) const;

    /**
     * Returns an int representation of this BigInteger, such as
     * -12345678.
     * @throw ErrorException if this BigInteger is out of the range of int.
     */
    int toInt() const;

    /**
     * Returns a long representation of this BigInteger, such as
     * -123456789.
     * @throw ErrorException if this BigInteger is out of the range of long.
     */
    long toLong() const;

    /**
     * Returns a string representation of this BigInteger, such as
     * "-1234567890123456789".
     */
    std::string toString(int radix = 10) const;

    /**
     * Increases the value of this BigInteger by 1 (prefix).
     */
    BigInteger& operator ++(); // prefix

    /**
     * Increases the value of this BigInteger by 1 (posfix).
     */
    BigInteger  operator ++(int); // postfix

    /**
     * Decreases the value of this BigInteger by 1 (prefix).
     */
    BigInteger& operator --(); // prefix

    /**
     * Decreases the value of this BigInteger by 1 (postfix).
     */
    BigInteger  operator --(int); // postfix

    /**
     * Assigns this BigInteger to store the sum of itself
     * and the given other BigInteger.
     */
    BigInteger& operator +=(const BigInteger& b);

    /**
     * Assigns this BigInteger to store the result of subtracting
     * the given other BigInteger from this BigInteger.
     */
    BigInteger& operator -=(const BigInteger& b);

    /**
     * Assigns this BigInteger to store the product of itself
     * and the given other BigInteger.
     */
    BigInteger& operator *=(const BigInteger& b);

    /**
     * Assigns this BigInteger to store the quotient of dividing
     * itself by the given other BigInteger.
     * @throw ErrorException if denominator is 0.
     * @throw ErrorException if denominator is not within the range of type long.
     */
    BigInteger& operator /=(const BigInteger& b);

    /**
     * Assigns this BigInteger to store the remainder of dividing
     * itself by the given other BigInteger.
     * @throw ErrorException if denominator is 0.
     * @throw ErrorException if denominator is not within the range of type long.
     */
    BigInteger& operator %=(const BigInteger& b);

    /**
     * Sets this big integer to a bitwise AND between this integer and the given other integer,
     * retaining only bits that are set in both.
     */
    BigInteger& operator &=(const BigInteger& b);

    /**
     * Sets this big integer to a bitwise OR between this integer and the given other integer,
     * retaining bits that are set in this integer or the other integer or both.
     */
    BigInteger& operator |=(const BigInteger& b);

    /**
     * Sets this big integer to a bitwise XOR between this integer and the given other integer,
     * retaining bits that are set in this integer or the other integer but not both.
     */
    BigInteger& operator ^=(const BigInteger& b);

    /**
     * Performs a bitwise NOT on this integer,
     * inverting the values of all of its bits.
     */
    BigInteger operator ~() const;

    /**
     * Performs a logical NOT on this integer,
     * setting it to 0 if non-zero, or to 1 if zero.
     */
    BigInteger operator !() const;

    /**
     * Sets this BigInteger to store the same value as the given other big integer.
     */
    BigInteger& operator =(const BigInteger& other);

    /**
     * Unary negation; returns a new BigInteger that is
     * the negative of this BigInteger.
     */
    BigInteger operator -() const;

    /**
     * Returns a new big integer whose value is equal to the value of
     * this big integer bit-shifted left by the given number of bits.
     * Equivalent to multiplying by 2 ^ shift.
     */
    BigInteger operator <<(unsigned int shift) const;

    /**
     * Modifies this big integer to be bit-shifted left by the given number of bits.
     * Equivalent to multiplying by 2 ^ shift.
     */
    BigInteger& operator <<=(unsigned int shift);

    /**
     * Returns a new big integer whose value is equal to the value of
     * this big integer bit-shifted right by the given number of bits.
     * Equivalent to dividing by 2 ^ shift.
     */
    BigInteger operator >>(unsigned int shift) const;

    /**
     * Modifies this big integer to be bit-shifted right by the given number of bits.
     * Equivalent to dividing by 2 ^ shift.
     */
    BigInteger& operator >>=(unsigned int shift);

    /**
     * Converts this BigInteger into a boolean value.
     * The value will be false if this BigInteger stores 0, or true otherwise.
     */
    explicit operator bool() const;

    /**
     * Converts this BigInteger into a double.
     * @throw ErrorException if this big integer is not within the range of type long.
     */
    // explicit operator double() const;

    /**
     * Converts this BigInteger into a float.
     * @throw ErrorException if this big integer is not within the range of type long.
     */
    // explicit operator float() const;

    /**
     * Converts this BigInteger into an integer.
     * @throw ErrorException if this big integer is not within the range of type int.
     */
    explicit operator int() const;

    /**
     * Converts this BigInteger into a long.
     * @throw ErrorException if this big integer is not within the range of type long.
     */
    explicit operator long() const;

    /**
     * Converts this BigInteger into a string.
     */
    explicit operator std::string() const;

private:
    /*
     * Constructs a new big integer set to the given value,
     * with optional sign (true=negative, false=positive).
     *
     * Example:
     * BigInteger bi("1234567890123456789", true);   // negative
     */
    BigInteger(const std::string& s, bool sin); // "string" constructor

    // add two big integers as string and return result; used by operator +
    static std::string add(const std::string& number1, const std::string& number2);

    // checks that the given string is in the proper format that it could be
    // interpreted as an integer in the given base; if not, issues an error()
    static void checkStringIsNumeric(const std::string& s, int radix = 10);

    // TODO: make work for big integer division
    // divide n by den and return result; used by operator /
    static std::pair<std::string, long> divide(const std::string& n, long den);
    static std::pair<BigInteger, BigInteger> divideBig(const BigInteger& numer, const BigInteger& denom);

    // return true if two BigIntegers are equal; used by operator ==
    static bool equals(const BigInteger& n1, const BigInteger& n2);

    // checks for -0 case and changes to 0
    void fixNegativeZero();

    /*
     * Returns the number stored by this BigInteger as a string.
     * If this BigInteger represents a negative number, the sign will be omitted.
     * Example: "1234567890123456789"
     */
    const std::string& getNumber() const; // retrieves the number

    /*
     * Returns the sign of this BigInteger; true if negative, false if not.
     */
    bool getSign() const;

    // return true if n1 > n2; used by operator >
    static bool greater(const BigInteger& n1, const BigInteger& n2);

    // return true if n1 < n2; used by operator <
    static bool less(const BigInteger& n1, const BigInteger& n2);

    // multiply two big integers as string and return result; used by operator *
    static std::string multiply(const std::string& n1, const std::string& n2);

    // removes leading 0s except one from given number
    static std::string removeLeadingZeros(const std::string& s);

    /*
     * Sets the number and the sign stored by this BigInteger.
     */
    void setValue(const std::string& s, int radix = 10);

    /*
     * Sets the number stored by this BigInteger.
     */
    void setNumber(const std::string& s, int radix = 10);

    /*
     * Sets the sign stored by this BigInteger.
     * The value true means negative; false means positive.
     */
    void setSign(bool s);

    // e.g. "0xfff" => "fff"
    static std::string stripNumberPrefix(const std::string& num, int radix = 10);

    // subtract num2 from num1 as string and return result; used by operator -
    static std::string subtract(const std::string& number1, const std::string& number2);

    // convert a string value into a long
    static long toLong(const std::string& s);

    // convert a long value to a string
    static std::string toString(long n);

    // TODO: remove?
    BigInteger& operator [](int n);

    friend int hashCode(const BigInteger& b);
    friend BigInteger operator +(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator -(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator *(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator /(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator %(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator &(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator |(const BigInteger& b1, const BigInteger& b2);
    friend BigInteger operator ^(const BigInteger& b1, const BigInteger& b2);
    friend bool operator ==(const BigInteger& b1, const BigInteger& b2);
    friend bool operator !=(const BigInteger& b1, const BigInteger& b2);
    friend bool operator >(const BigInteger& b1, const BigInteger& b2);
    friend bool operator <(const BigInteger& b1, const BigInteger& b2);
    friend bool operator >=(const BigInteger& b1, const BigInteger& b2);
    friend bool operator <=(const BigInteger& b1, const BigInteger& b2);
    friend std::istream& operator >>(std::istream& input, BigInteger& b);
    friend std::ostream& operator <<(std::ostream& out, const BigInteger& b);

    // member variables
    std::string number;   // string representation of this big integer in base-10, e.g. "1234567890123456789"
    bool sign;            // true if number is negative
};

/**
 * Returns a string representation of the given big integer.
 * Equivalent to calling bi.toString().
 * Provided for consistency with the other lib functions like integerToString.
 */
std::string bigIntegerToString(const BigInteger& bi, int radix = 10);

/**
 * Returns an integer hash code for the given BigInteger.
 */
int hashCode(const BigInteger& b);

/**
 * Returns a new BigInteger that is the sum of this BigInteger
 * and the given other BigInteger.
 */
BigInteger operator +(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns a new BigInteger that is the result of subtracting
 * the given other BigInteger from this BigInteger.
 */
BigInteger operator -(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns a new BigInteger that is the product of this BigInteger
 * and the given other BigInteger.
 */
BigInteger operator *(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns a new BigInteger that is the quotient of dividing
 * this BigInteger by the given other BigInteger.
 * @throw ErrorException if denominator is 0.
 * @throw ErrorException if denominator is not within the range of type long.
 */
BigInteger operator /(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns a new BigInteger that is the remainder of dividing
 * this BigInteger by the given other BigInteger.
 * @throw ErrorException if denominator is 0.
 * @throw ErrorException if denominator is not within the range of type long.
 */
BigInteger operator %(const BigInteger& b1, const BigInteger& b2);

/**
 * Performs a bitwise AND between this integer and the given other integer,
 * retaining only bits that are set in both.
 */
BigInteger operator &(const BigInteger& b1, const BigInteger& b2);

/**
 * Performs a bitwise OR between this integer and the given other integer,
 * retaining bits that are set in this integer or the other integer or both.
 */
BigInteger operator |(const BigInteger& b1, const BigInteger& b2);

/**
 * Performs a bitwise XOR between this integer and the given other integer,
 * retaining bits that are set in this integer or the other integer but not both.
 */
BigInteger operator ^(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if two BigIntegers store the same value.
 */
bool operator ==(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if two BigIntegers do not store the same value.
 */
bool operator !=(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if this BigInteger stores a larger value than the given other one.
 */
bool operator >(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if this BigInteger stores a smaller value than the given other one.
 */
bool operator <(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if this BigInteger stores a value that is
 * greater than or equal to the given other one.
 */
bool operator >=(const BigInteger& b1, const BigInteger& b2);

/**
 * Returns true if this BigInteger stores a value that is
 * less than or equal to the given other one.
 */
bool operator <=(const BigInteger& b1, const BigInteger& b2);

/**
 * Reads a BigInteger from the given input stream.
 */
std::istream& operator >>(std::istream& input, BigInteger& b);

/**
 * Writes this BigInteger to the given output stream.
 */
std::ostream& operator <<(std::ostream& out, const BigInteger& b);

/*
 * Free-standing arithmetic operators between int/long and BigInteger.
 * (Commenting these out because when present they seem to also match double,
 * producing bad results.)
 */
//BigInteger operator +(long n, const BigInteger& b);
//BigInteger operator -(long n, const BigInteger& b);
//BigInteger operator *(long n, const BigInteger& b);
//BigInteger operator /(long n, const BigInteger& b);
//BigInteger operator %(long n, const BigInteger& b);

// aliases for BigInteger for those who like abbreviations and lowercase
typedef BigInteger BigInt;
typedef BigInteger bigint;

#endif // _biginteger_h

/////////////////////// END code extracted from StanfordCPPLib/util/biginteger.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/bigfloat.h ///////////////////////
///// BEGIN BASE.H
//#pragma once

//#ifndef INTERNAL_INCLUDE
//
//#endif // INTERNAL_INCLUDE

//#include <stddef.h>
//#include <stdio.h>
//#include <stdarg.h>
//#include <vector>
//#include <map>
//#include <stdexcept>
//#include <string>
//#include <sstream>

//#ifdef _MSC_VER
//# define INLINE __forceinline
//  typedef  unsigned __int64 u8;
//  typedef  unsigned __int32 u4;
//  typedef  unsigned __int16 u2;
//  typedef  unsigned __int8  u1;
//  typedef  __int64 s8;
//  typedef  __int32 s4;
//  typedef  __int16 s2;
//  typedef  __int8  s1;
//#else
//# include <stdint.h>
//# define INLINE inline
//  typedef  uint64_t  u8;
//  typedef  uint32_t  u4;
//  typedef  uint16_t  u2;
//  typedef  uint8_t   u1;
//  typedef  int64_t  s8;
//  typedef  int32_t  s4;
//  typedef  int16_t  s2;
//  typedef  int8_t   s1;
//#endif

//class CosmosException : public std::exception
//{
//public:
//    CosmosException(const char* m) : _msg(m) {}
//    CosmosException(const std::string& m) : _msg(m) {}
//    virtual ~CosmosException() throw() {}
//    virtual const char* what() const throw()
//    {
//        return _msg.c_str();
//    }
//protected:
//    std::string _msg;
//};

/*#define ASSERT(condition, ...) do { \
  if (!(condition)) Assert(__LINE__, __FILE__, #condition, ##__VA_ARGS__); \
} while(0) */

/*#define ASSERTFG(f,g) do { \
  double fr = (f); double gr = (g); double diff = (fr-gr); \
  if (diff > 1.0e-10 || diff < -1.0e-10) \
  Assert(__LINE__, __FILE__, #f "," #g, "%f, %f, %f", fr, gr, diff); \
} while(0) */

//static void Assert(
//    int line,
//    const char* filename,
//    const char* condition)
//{
//	static const int bufSize = 4000;
//    char y[bufSize];
//    sprintf(y, "line=[%d], file=[%s], condition=[%s]",
//            line, filename, condition);
//    throw CosmosException(y);
//}

//static void Assert(
//    int line,
//    const char* filename,
//    const char* condition,
//    const char* fmt,
//    ...)
//{
//	static const int bufSize = 4000;
//    char x[bufSize];
//    char y[bufSize];
//    va_list args;
//    va_start(args, fmt);
//    vsprintf(x, fmt, args);
//    va_end(args);
//    sprintf(y, "line=[%d], file=[%s], condition=[%s], %s",
//            line, filename, condition, x);
//    throw CosmosException(y);
//}

///// END BASE.H






////#pragma once
////


//// This is not fast, but it has good accuracy.
//// I need this because orbital problems have a lot of nth-degree
//// polynomial approximations, and the coefficients of those polynomial
//// approximations are things like 48471792742212/237758976000.  The only
//// way to get the definitions of coefficients right is to do Gaussian
//// elimination on at least n equations with n unknowns, and a precision
//// about twice as great as the coefficients I want to end up with,
//// followed by continued fractions on the result to find the proper
//// fractional representation.
//class BigFloat
//{
//public:
//    BigFloat() { Zero(); }
//    BigFloat(const BigFloat& n) { Copy(n); }
//    BigFloat(s8 n) { FromInteger(n); }
//    BigFloat(s8 n, s8 exponent) { FromInteger(n, exponent); }
//    ~BigFloat() {}

//    // translation
//    BigFloat& FromInteger(s8 num, s8 exponent=0);
//    s8 ToInteger() const;  // it will truncate, but not overflow
//    static s8 RoundInteger(s8 value);  // round an s8 to right precision
//    double ToDouble() const;
//    bool IsNegative() const { return _isNegative; }
//    s8 ToExponent() const { return _exponent; }
//    u8 ToDigits() const;  // return digits filling an integer
//    void ToFraction(BigFloat& num, BigFloat& denom, int iter=1024) const;
//    void Print() const;
//    void PrintHex() const;
//    void PrintContinuedFraction() const;
//    void PrintDouble() const;

//    // arithmetic
//    BigFloat& PZero()
//    {
//        _exponent = c_zeroExponent;
//        _length = 0;
//        _isNegative = false;
//        return *this;
//    }
//    BigFloat& NZero()
//    {
//        _exponent = c_zeroExponent;
//        _length = 0;
//        _isNegative = true;
//        return *this;
//    }
//    BigFloat& Zero( bool neg = false) { return neg ? NZero() : PZero(); }
//    BigFloat& PInf()
//    {
//        _exponent = c_zeroExponent;
//        _length = 1;
//        _isNegative = false;
//        return *this;
//    }
//    BigFloat& NInf()
//    {
//        _exponent = c_zeroExponent;
//        _length = 1;
//        _isNegative = true;
//        return *this;
//    }
//    BigFloat& Inf( bool negative = false) { return negative ? NInf() : PInf(); }
//    BigFloat& NaN()
//    {
//        _exponent = c_zeroExponent;
//        _length = 2;
//        _isNegative = false;
//        return *this;
//    }

//    BigFloat& Copy(const BigFloat& n);
//    BigFloat& Negate();

//    // round to c_digits digits
//    //   carry=true: there should be an additional top digit of 1
//    //   previousDigit: what _d[c_digits] would have been, or 0
//    BigFloat& Round(bool carry, s8 previousDigit);
//    BigFloat& Round(u8 previousDigit);

//    // truncate to the nearest integer, towards zero
//    BigFloat& Trunc();

//    // -1 if |this|<|n|, 0 if |this|==|n|, 1 if |this|>|n|
//    int CompareAbsolute(const BigFloat& n) const;


//    // -1 if this<n, 0 if this==n, 1 if this>n
//    int Compare(const BigFloat& n) const;

//    bool IsZero() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 0;
//    }
//    bool IsPZero() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 0 &&
//            _isNegative == false;
//    }
//    bool IsNZero() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 0 &&
//            _isNegative == true;
//    }
//    bool IsInf() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 1;
//    }
//    bool IsPInf() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 1 &&
//            _isNegative == false;
//    }
//    bool IsNInf() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 1 &&
//            _isNegative == true;
//    }
//    bool IsNaN() const
//    {
//        return
//            _exponent == c_zeroExponent &&
//            _length == 2;
//    }
//    bool IsSpecial() const
//    {
//        return _exponent == c_zeroExponent;
//    }

//    BigFloat& Add(const BigFloat& n) { return AddOrSubtract(n, false); }
//    BigFloat& Sub(const BigFloat& n) { return AddOrSubtract(n, true); }
//    BigFloat& Mult(const BigFloat& n); // x => x*n
//    BigFloat& Div(const BigFloat& n); // x => x/n
//    BigFloat& Invert(); // x => 1/x
//    BigFloat& Sqrt(); // x => positive square root of x
//    BigFloat& Cos(); // x => cosine of x (x in radians)
//    BigFloat& Sin(); // x => sine of x (x in radians)
//    BigFloat& Sec(); // x => secant of x (x in radians)
//    BigFloat& Csc(); // x => cosecant of x (x in radians)
//    BigFloat& Tan(); // x => tangent of x (x in radians)
//    BigFloat& Exp(); // x => e to the xth power
//    BigFloat& ASin(); // x => arcsin of x (-1 => -pi/2, 1 => pi/2)
//    BigFloat& ACos(); // x => arccos of x (-1 => pi, 1 => 0)
//    BigFloat& ATan(); // x => arctan of x (-inf => -pi/2, inf => pi/2)
//    BigFloat& Ln();  // replaces x with the natural log of x
//    BigFloat& Log(const BigFloat& n);  // x => natural log of n base x
//    BigFloat& Power(const BigFloat& n); // replaces x with x to the nth
//    BigFloat& Rand(); // not impl: uniformly distributed value in [0,1)
//    BigFloat& RandNorm(); // not impl: pseudorandom normally-distributed value

//    // constants
//    static const BigFloat& Pi();  // length of unit circle, 3.14159...
//    static const BigFloat& E();  // the natural base for exponents, 2.71828...
//    static const BigFloat& ConstZero();
//    static const BigFloat& ConstOne();
//    static const BigFloat& ConstMinusOne();

//    // variations where arguments are signed integers
//    int Compare(s8 n, s8 exponent=0);
//    BigFloat& Add(s8 n, s8 exponent=0);
//    BigFloat& Sub(s8 n, s8 exponent=0);
//    BigFloat& Mult(s8 n, s8 exponent=0);
//    BigFloat& Div(s8 n, s8 exponent=0);
//    BigFloat& Power(s8 n, s8 exponent=0);  // not implemented

//    // Given an m*(m+1) matrix of BigFloat where the last col means =const,
//    // solve, and fill m[i][m] with the value for the ith variable.
//    static void GaussianElimination(BigFloat** m, s8 rows, s8 cols);
    
//    // assure that it works as expected
//    static void UnitTest();
        
//private:
//    // First, this => this mod 2pi.
//    // Return the quadrant (int)(this / (pi/4)), value 0..7
//    // this => (this + pi/4) mod pi/2 (positive), - pi/4.
//    // That means a negative value for odd quadrants and positive for even.
//    s8 Quadrant();
//    BigFloat& PartialSin();  // sin, but only for -pi/4 to pi/4
//    BigFloat& PartialCos();  // cos, but only for -pi/4 to pi/4
    
//    // this+n, or this-n if minus==true
//    BigFloat& AddOrSubtract(const BigFloat& n, bool minus);

//    // test whether this is the right representation of this integer
//    static void TestInteger(const BigFloat& n, s8 x);

//    // test addition and subtraction of two integers
//    static void TestAdd(s8 x, s8 y);

//    // test multiplication of two numbers
//    static void TestMult(s8 x, s8 ex, s8 y, s8 ey);

//    // test inverse of one number
//    static void TestInverse(s8 x, s8 ex);

//    // test sqrt of one number
//    static void TestSqrt(s8 x, s8 ex);

//    // representation: c_digits digits, each with range 0..c_range-1
//    // _d[0] is the most significant digit
//#ifdef BIGFLOAT_TEST
//    static const s8 c_digits = 4;
//    static const s8 c_log = 2;
//    static const s8 c_zeroExponent = -(((s8)1) << 4);
//#else
//    static const s8 c_digits = 10;
//    static const s8 c_log = 32;

//    // -1<<63 is a signed value, but 1<<63 is not, so 1<<62 then
//    static const s8 c_zeroExponent = -(((s8)1) << 62);
//#endif
//    static const s8 c_minExponent = c_zeroExponent + c_digits;
//    static const s8 c_maxExponent =  -c_zeroExponent;
//    static const u8 c_range = (((u8)1)<<c_log);

//    s8 _exponent;
//    u4 _d[c_digits];
//    bool _isNegative;
//    u2 _length; // number of digits used
//};

//class BigFloatCache
//{
//public:
//    static bool _isInitialized;
//    static BigFloat _zero;
//    static BigFloat _e;
//    static BigFloat *_ePower; // [i] is e^^(2^^i), i in -6..ePowerLen-1
//    static BigFloat *_eInvPower; // [i] is e^^-(2^^i), i in -6..ePowerLen-1
//    static s8 _ePowerLen;
//    static const s8 _ePowerNeg = -7;
//    static BigFloat _pi;
//    static BigFloat _twoPi;
//    static BigFloat _overTwoPi;
//    static BigFloat _piOverTwo;
//    static BigFloat _threePiOverTwo;
//    static BigFloat _piOverFour;
//    static s8 _overFactLen;
//    static BigFloat* _overFact;

//    // fill in _pi, _e, and various cached arrays
//    static void Init();
//};

/////////////////////// END code extracted from StanfordCPPLib/util/bigfloat.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/private/version.h ///////////////////////
/*
 * File: version.h
 * ---------------
 * This file contains declarations of the version number of the
 * Stanford C++ library.
 *
 * @author Marty Stepp
 * @version 2019/10/12
 */

#ifndef _version_h
#define _version_h

#include <string>

/*
 * Current version of the Stanford C++ library.
 * NOTE: This value and the other date values here all
 *       *MUST* be zero-padded to YYYY/MM/DD format;
 *       if month or day is < 10, insert a preceding 0
 */
#define STANFORD_CPP_LIB_VERSION "2019/10/12"

/*
 * Minimum version of your IDE's project that is supported.
 * platform.cpp checks this and exits if project .pro is older than
 * this to avoid incompatible versions.
 *
 * NOTE: This value and the other date values here all
 *       *MUST* be zero-padded to YYYY/MM/DD format;
 *       if month or day is < 10, insert a preceding 0
 */
#define STANFORD_CPP_PROJECT_MINIMUM_VERSION "2019/04/22"

/*
 * URL at which documentation about the libraries can be found.
 */
#define STANFORD_CPP_LIB_DOCS_URL "http://stanford.edu/~stepp/cppdoc/"


namespace version {
void ensureJavaBackEndVersion(std::string minVersion = "") /* deprecated */;
void ensureProjectVersion(std::string minVersion = "");
std::string getCppLibraryDocsUrl();
std::string getCppLibraryVersion();
std::string getJavaBackEndVersion() /* deprecated */;
std::string getProjectVersion();
} // namespace version

#endif // _version_h

/////////////////////// END code extracted from StanfordCPPLib/private/version.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/regexpr.h ///////////////////////
/*
 * File: regexpr.h
 * ---------------
 * This file exports functions for performing regular expression operations
 * on C++ strings.  It will be unnecessary once the C++11 regex library
 * is widely available, but as of this writing the regex library is not
 * supported on gcc and other major C++ compilers.
 * 
 * The regular expression functions are implemented by sending the strings and
 * regexes to the Java Back-End to run the operations in Java.  This is a bit
 * kludgy but we don't want to write our own regex parser from scratch.
 * Using Java's is a compromise for now.
 *
 * @author Marty Stepp
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 * @version 2018/09/20
 * - added Qt version checking around some regex functions for compatibility
 * @version 2014/10/14
 * - removed regexMatchCountWithLines for simplicity
 * @since 2014/03/01
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _regexpr_h
#define _regexpr_h

#include <string>

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

/**
 * Returns true if the given string s matches the given regular expression
 * as a substring.
 * For an exact match instead, put "^" and "$" in your regex as start/end anchors.
 */
bool regexMatch(const std::string& s, const std::string& regexp);

/**
 * Returns the number of times the given regular expression is found inside
 * the given string s.
 * Returns 0 if there are no matches for the regexp.
 */
int regexMatchCount(const std::string& s, const std::string& regexp);

/**
 * Finds all matches of the given regular expression in the given string s
 * and fills 'linesOut' with a comma-separated string representing the line
 * numbers within the string at which the matches occur, such as "2,14,27,36".
 * This is mainly useful for grading programs.
 * Returns the number of times the given regular expression is found inside
 * the given string s.  Returns 0 if there are no matches for the regexp.
 */
int regexMatchCountWithLines(const std::string& s, const std::string& regexp,
                             std::string& linesOut);

/**
 * Finds all matches of the given regular expression in the given string s
 * and fills 'linesOut' with the line numbers within the string at which the
 * matches occur, such as [2, 14, 27, 36].
 * This is mainly useful for grading programs.
 * Returns the number of times the given regular expression is found inside
 * the given string s.  Returns 0 if there are no matches for the regexp.
 */
void regexMatchCountWithLines(const std::string& s, const std::string& regexp,
                              Vector<int>& linesOut);

/**
 * Replaces occurrences of the given regular expression in s with the given
 * replacement text, and returns the resulting string.
 * If limit >  0 is passed, replaces that many occurrences of the regex.
 * If limit <= 0 is passed (or omitted), all occurrences are replaced.
 */
std::string regexReplace(const std::string& s, const std::string& regexp,
                         const std::string& replacement, int limit = -1);

#endif // _regexpr_h

/////////////////////// END code extracted from StanfordCPPLib/util/regexpr.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/system/call_stack.h ///////////////////////
/*
 * Copyright (c) 2009, Fredrik Orderud
 * License: BSD licence (http://www.opensource.org/licenses/bsd-license.php)
 *
 * @author Marty Stepp (made changes to F.Orderud version)
 * @version 2018/10/22
 * - bug fix for STL vector vs Stanford Vector
 * @version 2018/10/18
 * - added addr2line_functionName to resolve some function names not in backtrace
 * @version 2016/12/01
 * - bug fixes for call stack line number retrieval
 * - slight refactor of entry class
 * @version 2015/07/05
 * - replaced pragma once with ifndef/define for greater compatibility
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _call_stack_h
#define _call_stack_h
#include <string>
#include <sstream>
#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

namespace stacktrace {

int execAndCapture(std::string cmd, std::string& output);
int addr2line(void* addr, std::string& line);
int addr2line_all(Vector<void*> addrsVector, std::string& output);
int addr2line_all(void** addrs, int length, std::string& output);
std::string addr2line_clean(std::string line);
std::string addr2line_functionName(std::string line);

/*
 * Function to get/set a fake call stack pointer for use in printing a stack trace.
 * Called on Windows only after a signal / SEH handler is invoked to get a stack pointer.
 */
void*& fakeCallStackPointer();

/** Call-stack entry datastructure. */
struct entry {
public:
    /** Default constructor that clears all fields. */
    entry() : line(0), address(nullptr) {
        // empty
    }

    std::string file;       // filename
    size_t      line;       // line number
    std::string lineStr;    // line number string (not always set)
    std::string function;   // name of function or method
    void* address;          // memory address of stack pointer (raw)
    void* address2;         // memory address of stack pointer (from dladdr; data segment offset subtracted)

    /** Serialize entry into a text string. */
    std::string toString() const {
        std::ostringstream os;
        os << "file=\"" << file << "\"";
        if (line > 0) {
            os << " (line=" << line << ")";
        } else if (!lineStr.empty()) {
            os << " (lineStr=\"" << lineStr << "\")";
        }
        os << " function=\"" << function << "\"";
        return os.str();
    }
};

std::ostream& operator <<(std::ostream& out, const entry& ent);

/** Stack-trace base class, for retrieving the current call-stack. */
class call_stack {
public:
    /** Stack-trace consructor.
     \param num_discard - number of stack entries to discard at the top. */
    call_stack(const size_t num_discard = 0);

    virtual ~call_stack() throw();

    /** Serializes the entire call-stack into a text string. */
    std::string to_string() const {
        std::ostringstream os;
        for (int i = 0; i < stack.size(); i++)
            os << stack[i].toString() << std::endl;
        return os.str();
    }

    /** Call stack. */
    Vector<entry> stack;
};

} // namespace stacktrace

#endif // _call_stack_h

/////////////////////// END code extracted from StanfordCPPLib/system/call_stack.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/timer.h ///////////////////////
/*
 * File: timer.h
 * -------------
 * This file exports a Timer class that is useful for measuring the elapsed
 * time of a program in milliseconds over a given interval.
 *
 * @version 2018/09/25
 * - added doc comments for new documentation generation
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _timer_h
#define _timer_h

/**
 * A Timer object is useful for measuring the elapsed
 * time of a program in milliseconds over a given interval.
 * Usage example:
 *
 *<pre>
 * Timer tim;
 * tim.start();
 * ... code that takes a while ...
 * tim.stop();
 * cout << "That took " << tim.elapsed() << "ms." << endl;
 *</pre>
 */
class Timer {
public:
    /**
     * Constructs a new timer.
     * If an optional bool parameter of true is passed, also starts the timer.
     */
    Timer(bool autostart = false);

    /**
     * Returns the number of milliseconds that have elapsed since this timer
     * was started.
     * Returns 0 if the timer was never started.
     */
    long elapsed() const;

    /**
     * Returns true if the timer has been started.
     */
    bool isStarted() const;

    /**
     * Starts the timer.
     * If the timer was already started, restarts it such that its 'elapsed'
     * time will be 0 at the moment of the call.
     */
    void start();

    /**
     * Stops the timer and returns the number of elapsed milliseconds.
     * If the timer was never started, 0 ms will be considered to have elapsed.
     */
    long stop();

    /**
     * A static utility function for getting the current time as a Unix
     * timestamp of milliseconds since the epoch.
     */
    static long currentTimeMS();

private:
    // instance variables
    long _startMS;
    long _stopMS;
    bool _isStarted;
};

#endif // _timer_h

/////////////////////// END code extracted from StanfordCPPLib/util/timer.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib/util/note.h ///////////////////////
/*
 * File: note.h
 * ------------
 * This file defines a class named Note that can play musical notes.
 *
 * @author Marty Stepp
 * @version 2016/09/26
 * - initial version
 * @since 2016/09/26
 */



#ifndef INTERNAL_INCLUDE

#endif // INTERNAL_INCLUDE

#ifndef _note_h
#define _note_h

#include <iostream>
#include <string>

/**
 * Constant for the minimum legal value that an octave can have.
 */
#define OCTAVE_MIN 1

/**
 * Constant for the maximum legal value that an octave can have.
 */
#define OCTAVE_MAX 10

/**
 * Should Note objects print a message to the console as they play?
 */
#define NOTE_DEBUG false

/**
 * Each Note object represents a musical note or rest.
 * A Note encapsulates a pitch (A-G), a duration in seconds, an octave,
 * an accidental (sharp, flat, or natural), and a flag of whether it is the
 * start/end of a repeated section or not.
 * A song or melody can be thought of as a list or array of Note objects.
 */
class Note {
public:
    /**
     * Represents a musical pitch from A-G or rest.
     */
    enum Pitch {A, B, C, D, E, F, G, R};

    /**
     * Represents a musical accidental: sharp, natural, or flat.
     */
    enum Accidental {SHARP, NATURAL, FLAT};

    /**
     * Constructs a Note with the information contained in the given line.
     * @param line a line of input data such as "0.2 C 4 NATURAL false" or "0.4 R false" for a rest
     * @throws an error if line is empty.
     * @throws an error if duration is negative or octave is not
     *         between OCTAVE_MIN and OCTAVE_MAX inclusive.
     */
    Note(std::string line);

    /**
     * Constructs a Note with the given information.
     * @param duration Note's duration in seconds.
     * @param pitch Note's pitch from A through G, or R for a rest.
     * @param octave Note's octave from OCTAVE_MIN through OCTAVE_MAX inclusive.
     * @param accidental Note's accidental from SHARP, FLAT, or NATURAL.
     * @param repeat true if this note starts/ends a repeated section.
     * @throws an error if any value passed is illegal.
     */
    Note(double duration = 0.0, Pitch pitch = R, int octave = OCTAVE_MIN, Accidental accidental = NATURAL, bool repeat = false);

    /**
     * Returns true if note2 has the same state as this Note object; otherwise false.
     * @param o the object to compare against
     */
    bool equals(const Note& note2) const;

    /**
     * Returns this Note's accidental value of SHARP, FLAT, or NATURAL.
     * The accidental value is meaningless for a rest; this method will
     * return NATURAL by default if called on a rest.
     * @return this Note's accidental value of SHARP, FLAT, or NATURAL.
     */
    Accidental getAccidental() const;

    /**
     * Returns this Note's duration in seconds.
     * @return this Note's duration in seconds.
     */
    double getDuration() const;

    /**
     * Returns this Note's octave.
     * The octave value is meaningless for a rest; this method will return
     * OCTAVE_MIN + 1 by default if called on a rest.
     * @return this Note's octave from OCTAVE_MIN to OCTAVE_MAX.
     */
    int getOctave() const;

    /**
     * Returns this Note's pitch value of A-G or R for a rest.
     * @return this Note's pitch value of A-G or R for a rest.
     */
    Pitch getPitch() const;

    /**
     * Returns true if this Note is the start or end of a repeated section.
     * @return true if this Note is the start or end of a repeated section,
     *         otherwise false.
     */
    bool isRepeat() const;

    /**
     * Returns true if this Note is a rest.  Equivalent to checking whether
     * this note's pitch is Pitch.R.  Provided for convenience.
     * @return true if this Note is a rest, otherwise false.
     */
    bool isRest() const;

    /**
     * Plays this note through the underlying audio system.
     * Also may print a message to the system console for debugging.
     * If the audio system is muted or paused, the note may not play.
     */
    void play() const;

    /**
     * Sets this Note's accidental value to be the given value: SHARP, FLAT, or NATURAL.
     * The accidental value is meaningless for a rest, but the Note object still
     * maintains an accidental value internally (initially NATURAL)
     * which is ignored.
     * @param accidental Note's accidental from SHARP, FLAT, or NATURAL.
     * @throws an error if the accidental value passed is illegal.
     */
    void setAccidental(Accidental accidental);

    /**
     * Sets this Note's duration in seconds to be the given value.
     * @param duration Note's duration in seconds.
     * @throws an error if duration is negative.
     */
    void setDuration(double duration);

    /**
     * Sets this Note's octave to be the given value.
     * The octave value is meaningless for a rest, but the Note object still
     * maintains an octave value internally (initially OCTAVE_MIN + 1)
     * which is ignored.
     * @param octave Note's octave from OCTAVE_MIN through OCTAVE_MAX inclusive.
     * @throws an error if octave is not between OCTAVE_MIN and OCTAVE_MAX inclusive.
     */
    void setOctave(int octave);

    /**
     * Sets this Note's pitch to be the given value.
     * @param pitch Note's pitch from A through G, or R for a rest.
     * @throws an error if pitch is invalid.
     */
    void setPitch(Pitch pitch);

    /**
     * Sets this Note's repeat flag to be the given value.
     * @param repeat true to indicate that this note is the start/end of a
     *               repeated section, or false if not.
     */
    void setRepeat(bool repeat);

    /**
     * Returns a string representation of this note.
     * @return A string such as "0.4 C 5 NATURAL false".
     */
    std::string toString() const;

private:
    // member variables (a.k.a. instance variables; fields)
    double duration;
    Pitch pitch;
    int octave;
    Accidental accidental;
    bool repeat;
};

/**
 * Compares the given two Note objects for equality.
 */
bool operator ==(const Note& note1, const Note& note2);

/**
 * Compares the given two Note objects for inequality.
 */
bool operator !=(const Note& note1, const Note& note2);

std::ostream& operator <<(std::ostream& out, const Note& note);

/**
 * Returns a unique integer hash code for the given Note object.
 */
int hashCode(const Note& note);

#endif // _note_h

/////////////////////// END code extracted from StanfordCPPLib/util/note.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/ArrayIntList.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * ArrayIntList is our example of implementing a basic data structure.
 * The list can store only ints for now.
 * See ArrayIntList.cpp for documentation of each member.
 *
 * @version 2016/08/23
 * - added initializer_list support to match other lib collections
 * @version 2016/07/10
 * - added removeDuplicates() declaration
 */

#ifndef _arrayintlist_h
#define _arrayintlist_h

#include <fstream>
#include <initializer_list>
#include <iostream>
#include <string>

using namespace std;

class ArrayIntList {
public:
    // constructor
    ArrayIntList();
    ArrayIntList(int capacity);
    ArrayIntList(std::initializer_list<int> list);
    ~ArrayIntList();
    
    // member functions (methods)
    void add(int value);
    void clear();
    void ensureCapacity(int capacity);
    int get(int index) const;
    void insert(int index, int value);
    bool isEmpty() const;
    void remove(int index);
    void set(int index, int value);
    int size() const;
    void debug() const;
    
    // section problems
    int maxCount() const;
    
    // exam problems
    void stretch(int k);
    void mirror();
    int longestSortedSequence() const;
    bool filter(const Set<int>& set);
    void removeDuplicates();

    ArrayIntList& operator =(const ArrayIntList& src);

private:
    // member variables (fields)
    int* elements;   // array storing element data
    int mysize;      // number of elements in the array
    int capacity;    // array's length
    
    void checkIndex(int index, int min, int max) const;
};

// overloaded operators
ostream& operator <<(ostream& out, const ArrayIntList& list);
istream& operator >>(istream& in, ArrayIntList& list);

#endif








/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/ArrayIntList.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeNode.h ///////////////////////
/*
 * This file contains the declaration of the BinaryTreeNode structure.
 * A BinaryTreeNode stores one integer piece of data in a binary tree of integers.
 *
 * @version 2015/11/10
 * - added nodes for char, double, string
 * @version 2015/07/21
 * - initial version
 */

#ifndef _binarytreenode_h
#define _binarytreenode_h

#include <iostream>
#include <string>



template <typename T>
class BinaryTreeNodeGen {
public:
    static int s_allocated;
    static int s_freed;
    T data;
    BinaryTreeNodeGen<T>* left;
    BinaryTreeNodeGen<T>* right;

    /*
     * Constructs a new tree node with the given data and left/right links.
     */
    BinaryTreeNodeGen<T>(const T& data = T(), BinaryTreeNodeGen* left = nullptr, BinaryTreeNodeGen* right = nullptr);
    ~BinaryTreeNodeGen<T>();
    bool isLeaf() const;
};

// define various node types so that some students need not learn C++ templates
typedef BinaryTreeNodeGen<int> BinaryTreeNode;
typedef BinaryTreeNodeGen<char> BinaryTreeNodeChar;
typedef BinaryTreeNodeGen<double> BinaryTreeNodeDouble;
typedef BinaryTreeNodeGen<std::string> BinaryTreeNodeString;

template <typename T>
std::ostream& operator <<(std::ostream& out, BinaryTreeNodeGen<T>* node);

template <typename T>
std::istream& operator >>(std::istream& input, BinaryTreeNodeGen<T>*& node);


// begin ".cpp" section

template <typename T>
int BinaryTreeNodeGen<T>::s_allocated = 0;

template <typename T>
int BinaryTreeNodeGen<T>::s_freed = 0;

/*
 * Constructs a new tree node with the given data and left/right links.
 */
template <typename T>
BinaryTreeNodeGen<T>::BinaryTreeNodeGen(const T& data, BinaryTreeNodeGen* left, BinaryTreeNodeGen* right) {
    this->data = data;
    this->left = left;
    this->right = right;
    s_allocated++;
}

template <typename T>
BinaryTreeNodeGen<T>::~BinaryTreeNodeGen() {
    s_freed++;
    this->left = nullptr;
    this->right = nullptr;
}

template <typename T>
bool BinaryTreeNodeGen<T>::isLeaf() const {
    return left == nullptr && right == nullptr;
}

template <typename T>
void parseBinaryTreeNodeFromQueue(Queue<std::string>& tokenQueue, BinaryTreeNodeGen<T>*& node) {
    if (tokenQueue.isEmpty()) {
        node = nullptr;
    } else if (tokenQueue.peek() == "(") {
        // start of a new node
        tokenQueue.dequeue();   // the "(" token
        T data;
        std::istringstream isstr(tokenQueue.dequeue());
        readGenericValue(isstr, data);
        node = new BinaryTreeNodeGen<T>(data);
        parseBinaryTreeNodeFromQueue(tokenQueue, node->left);
        parseBinaryTreeNodeFromQueue(tokenQueue, node->right);
        tokenQueue.dequeue();   // the ")" token
    } else if (tokenQueue.peek() == "NULL" || tokenQueue.peek() == "null"
               || tokenQueue.peek() == "nullptr" || tokenQueue.peek() == "/") {
        tokenQueue.dequeue();
        node = nullptr;
    } else {
        node = nullptr;
    }
}

template <typename T>
void makeTreeFromString(std::string s, BinaryTreeNodeGen<T>*& node) {
    // make easier for tokenizing
    s = stringReplace(s, "(", "( ");
    s = stringReplace(s, "[", "( ");
    s = stringReplace(s, ")", " ) ");
    s = stringReplace(s, "]", " ) ");
    s = stringReplace(s, ", ", " , ");
    s = stringReplace(s, "  ", " ");
    s = stringReplace(s, "  ", " ");
    s = stringReplace(s, "  ", " ");
    s = stringReplace(s, "  ", " ");
    Vector<std::string> tokens = stringSplit(s, " ");
    Queue<std::string> tokenQueue;
    for (const std::string& token : tokens) {
        tokenQueue.enqueue(token);
    }

    parseBinaryTreeNodeFromQueue(tokenQueue, node);
}

template <typename T>
std::ostream& binaryTreeOpLtLtHelper(std::ostream& out, BinaryTreeNodeGen<T>* node) {
    if (!node) {
        out << "/";
    } else {
        out << "(";
        writeGenericValue(out, node->data, /* forceQuotes */ true);
        if (!node->isLeaf()) {
            out << " ";
            binaryTreeOpLtLtHelper(out, node->left);
            if (node->right) {
                out << " ";
                binaryTreeOpLtLtHelper(out, node->right);
            }
        }
        out << ")";
    }
    return out;
}

template <typename T>
std::ostream& operator <<(std::ostream& out, BinaryTreeNodeGen<T>* node) {
    binaryTreeOpLtLtHelper(out, node);
    return out;
}

template <typename T>
std::istream& operator >>(std::istream& input, BinaryTreeNodeGen<T>*& node) {
    std::string line;
    if (getline(input, line)) {
        makeTreeFromString(line, node);
    } else {
        node = nullptr;
    }
    return input;
}

#endif // _binarytreenode_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeNode.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTree.h ///////////////////////
/*
 * This file contains the declaration of the BinaryTree class,
 * which defines a binary tree of integers.
 * See BinaryTree.cpp for implementation of each member.
 *
 * @version 2017/10/20
 * - replaced nulls with nullptr
 * @version 2015/07/21
 */

#ifndef _binarytree_h
#define _binarytree_h

#include <iostream>
#include <string>


using namespace std;

class BinaryTree {
public:
    // public just for exam testing
    BinaryTreeNode* root;   // topmost node in the tree (null if empty)

    BinaryTree(BinaryTreeNode* root = nullptr);
    virtual ~BinaryTree();
    
    void clear();
    // int height();
    string toString();
    
    // lecture problems
    void print() const;
    int size() const;
    void printSideways() const;
    bool contains(int value) const;

    // section problems
    int height() const;
    int countLeftNodes() const;
    bool isBalanced() const;
    bool isBST() const;
    void removeLeaves();
    void completeToLevel(int k);
    void tighten();
    void limitPathSum(int max);
    
    // exam problems
    bool hasPath(int start, int end) const;
    bool isConsecutive() const;
    void limitLeaves(int n);
    int makeFull();
    int range(int min, int max);
    void removeMatchingLeaves(const BinaryTree& other);
    void swapChildrenAtLevel(int level);

    // operators for reading/writing trees based on a root pointer
    // (these are used by the CodeStepByStep tool)
    friend ostream& operator <<(ostream& out, BinaryTreeNode* node);
    friend istream& operator >>(istream& input, BinaryTreeNode*& node);

private:
    int size(BinaryTreeNode* node);
    string toString(BinaryTreeNode* node);
    void deleteTree(BinaryTreeNode* node);
};

ostream& operator <<(ostream& out, const BinaryTree& tree);
istream& operator >>(istream& input, BinaryTree& tree);

enum Order {PRE_ORDER, IN_ORDER, POST_ORDER};

template <typename T>
class TreeSet {
public:
    TreeSet(BinaryTreeNodeGen<T>* root = nullptr);
    virtual ~TreeSet();
    
    void add(T value);
    bool contains(T value);
    T getMin() const;
    int height() const;
    bool isBalanced() const;
    void print(int order = IN_ORDER);
    void printSideways();
    void remove(T value);
    
private:
    BinaryTreeNodeGen<T>* root;   // topmost node in the tree (nullptr if empty)

    void add(BinaryTreeNodeGen<T>*& node, T value);
    bool contains(BinaryTreeNodeGen<T>* node, T value);
    T getMin(BinaryTreeNodeGen<T>* node) const;
    int height(BinaryTreeNodeGen<T>* node) const;
    bool isBalanced(BinaryTreeNodeGen<T>* node) const;
    void print(BinaryTreeNodeGen<T>* node, int order = IN_ORDER);
    void printSideways(BinaryTreeNodeGen<T>* node, string indent);
    void remove(BinaryTreeNodeGen<T>*& node, T value);
};

// method bodies must be in .h file for template classes

template <typename T>
TreeSet<T>::TreeSet(BinaryTreeNodeGen<T>* root) {
    this->root = root;
}

template <typename T>
TreeSet<T>::~TreeSet() {
    // TODO
    root = nullptr;
}

template <typename T>
void TreeSet<T>::add(T value) {
    add(root, value);
}

template <typename T>
void TreeSet<T>::add(BinaryTreeNodeGen<T>*& node, T value) {
    if (!node) {
        node = new BinaryTreeNodeGen<T>(value);
    } else if (value < node->data) {
        add(node->left, value);
    } else if (value > node->data) {
        add(node->right, value);
    }
}

template <typename T>
bool TreeSet<T>::contains(T value) {
    return contains(root, value);
}

template <typename T>
bool TreeSet<T>::contains(BinaryTreeNodeGen<T>* node, T value) {
    if (!node) {
        return false;
    } else if (value == node->data) {
        return true;
    } else if (value < node->data) {
        return contains(node->left, value);
    } else {
        return contains(node->right, value);
    }
}

template <typename T>
T TreeSet<T>::getMin() const {
    return getMin(root);
}

template <typename T>
T TreeSet<T>::getMin(BinaryTreeNodeGen<T>* node) const {
    if (!node) {
        throw ":-(";
    } else if (!node->left) {
        return node->data;
    } else {
        return getMin(node->left);
    }
}

template <typename T>
int TreeSet<T>::height() const {
    return height(root);
}

template <typename T>
int TreeSet<T>::height(BinaryTreeNodeGen<T>* node) const {
    if (!node) {
        return 0;
    } else {
        int l = height(node->left);
        int r = height(node->right);
        return max(l, r) + 1;
    }
}

template <typename T>
bool TreeSet<T>::isBalanced() const {
    return isBalanced(root);
}

template <typename T>
bool TreeSet<T>::isBalanced(BinaryTreeNodeGen<T>* node) const {
    if (!node) {
        return true;
    } else {
        int l = height(node->left);
        int r = height(node->right);
        int bf = r - l;
        if (abs(bf) > 1) {
            cout << "imbalanced: " << node->data << " (balance factor: " << bf << ")" << endl;
        }
        // inefficient because we want to print ALL imbalanced nodes
        bool balL = isBalanced(node->left);
        bool balR = isBalanced(node->right);
        return abs(l - r) <= 1 && balL && balR;
    }
}

template <typename T>
void TreeSet<T>::print(int order) {
    print(root, order);
    cout << endl;
}

template <typename T>
void TreeSet<T>::print(BinaryTreeNodeGen<T>* node, int order) {
    if (node) {
        if (order == PRE_ORDER) {
            cout << node->data << " ";
            cout.flush();
        }
        print(node->left, order);
        if (order == IN_ORDER) {
            cout << node->data << " ";
            cout.flush();
        }
        print(node->right, order);
        if (order == POST_ORDER) {
            cout << node->data << " ";
            cout.flush();
        }
    }
}

template <typename T>
void TreeSet<T>::printSideways() {
    printSideways(root, "");
}

template <typename T>
void TreeSet<T>::printSideways(BinaryTreeNodeGen<T>* node, string indent) {
    if (node) {
        printSideways(node->right, indent + "  ");
        cout << indent << node->data << endl;
        printSideways(node->left, indent + "  ");
    }
}

template <typename T>
void TreeSet<T>::remove(T value) {
    remove(root, value);
}

template <typename T>
void TreeSet<T>::remove(BinaryTreeNodeGen<T>*& node, T value) {
    if (!node) {
        // do nothing
    } else if (value < node->data) {
        remove(node->left, value);
    } else if (value > node->data) {
        remove(node->right, value);
    } else {
        // remove this node
        if (!node->left && !node->right) {
            delete node;
            node = nullptr;
        } else if (!node->left) {
            BinaryTreeNodeGen<T>* trash = node;
            node = node->right;
            delete trash;
        } else if (!node->right) {
            BinaryTreeNodeGen<T>* trash = node;
            node = node->left;
            delete trash;
        } else {
            T min = getMin(node->right);
            remove(node->right, min);
            node->data = min;
        }
    }
}

#endif // _binarytree_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTree.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeMapNode.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * This file contains the declaration of the TreeMapNode structure.
 * A TreeMapNode stores one string/integer key/value pair in a tree map.
 *
 * @version 2015/07/21
 */

#ifndef _binarytreemapnode_h
#define _binarytreemapnode_h

#include <string>
using namespace std;

struct BinaryTreeMapNode {
    string key;
    int value;
    BinaryTreeMapNode* left;
    BinaryTreeMapNode* right;

    /*
     * Constructs a new tree node with the given key/value and left/right links.
     */
    BinaryTreeMapNode(string key, int value, BinaryTreeMapNode* left = nullptr, BinaryTreeMapNode* right = nullptr) {
        this->key = key;
        this->value = value;
        this->left = left;
        this->right = right;
    }
    
    /*
     * Returns true if this node has no children.
     */
    bool isLeaf() {
        return !left && !right;
    }
};

#endif

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeMapNode.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeMap.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * This file contains the declaration of the BinaryTreeMap class,
 * which defines a map from string->integer using a binary search tree.
 * See BinaryTreeMap.cpp for implementation of each member.
 *
 * @version 2015/07/21
 */

#ifndef _binarytreemap_h
#define _binarytreemap_h

#include <iostream>
#include <string>

using namespace std;

class BinaryTreeMap {
public:
    /*
     * Constructs a new tree map.
     */
    BinaryTreeMap();

    /*
     * Frees memory that was allocated by this tree map.
     */
    ~BinaryTreeMap();
    
    /*
     * Returns true if the given key is contained in this map.
     */
    bool containsKey(string key) const;

    /*
     * Returns the value associated with the given key in this map.
     * If the given key is not associated with any value, returns 0.
     */
    int get(string key) const;

    /*
     * Returns true if this map does not contain any key/value pairs.
     */
    bool isEmpty() const;

    /*
     * Adds the given key/value pair to this tree map, if not already present.
     */
    void put(string key, int value);

    /*
     * Removes the given key and its associated value from this tree map, if it was present.
     */
    void remove(string key);

    /*
     * Returns the number of key/value pairs in this map.
     */
    int size() const;
    
private:
    BinaryTreeMapNode* m_root;   // topmost node in the tree (null if empty)
    int m_size;            // # of k/v pairs in map (0 if empty)

    /*
     * Recursive helpers to implement the above public members.
     * Each helper accepts a pointer to the part of the tree to process.
     */
    bool containsKey(BinaryTreeMapNode* node, string key) const;
    int get(BinaryTreeMapNode* node, string key) const;
    BinaryTreeMapNode* getMin(BinaryTreeMapNode* node) const;
    void put(BinaryTreeMapNode*& node, string key, int value);
    void remove(BinaryTreeMapNode*& node, string key);
};

#endif

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/BinaryTreeMap.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HashTableMap.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * This file contains the declaration of the HashTableMap class, which implements
 * a map using a hash table.
 * The hash table uses separate chaining (a linked list of values in each
 * hash bucket) to resolve hash collisions.
 *
 * @version 2015/07/21
 */

#ifndef _hashtablemap_h
#define _hashtablemap_h

#include <iomanip>
#include <iostream>
#include <string>

/*
 * A HashNode stores a single integer of data and a link to another node.
 */
template <typename K, typename V>
struct HashTableMapNode {
    K key;
    V value;
    HashTableMapNode* next;
    HashTableMapNode(K key, V value, HashTableMapNode* next = nullptr) {
        this->key = key;
        this->value = value;
        this->next = next;
    }
};

template <typename K, typename V>
class HashTableMap {
public:
    HashTableMap(int capacity = 10, double rehashLoadFactor = 0.5);
    void put(K key, V value);
    bool containsKey(K key) const;
    V get(K key) const;
    double loadFactor() const;
    void printStructure() const;
    void remove(K key);
    void setRehashLoadFactor(double loadFactor);

private:
    HashTableMapNode<K, V>** elements;
    int mysize;
    int capacity;
    double rehashLoadFactor;
    int __hashCode(int n) const;
    int __hashCode(double d) const;
    int __hashCode(string s) const;
    int _hashCode(K key) const;

    void rehash();
};

template <typename K, typename V>
HashTableMap<K, V>::HashTableMap(int capacity, double rehashLoadFactor) {
    mysize = 0;
    this->capacity = capacity;
    elements = new HashTableMapNode<K, V>*[capacity]();
    this->rehashLoadFactor = rehashLoadFactor;
}

template <typename K, typename V>
void HashTableMap<K, V>::put(K key, V value) {
    int index = _hashCode(key);
    if (containsKey(key)) {
        // already has a pair for this key; replace the value
        HashTableMapNode<K, V>* current = elements[index];
        while (current) {
            if (current->key == key) {
                current->value = value;
                break;
            }
            current = current->next;
        }
    } else {
        // add a new pair to the front of the chain
        elements[index] = new HashTableMapNode<K, V>(key, value, elements[index]);
        mysize++;
        if (loadFactor() >= rehashLoadFactor) {
            rehash();
        }
    }
}

template <typename K, typename V>
bool HashTableMap<K, V>::containsKey(K key) const {
    int index = _hashCode(key);
    HashTableMapNode<K, V>* current = elements[index];
    while (current) {
        if (current->key == key) {
            return true;
        }
        current = current->next;
    }
    return false;
}

template <typename K, typename V>
V HashTableMap<K, V>::get(K key) const {
    int index = _hashCode(key);
    HashTableMapNode<K, V>* current = elements[index];
    while (current) {
        if (current->key == key) {
            return current->value;
        }
        current = current->next;
    }
    return V();
}

template <typename K, typename V>
int HashTableMap<K, V>::__hashCode(int n) const {
    return n;
}

template <typename K, typename V>
int HashTableMap<K, V>::__hashCode(double d) const {
    return hashCode(d);
}

template <typename K, typename V>
int HashTableMap<K, V>::__hashCode(string s) const {
    return hashCode(s);
}

template <typename K, typename V>
int HashTableMap<K, V>::_hashCode(K key) const {
    return abs(__hashCode(key)) % capacity;
}

template <typename K, typename V>
double HashTableMap<K, V>::loadFactor() const {
    return (double) mysize / capacity;
}

template <typename K, typename V>
void HashTableMap<K, V>::printStructure() const {
    for (int i = 0; i < capacity; i++) {
        cout << "[" << setw(2) << i << "]:";
        HashTableMapNode<K, V>* curr = elements[i];
        while (curr) {
            cout << " -> " << setw(2) << curr->key << ":" << curr->value;
            curr = curr->next;
        }
        cout << endl;
    }
    cout << "size        = " << mysize << endl;
    cout << "capacity    = " << capacity << endl;
    cout << "load factor = " << loadFactor() << endl;
}

template <typename K, typename V>
void HashTableMap<K, V>::rehash() {
    HashTableMapNode<K, V>** oldElements = elements;
    elements = new HashTableMapNode<K, V>*[capacity * 2]();
    capacity *= 2;
    mysize = 0;
    
    for (int i = 0; i < capacity/2; i++) {
        HashTableMapNode<K, V>* curr = oldElements[i];
        while (curr) {
            put(curr->key, curr->value);
            HashTableMapNode<K, V>* trash = curr;
            curr = curr->next;
            delete trash;
        }
    }
    
    delete oldElements;
}

template <typename K, typename V>
void HashTableMap<K, V>::remove(K key) {
    int index = _hashCode(key);
    if (!elements[index]) {
        return;
    } else if (elements[index]->key == key) {
        // remove from front
        HashTableMapNode<K, V>* trash = elements[index];
        elements[index] = elements[index]->next;
        delete trash;
        mysize--;
    } else {
        // remove from later in the chain
        HashTableMapNode<K, V>* current = elements[index];
        while (current->next) {
            if (current->next->key == key) {
                HashTableMapNode<K, V>* trash = current->next;
                current->next = current->next->next;
                delete trash;
                mysize--;
                break;
            }
            current = current->next;
        }
    }
}

template <typename K, typename V>
void HashTableMap<K, V>::setRehashLoadFactor(double loadFactor) {
    this->rehashLoadFactor = loadFactor;
}

#endif

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HashTableMap.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HashTableSet.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * This file contains the declaration of the HashTableSet class, which implements
 * a set of integers using a hash table.
 * The hash table uses separate chaining (a linked list of values in each
 * hash bucket) to resolve hash collisions.
 * See HashTableSet.cpp for the implementation of each member.
 *
 * @version 2015/07/21
 */

#ifndef _hashtableset_h
#define _hashtableset_h

#include <iostream>
#include <string>

/*
 * A HashNode stores a single integer of data and a link to another node.
 */
struct HashTableNode {
    int data;
    HashTableNode* next;
    HashTableNode(int data = 0, HashTableNode* next = nullptr) {
        this->data = data;
        this->next = next;
    }
};

class HashTableSet {
public:
    HashTableSet();
    void add(int value);
    bool contains(int value) const;
    void remove(int value);
    void printStructure() const;

    void trimChains(int k);

private:
    HashTableNode** m_elements;
    int m_size;
    int m_capacity;
    int hashCode(int value) const;
};

#endif






/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HashTableSet.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HeapPriorityQueue.h ///////////////////////
/*
 * CS 106B, Marty Stepp
 * This file declares the HeapPriorityQueue class.
 *
 * @version 2015/07/29
 */

#ifndef _heappriorityqueue_h
#define _heappriorityqueue_h

#include <fstream>
#include <iostream>
#include <string>


using namespace std;

struct PQEntry {
    string data;
    double priority;
};

class HeapPriorityQueue {
public:
    HeapPriorityQueue(PQEntry* elements = nullptr, int capacity = 10, int mysize = 0);
    ~HeapPriorityQueue();
    void changePriority(string value, double newPriority);
    void clear();
    string dequeue();
    void enqueue(string value, double priority);
    bool isEmpty() const;
    string peek() const;
    double peekPriority() const;
    void printSideways(int index = 1, string indent = "") const;
    int size() const;
    string toString() const;
    
    friend ostream& operator <<(ostream& out, const HeapPriorityQueue& pq);
    friend istream& operator >>(istream& input, HeapPriorityQueue& pq);
    
    // exam problems
    int atLevel(int level) const;

private:
    PQEntry* elements;   // array of element data
    int capacity;        // length of elements array
    int mysize;          // number of elements that have been added
    
    PriorityQueue<string>* hackPQ;
};

// "a:4, b:16, c:7" => PQ
void stringToPQ(HeapPriorityQueue& pq, string elements);

#endif

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/HeapPriorityQueue.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/LinkedIntList.h ///////////////////////
/*
 * LinkedIntList is an example of a second implementation of a basic data structure.
 * A LinkedIntList is a sequential collection of integers stored with 0-based integer
 * indexes and internally represented as a list of linked node structures.
 *
 * @version 2019/05/17
 * - added AssassinNode
 * @version 2018/03/19
 * - changed nullptr output to {}
 * @version 2016/11/11
 * - made into template class
 * @version 2016/08/23
 * - added initializer_list support to match other lib collections
 */

#ifndef _linkedintlist_h
#define _linkedintlist_h

#include <initializer_list>
#include <iostream>
#include <string>






/*
 * The internal structure representing a single node.
 */
template <typename T>
class ListNodeGen {
public:
    // global count of how many nodes have been created/destroyed
    static int s_allocated;
    static int s_freed;

    T data;           // element stored in each node
    ListNodeGen<T>* next;   // pointer to the next node (null if none)

    ListNodeGen(T d = T(), ListNodeGen<T>* n = nullptr);
    ~ListNodeGen();

    static void printChain(ListNodeGen<T>* list, std::string name = "list", int maxLength = 10);
};

template <typename T>
std::ostream& operator <<(std::ostream& out, ListNodeGen<T>* front);

template <typename T>
std::istream& operator >>(std::istream& input, ListNodeGen<T>*& front);


// begin "cpp" section of ListNode

template <typename T>
int ListNodeGen<T>::s_allocated = 0;

template <typename T>
int ListNodeGen<T>::s_freed = 0;

template <typename T>
ListNodeGen<T>::ListNodeGen(T d, ListNodeGen<T>* n) {
    data = d;
    next = n;
    s_allocated++;
}

template <typename T>
ListNodeGen<T>::~ListNodeGen() {
    s_freed++;
    next = nullptr;
}

template <typename T>
void ListNodeGen<T>::printChain(ListNodeGen<T>* list, std::string name, int maxLength) {
    std::cout << name << ": ";
    if (!list) {
        std::cout << "nullptr" << std::endl;
    } else {
        ListNodeGen<T>* curr = list;
        bool hasCycle = false;
        for (int i = 0; curr && (maxLength <= 0 || i < maxLength); i++, curr = curr->next) {
            std::cout << curr->data;
            if (curr->next) {
                std::cout << " -> ";
            }
            if (i == maxLength - 1) {
                std::cout << " ... (cycle)";
                hasCycle = true;
            }
        }
        if (!hasCycle) {
            std::cout << " /";
        }
        std::cout << std::endl;
    }
}

template <typename T>
std::ostream& operator <<(std::ostream& out, ListNodeGen<T>* front) {
    if (!front) {
        // out << "nullptr";
        out << "{}";
    } else {
        out << "{";
        if (front) {
            HashSet<ListNodeGen<T>*> visited;
            writeGenericValue(out, front->data, /* forceQuotes */ true);
            visited.add(front);

            ListNodeGen<T>* curr = front->next;
            while (curr) {
                out << ", ";
                writeGenericValue(out, curr->data, /* forceQuotes */ true);
                if (visited.contains(curr)) {
                    out << " (cycle!)";
                    break;
                }

                visited.add(curr);
                curr = curr->next;
            }
        }
        out << "}";
    }
    return out;
}

template <typename T>
std::istream& operator >>(std::istream& input, ListNodeGen<T>*& front) {
    // read into a vector first (yeah yeah, wastes some space, oh well)
    Vector<T> vec;
    T element;
    stanfordcpplib::collections::readCollection(input, vec, element, /* descriptor */ "ListNode::operator >>");

    // now convert into a linked list
    if (vec.isEmpty()) {
        front = nullptr;
    } else {
        front = new ListNodeGen<T>(vec[0]);
        ListNodeGen<T>* curr = front;
        for (int i = 1; i < vec.size(); i++) {
            curr->next = new ListNodeGen<T>(vec[i]);
            curr = curr->next;
        }
    }

    return input;
}

typedef ListNodeGen<int> ListNode;
typedef ListNodeGen<int> ListNodeInt;
typedef ListNodeGen<double> ListNodeDouble;
typedef ListNodeGen<std::string> ListNodeString;
typedef ListNodeGen<std::string> AssassinNode;

// end "cpp" section of ListNode


class LinkedIntList {
public:
    LinkedIntList();
    LinkedIntList(std::initializer_list<int> list);
    ~LinkedIntList();

    void add(int value);
    void clear();
    int get(int index) const;
    void insert(int index, int value);
    bool isEmpty() const;
    void remove(int index);
    void set(int index, int value);
    int size() const;
    std::string toString() const;

    // section problems
    void setLocked(bool locked);
    int min() const;
    bool isSorted() const;
    int countDuplicates() const;
    void stutter();
    int deleteBack();
    void split();
    void removeAll(int value);
    void doubleList();
    void rotate();
    void reverse();
    void consume(LinkedIntList& list2);
    void transferEvens(LinkedIntList& list2);

    // exam questions
    void chopBothSides(int k);
    void combineDuplicates();
    void expand(int k);
    bool isSortedBy(int k) const;
    void mergeUpTo(int max);
    void partitionSort();
    bool removeRange(int min, int max);

    LinkedIntList& operator =(const LinkedIntList& src);

    // declared here so they can access front
    friend std::ostream& operator <<(std::ostream& out, const LinkedIntList& list);
    friend std::istream& operator >>(std::istream& input, LinkedIntList& list);

private:
    ListNode* front;   // pointer to front node in list;  null if empty

    bool m_locked;     // whether to forbid method calls (for problems)

    void checkIndex(int index, int min, int max) const;
    void checkLocked(std::string memberName = "") const;
};

#endif // _linkedintlist_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/LinkedIntList.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/graphsupport.h ///////////////////////
#ifndef _graphsupport_h
#define _graphsupport_h

#include <iostream>
#include <sstream>


using namespace std;

// colors for graph problems
typedef int Color;
extern const Color UNCOLORED, WHITE, GRAY, YELLOW, GREEN, RED, BLUE;
extern const int NUM_COLORS;
extern const Color COLORS[7];
extern const std::string COLOR_NAMES[7];

bool graph_canReach(BasicGraph& graph, Vertex* start, Vertex* end, Set<Vertex*>& visited, Vector<Vertex*>* path = nullptr);
bool graph_isConnected(BasicGraph& graph, bool checkWeak = false);
bool graph_isCyclic(BasicGraph& graph);
void graph_printEdgeList(BasicGraph& graph);
void graph_printAdjacencyList(BasicGraph& graph);
void graph_printAdjacencyMatrix(BasicGraph& graph);
void graph_printVertexDegrees(BasicGraph& graph);
string graph_pathToString(const Vector<Vertex*>& path);
void graph_printPath(const Vector<Vertex*>& path);
void BasicGraph_fromString(BasicGraph& obj, string str);
ostream& operator <<(ostream& out, const Vector<Vertex*>& path);
ostream& operator <<(ostream& out, const Set<Vertex*>& set);

#endif //_graphsupport_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/graphsupport.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/types.h ///////////////////////
/*
 * Various support classes and types used in practice problems.
 *
 * @version 2015/08/10
 */

#ifndef _types_h
#define _types_h

#include <iostream>
using namespace std;

struct Domino {
    int first;
    int second;
    
    Domino(int f = 0, int s = 0);
};

ostream& operator <<(ostream& out, const Domino& d);
istream& operator >>(istream& input, Domino& d);

#endif // _types_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/types.h ///////////////////////

/////////////////////// BEGIN code extracted from StanfordCPPLib_CodeStepByStep_Project/src/codestepbystep.h ///////////////////////
/*
 * @version 2019/10/12
 * - add arrayToString template
 * @version 2019/05/17
 * - add AssassinNode support
 * @version 2019/04/24
 * - add setFromFile
 * - remove STL includes
 * @version 2017/10/06
 * - hid POSIX signal handler behind preprocessor macro
 * @version 2016/12/07
 * - added assert* methods
 */

#ifndef _codestepbystep_h
#define _codestepbystep_h

// basic standard library stuff
#include <cctype>
#include <climits>
#include <cmath>
#include <csignal>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

//// STL
//#include <algorithm>
//#include <deque>
//#include <list>
//#include <map>
//#include <queue>
//#include <set>
//#include <stack>
//#include <vector>

// Stanford lib stuff
#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#define INTERNAL_INCLUDE 1

#undef INTERNAL_INCLUDE

namespace CodeStepByStep {

std::string testToRun();
bool runAllTests();

std::string htmlDecode(const std::string& s);
std::string htmlEncode(const std::string& s);

template <typename T>
std::string htmlEncode(const T& obj) {
    std::ostringstream out;
    out << obj;
    std::string s = out.str();
    return ::htmlEncode(s);
}

std::ofstream& __getXmlOut();

void printXml(const std::string& s);

void printlnXml(const std::string& s);

void printXml(bool b);

void printlnXml(bool b);

void printXml(double d);

void printlnXml(double d);

void printXml(float f);

void printlnXml(float f);

template <typename T>
void printXml(const T& value) {
    __getXmlOut() << value;
}

template <typename T>
void printlnXml(const T& value) {
    __getXmlOut() << value << std::endl;
}

std::string __stackTraceToString();

void __printException(const std::string& type, const std::string& message = "",
                      const std::string& stacktrace = "", int lineNumber = -1);

void __openXmlOldWay(const std::string& filename);

void __closeXml();

void __printXml(const char* s);

void __printXml(const std::string& s);

void __printlnXml(const char* s);

void __printlnXml(const std::string& s);

// CODE FOR HANDLING SIGNALS (VARIOUS PROGRAM CRASHES)
// #define SIGSTACK ((int) 0xdeadbeef)
// #define SIGUNKNOWN ((int) 0xcafebabe)
// #define SIGTIMEOUT ((int) 0xf00df00d)

void __codeStepByStepSignalHandler(int sig);
#if !defined(_WIN32)
void __posixSignalHandler(int sig, siginfo_t* /*siginfo*/, void* /*context*/);
#endif // !defined(_WIN32)

// function to convert an array to string for printing
template <typename T>
std::string arrayToString(T a[], int length) {
    std::ostringstream out;
    out << "{";
    if (length > 0) {
        writeGenericValue(out, a[0], /* forceQuotes */ true);
        for (int i = 1; i < length; i++) {
            out << ", ";
            writeGenericValue(out, a[i], /* forceQuotes */ true);
        }
    }
    out << "}";
    return out.str();
}

// functions to parse various collections from strings
void ArrayIntList_fromString(ArrayIntList& list, const std::string& str);
void AssassinNode_fromString(AssassinNode*& ptr, const std::string& str);
void BasicGraph_fromString(BasicGraph& graph, const std::string& str);
void BinaryTree_fromString(BinaryTree& tree, const std::string& str);
void BinaryTreeNode_fromString(BinaryTreeNode*& root, const std::string& str);
void BinaryTreeNodeptr_fromString(BinaryTreeNode*& root, const std::string& str);
void BinaryTreeNodeChar_fromString(BinaryTreeNodeChar*& root, const std::string& str);
void BinaryTreeNodeCharptr_fromString(BinaryTreeNodeChar*& root, const std::string& str);
void BinaryTreeNodeDouble_fromString(BinaryTreeNodeDouble*& root, const std::string& str);
void BinaryTreeNodeString_fromString(BinaryTreeNodeString*& root, const std::string& str);
void HeapPriorityQueue_fromString(HeapPriorityQueue& pqueue, const std::string& str);
void LinkedIntList_fromString(LinkedIntList& list, const std::string& str);
void ListNode_fromString(ListNode*& ptr, const std::string& str);
void ListNodeptr_fromString(ListNode*& ptr, const std::string& str);
void ListNodeDouble_fromString(ListNodeDouble*& ptr, const std::string& str);
void ListNodeDoubleptr_fromString(ListNodeDouble*& ptr, const std::string& str);
void ListNodeString_fromString(ListNodeString*& ptr, const std::string& str);
void ListNodeStringptr_fromString(ListNodeString*& ptr, const std::string& str);

// this one's body must be here in .h file because it's a template
template <typename T>
void Vector_fromString(Vector<T>& v, const std::string& str) {
    std::istringstream input(str);
    input >> v;
}

// build a set of words from a file, a la Lexicon
// (we use this to initialize a set of words from a file in one line)
Set<string> setFromFile(const std::string& filename, bool cache = true);

// helpers for parts of main() function
void main_begin(int argc, char** argv);
void main_end();

// code for assertions (used in classes+objects problems)
#ifndef _codestepbystep_assertions
#define _codestepbystep_assertions
namespace Assertions {
void assertionPrint(const std::string& msg,
                    const std::string& assertType,
                    const std::string& valueType,
                    const std::string& expected,
                    const std::string& actual,
                    Map<std::string, std::string> attrs = {});

template <typename T>
void assertEquals(const std::string& msg, const std::string& type, T expected, T actual,
                  Map<std::string, std::string> attrs = {}) {
    std::string expStr = genericValueToString(expected);
    std::string actStr = genericValueToString(actual);
    assertionPrint(msg, "assertEquals", type, expStr, actStr, attrs);
}

template <typename T>
void assertEquals(const std::string& msg, T expected, T actual,
                  Map<std::string, std::string> attrs = {}) {
    assertEquals(msg, "T", expected, actual, attrs);
}

void assertEqualsBool(const std::string& msg, bool expected, bool actual);
void assertEqualsChar(const std::string& msg, char expected, char actual);
void assertEqualsDouble(const std::string& msg, double expected, double actual, double tolerance = 0.0001);
void assertEqualsInt(const std::string& msg, int expected, int actual);
void assertEqualsString(const std::string& msg, std::string expected, std::string actual);
void assertTrue(const std::string& msg, bool test);
void assertFalse(const std::string& msg, bool test);
void assertFail(const std::string& msg);
void setTestName(const std::string& name);
} // namespace CodeStepByStep::Assertions
#endif // _codestepbystep_assertions

} // namespace CodeStepByStep


#endif // _codestepbystep_h

/////////////////////// END code extracted from StanfordCPPLib_CodeStepByStep_Project/src/codestepbystep.h ///////////////////////

